/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { CheckoutModule, ErrorLocation, IGiftCardExtend } from '@msdyn365-commerce/global-state';
import {
    getGiftCardAsync,
    getTenderTypesAsync,
    resolveCardTypesAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import {
    CardType,
    CardTypeInfo,
    GiftCard,
    RetailOperation,
    TenderType
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateProps, withModuleState, EnabledPaymentsForOBO } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import { computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { OPERATIONS } from '@msdyn365-commerce-modules/checkout';
import { ICheckoutCodOptionData } from './checkout-cod-option.data';
import { ICheckoutCodOptionConfig, ICheckoutCodOptionProps, ICheckoutCodOptionResources } from './checkout-cod-option.props.autogenerated';
import { getForm, IForm } from './components/get-form';
import { getList, IList } from './components/get-list';
import TitleCompoent from './components/title';
import { focusOnCheckoutError } from '@msdyn365-commerce-modules/checkout';
import { getCartState } from '@msdyn365-commerce/global-state';
import CodPaymentService from '../../shared/CodPaymentService';
import { isEmpty } from '@msdyn365-commerce/retail-proxy';

export * from './components/get-form';
export * from './components/get-item';
export * from './components/get-list';

interface ICheckoutGiftCardState {
    isFetchingGiftCard: boolean;
    errorMessage: string;
    giftCardNumber: string;
    giftCardPin: string;
    giftCardExp: string;
    isMobileModalOpen?: boolean;
    isCodSelected?: boolean;
    mobileNumberOTP: string;
    isRadioButtonChecked: boolean;
    isOTPVerified: boolean;
    isPlaceOrderLoading?: boolean;
    codChargeAmount: number;
}

enum SupportedGiftCardType {
    Internal = 'internal',
    External = 'external',
    Both = 'both'
}

export interface ICheckoutGiftCardModuleProps extends ICheckoutCodOptionProps<ICheckoutCodOptionData>, IModuleStateProps {}

export interface IShowResource {
    title: React.ReactNode;
    list?: IList;
}

export interface IAddResource {
    form: IForm;
    list?: IList;
    config?: ICheckoutCodOptionConfig;
    resources?: ICheckoutCodOptionResources;
    codChargeAmount?: number;
    error?: string;
}

const codPaymentService = CodPaymentService.getInstance();

export interface ICheckoutGiftCardViewProps extends ICheckoutCodOptionProps<{}>, ICheckoutGiftCardState {
    className?: string;

    showGiftCard?: IShowResource;
    addGiftCard?: IAddResource;

    checkoutGiftCardProps: IModuleProps;
    couldPaidByGiftCard?: boolean;
    isEnabled?: boolean;
    checkoutErrorRef?: React.RefObject<HTMLElement>;
    onEdit?(): void;
    onCancel?(): void;
    onSubmit?(): void;
    enterGiftCardNumber?(giftCardNumber: string): void;
    enterGiftCardPin?(giftCardNumber: string): void;
    enterGiftCardExp?(giftCardNumber: string): void;
    removeGiftCard?(giftCardNumber: string): void;
    applyGiftCard?(): void;
    closeModal(): void;
    codMobileNumber?: string;
    setCodSelected(): void;
    isAuthenticated: boolean;
    setMobileNumberOTP(otpValue: string): void;
    setOTPVerified(verify: boolean): void;
    handleCODButtonCheck(value: boolean): void;
    handleCODSelectedOption(value: string): void;
}

/**
 *
 * CheckoutGiftCard component.
 * @extends {React.Component<ICheckoutCodOptionProps<ICheckoutCodOptionData>, ICheckoutGiftCardState>}
 */
@observer
export class CheckoutGiftCard extends React.Component<ICheckoutGiftCardModuleProps, ICheckoutGiftCardState> {
    public state: ICheckoutGiftCardState = {
        isFetchingGiftCard: false,
        errorMessage: '',
        giftCardNumber: '',
        giftCardPin: '',
        giftCardExp: '',
        isMobileModalOpen: false,
        isCodSelected: false,
        mobileNumberOTP: '',
        isOTPVerified: false,
        isRadioButtonChecked: false,
        isPlaceOrderLoading: false,
        codChargeAmount: 0
    };

    private readonly inputRef: React.RefObject<HTMLInputElement> = React.createRef();

    private readonly inputPinRef: React.RefObject<HTMLInputElement> = React.createRef();

    private readonly inputExpRef: React.RefObject<HTMLInputElement> = React.createRef();

    private readonly checkoutErrorRef: React.RefObject<HTMLElement> = React.createRef();

    private readonly radioButtonRef: React.RefObject<HTMLInputElement> = React.createRef();

    private handleCODOptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const selectedOption = event.target.value;
        this.handleCODSelectedOption(selectedOption);

        if (this.props.context.request.user.isAuthenticated && !this.state.isOTPVerified) {
            this.setCodSelected();
            this.handleCODButtonCheck(true);
            this.handleCodClick();
        }
    };

    private handleCODSelectedOption = async (selectedOption: string) => {
        // await this.korApplyCODChargesRequest();
        codPaymentService.setSelectedOption(selectedOption);
        codPaymentService.setCODAmount(this.state.codChargeAmount);
    };

    @computed get isDataReady(): boolean {
        return (this.props.data.checkout.result && this.props.data.checkout.status) === 'SUCCESS';
    }

    @computed get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.loyaltyAmount) {
            return 0;
        }
        return checkoutState.loyaltyAmount;
    }

    @computed get getCustomerAccountAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.customerAccountAmount ? checkoutState.customerAccountAmount : 0;
    }

    @computed get getGiftCardTotalAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count: number, giftCard: IGiftCardExtend) => {
            const balance: number = giftCard.Balance || 0;
            return count + balance;
        }, 0);
    }

    @computed get disableCashOnDelivery(): boolean {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return true;
        }
        return this.getLoyaltyAmount + this.getCustomerAccountAmount + this.getGiftCardTotalAmount > 0;
    }

    @computed get shouldPayGiftCard(): boolean {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return false;
        }

        // Use gift card card when loyalty points do not cover the total amount
        // const amountDue = (cart.TotalAmount || 0) - this.getLoyaltyAmount - this.getCustomerAccountAmount;
        const amountDue = cart.TotalAmount || 0;
        return amountDue > 0;
    }

    @computed get isOtherPaymentsEnabled(): boolean {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return false;
        }

        // Use gift card card when loyalty points do not cover the total amount
        const amountDue = this.getLoyaltyAmount + this.getCustomerAccountAmount + this.getGiftCardTotalAmount;
        return amountDue > 0;
    }

    @computed get hasSelectedItem(): boolean {
        const {
            data: { checkout }
        } = this.props;
        const giftCards = checkout.result && checkout.result.giftCardExtends;
        return !!giftCards && giftCards.length > 0;
    }

    private handleKorCODPlaceOrderTrigger = (option: string, amount: number, codSelected: boolean, codOrderFailure: string): void => {
        this.setState({ errorMessage: codOrderFailure });
    };

    public componentDidMount(): void {
        // Listen for changes in radio button state
        codPaymentService.addListener(this.handleKorCODPlaceOrderTrigger);

        // Set initial state based on current selected option
        this.setState({ errorMessage: codPaymentService.getCODOrderFailure() });
        when(
            () => this.isDataReady,
            () => {
                this.init();
                this.korGetCODChargeAmount();
            }
        );

        reaction(
            () => this.isOtherPaymentsEnabled, // Observable or computed value
            otherPaymentEnabled => {
                if (this.state.isOTPVerified || this.state.isRadioButtonChecked || this.props.context.request.user.isAuthenticated) {
                    if (otherPaymentEnabled) {
                        this.setState({ isRadioButtonChecked: false, isCodSelected: false });
                        codPaymentService.setSelectedOption('');
                    }
                }
            }
        );

        if (this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging) {
            reaction(
                () => this.props.data.checkout.result?.checkoutError,
                checkoutError => {
                    if (checkoutError && checkoutError.errorLocation === ErrorLocation.CheckoutGiftCard && checkoutError.errorMessage) {
                        this.setError(checkoutError.errorMessage);
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.checkoutErrorFocus,
                checkoutErrorFocus => {
                    if (checkoutErrorFocus === CheckoutModule.CheckoutGiftCard) {
                        focusOnCheckoutError(this.checkoutErrorRef, this.props.context.actionContext);
                    }
                }
            );
        }

        const radioButton = this.radioButtonRef.current;
        if (radioButton) {
            radioButton.addEventListener('click', this.handleClick);
        }
    }

    public componentWillUnmount() {
        const radioButton = this.radioButtonRef.current;
        if (radioButton) {
            radioButton.removeEventListener('click', this.handleClick);
        }
        codPaymentService.removeListener(this.handleKorCODPlaceOrderTrigger);
    }

    private readonly korGetCODChargeAmount = async (): Promise<any> => {
        const cRetailURL = this.props.context.request.apiSettings.baseUrl;
        const cRetailOUN = this.props.context.request.apiSettings.oun ? this.props.context.request.apiSettings.oun : '';

        const cKORGetCODChargeAmountUrl = `${cRetailURL}commerce/KORGetCODChargeAmount?api-version=7.3`;

        try {
            const response = await fetch(cKORGetCODChargeAmountUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    OUN: cRetailOUN,
                    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0'
                }
            });

            if (response.status === 200) {
                const data = await response.json();
                if (data.value !== undefined && data.value !== null) {
                    this.setState({ codChargeAmount: data.value });
                } else {
                    this.setState({ errorMessage: this.props.resources.codChargeAmountErrorMessage });
                }
            } else {
                this.setState({ errorMessage: this.props.resources.codChargeAmountErrorMessage });
            }
        } catch (error) {
            this.setState({ errorMessage: this.props.resources.codChargeAmountErrorMessage });
        }
    };

    private handleClick = (event: Event) => {
        const radioButton = this.radioButtonRef.current;
        if (this.isOtherPaymentsEnabled) {
            this.setError(this.props.config.codIsNotApplicableMessage || this.props.resources.codIsNotApplicableMessage);
        } else {
            this.setError('');
        }
        if (radioButton && isEmpty(this.state.errorMessage) && !this.isOtherPaymentsEnabled) {
            if (!this.props.context.request.user.isAuthenticated && !this.state.isOTPVerified) {
                event.preventDefault();
                this.setState({ isMobileModalOpen: true, isRadioButtonChecked: false });
            } else if (!this.props.context.request.user.isAuthenticated && this.state.isOTPVerified) {
                this.handleCODOptionChange({ target: radioButton } as React.ChangeEvent<HTMLInputElement>);
                this.handleCODButtonCheck(true);
                this.setCodSelected();
            } else {
                this.setState({ isRadioButtonChecked: radioButton.checked });
                this.handleCODOptionChange({ target: radioButton } as React.ChangeEvent<HTMLInputElement>);
            }
        }
    };

    public shouldComponentUpdate(nextProps: ICheckoutGiftCardModuleProps, nextState: ICheckoutGiftCardState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    private handleCODButtonCheck = (value: boolean) => {
        this.setState({ isRadioButtonChecked: value });
    };

    private handleCodClick = () => {
        this.setState({ isMobileModalOpen: true });
    };

    private closeModal = () => {
        this.setState({ isMobileModalOpen: false });
    };

    private setCodSelected = () => {
        codPaymentService.setCODSelected(!this.state.isCodSelected);
        this.setState({ isCodSelected: !this.state.isCodSelected });
    };

    private setMobileNumberOPT = (value: string) => {
        this.setState({ mobileNumberOTP: value });
    };

    private setOPTVerified = (value: boolean) => {
        this.setState({ isOTPVerified: value });
    };

    private readonly korPreCheckoutRequest = async (): Promise<any> => {
        this.setState({ isPlaceOrderLoading: true });
        const cRetailURL = this.props.context.request.apiSettings.baseUrl;
        const cRetailOUN = this.props.context.request.apiSettings.oun ? this.props.context.request.apiSettings.oun : '';

        const cKORPreCheckoutRequestUrl = `${cRetailURL}commerce/KORPreCheckoutRequest?api-version=7.3`;
        const currentCartState = await getCartState(this.props.context?.actionContext);
        const checkoutState = this.props.data.checkout.result;

        const cGuestCheckoutEmail = checkoutState?.guestCheckoutEmail;
        const cCartId = checkoutState?.checkoutCart.cart.Id;
        const cShippingCharge = checkoutState?.checkoutCart.cart.ShippingChargeAmount || 0;
        const cTaxAmount = checkoutState?.checkoutCart.cart.TaxAmount || 0;
        const cCodChargesAmount = this.state.codChargeAmount || 0;
        const cAmountDue = (checkoutState?.checkoutCart.cart.AmountDue || 0) + cCodChargesAmount;
        const cDeliveryMode = checkoutState?.checkoutCart.cart.DeliveryMode;

        try {
            const response = await fetch(cKORPreCheckoutRequestUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    OUN: cRetailOUN,
                    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0'
                },
                body: JSON.stringify({
                    // context: this.props.context,
                    cartId: cCartId,
                    receiptEmail: cGuestCheckoutEmail,
                    modeOfDeliver: cDeliveryMode,
                    shippingCharges: Math.round(cShippingCharge * 100) / 100,
                    totalDueAmt: Math.round(cAmountDue * 100) / 100,
                    CODCharges: Math.round(cCodChargesAmount * 100) / 100,
                    taxAmount: Math.round(cTaxAmount * 100) / 100
                })
            });

            if (response.status === 200) {
                const data = await response.json();
                const cCartLineIds: string[] = currentCartState.cart.CartLines
                    ? currentCartState.cart.CartLines.map(line => line.LineId!.toString())
                    : [];
                const input = {
                    cartLineIds: cCartLineIds
                };
                if (data && data.value) {
                    await currentCartState.refreshCart({});
                    await currentCartState.removeCartLines(input);
                    await currentCartState.removeAllPromoCodes({});
                    if (this.props.config.codOrderConfirmationLink) {
                        window.location.href = `${this.props.config.codOrderConfirmationLink?.linkUrl.destinationUrl}?orderid=${data.value}&iscod=true`;
                    }
                } else {
                    this.setError(this.props.resources.placeOrderErrorMessage);
                }
            } else {
                this.setError(this.props.resources.placeOrderErrorMessage);
            }
        } catch (error) {
            this.setError(this.props.resources.placeOrderErrorMessage);
            console.error('place order error:', error);
        } finally {
            this.setState({ isPlaceOrderLoading: false });
        }
    };

    public render(): JSX.Element | null {
        const {
            moduleState: { isReady },
            data: { checkout },
            config: { className, showAdditionalFields },
            resources
        } = this.props;
        const { errorMessage, giftCardNumber, giftCardPin, giftCardExp } = this.state;
        const giftCards = checkout.result && checkout.result.giftCardExtends;
        const additionalFields = showAdditionalFields;
        const supportedGiftCardType = this.props.context.app.config.giftCardSupported;
        const codMobileNumber = checkout.result?.shippingAddress?.Phone ? checkout.result?.shippingAddress?.Phone : '';
        const cAuthenticated = this.props.context.request.user.isAuthenticated ? this.props.context.request.user.isAuthenticated : false;

        if (!this.isEnabled() || (!this.shouldPayGiftCard && !isReady)) {
            this.props.context.telemetry.error('Checkout giftcard content is empty, module wont render');
            return null;
        }

        if (this.props.context.request.user.isOBORequest && EnabledPaymentsForOBO.GiftCard === 0) {
            this.props.context.telemetry.information('isOBORequest is enabled, Checkout gift card module wont render');
            return null;
        }

        const supportExternalGiftCard = supportedGiftCardType !== SupportedGiftCardType.Internal;

        const moduleClassName = classname('ms-checkout-gift-card ms-checkout-cash-on-delivery', className, isReady ? 'show' : 'add');

        const viewProps: ICheckoutGiftCardViewProps = {
            ...this.props,
            ...this.state,
            className: moduleClassName,
            checkoutErrorRef: this.checkoutErrorRef,

            checkoutGiftCardProps: { moduleProps: this.props, className: moduleClassName },
            couldPaidByGiftCard: this.couldPaidByGiftCard(),
            isEnabled: this.isEnabled(),
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            enterGiftCardNumber: this.enterGiftCardNumber,
            enterGiftCardPin: this.enterGiftCardPin,
            enterGiftCardExp: this.enterGiftCardExp,
            removeGiftCard: this.removeGiftCard,
            applyGiftCard: this.applyGiftCard,
            showGiftCard: isReady
                ? {
                      title: <TitleCompoent title={resources.giftCardFormLabel} />,
                      list: getList({
                          canRemove: false,
                          getFormattedPrice: this.getFormattedPrice,
                          giftCards: giftCards && [...giftCards], // Note: ReadOnly Checkout State GiftCard[] is not assignable to GiftCard[] type
                          onRemoveGiftCard: this.removeGiftCard,
                          resources
                      })
                  }
                : undefined,
            addGiftCard: !isReady
                ? {
                      form: getForm({
                          errorMessage,
                          giftCardNumber,
                          giftCardPin,
                          giftCardExp,
                          inputRef: this.inputRef,
                          inputPinRef: this.inputPinRef,
                          inputExpRef: this.inputExpRef,
                          resources,
                          onEnterGiftCardNumber: this.enterGiftCardNumber,
                          onEnterGiftCardPin: this.enterGiftCardPin,
                          onEnterGiftCardExp: this.enterGiftCardExp,
                          onApplyGiftCard: this.applyGiftCard,
                          supportExternalGiftCard,
                          additionalFields,
                          disableAddGiftCard: this.disableCashOnDelivery,
                          handleCodClick: this.handleCodClick,
                          handlePreCheckout: this.korPreCheckoutRequest,
                          setCodSelected: this.setCodSelected,
                          isCodSelected: this.state.isCodSelected ? this.state.isCodSelected : false,
                          isAuthenticated: cAuthenticated,
                          mobileNumberOTP: this.state.mobileNumberOTP,
                          handleCODOptionChange: this.handleCODOptionChange,
                          radioButtonRef: this.radioButtonRef,
                          isRadioButtonChecked: this.state.isRadioButtonChecked,
                          isPlaceOrderLoading: this.state.isPlaceOrderLoading
                      }),
                      list: getList({
                          canRemove: true,
                          getFormattedPrice: this.getFormattedPrice,
                          giftCards: giftCards && [...giftCards], // Note: ReadOnly Checkout State GiftCard[] is not assignable to GiftCard[] type
                          onRemoveGiftCard: this.removeGiftCard,
                          resources
                      })
                  }
                : undefined,
            closeModal: this.closeModal,
            codMobileNumber: codMobileNumber,
            setCodSelected: this.setCodSelected,
            isAuthenticated: cAuthenticated,
            setMobileNumberOTP: this.setMobileNumberOPT,
            handleCODButtonCheck: this.handleCODButtonCheck,
            setOTPVerified: this.setOPTVerified,
            handleCODSelectedOption: this.handleCODSelectedOption
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private readonly init = (): void => {
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            isRequired: false,
            ...(!this.isEnabled() && { status: 'disabled' })
        });

        const giftCards = this.props.data.checkout.result?.giftCardExtends;
        if (giftCards && giftCards.length > 0) {
            this.props.moduleState.onReady();
        } else if (this.props.data.checkout.result?.isPaymentVerificationRedirection) {
            this.props.moduleState.onSkip();
        }
    };

    private readonly couldPaidByGiftCard = (): boolean => {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart?.cart : undefined;
        if (!cart) {
            return false;
        }

        // Use gift card when it is not free
        return (cart.TotalAmount || 0) > 0;
    };

    private readonly isEnabled = (): boolean => {
        if (
            !this.props.context.request.user.isAuthenticated &&
            this.props.context.app.config.giftCardSupported !== SupportedGiftCardType.External &&
            !this.props.config.shouldBeEnabledForGuest
        ) {
            return false;
        }
        return this.couldPaidByGiftCard();
    };

    private readonly onEdit = (): void => {
        this.props.telemetry.information('Payment section gift card onEdit is called.');

        // Show add gift card form
        this.props.moduleState.onUpdating();
    };

    private readonly onCancel = (): void => {
        this.props.telemetry.information('Payment section gift card onCancel is called.');

        this.handleCancelOrSubmit();
    };

    private readonly onSubmit = (): void => {
        this.props.telemetry.information('Payment section gift card onSubmit is called.');

        this.handleCancelOrSubmit();
    };

    private readonly handleCancelOrSubmit = () => {
        if (this.hasSelectedItem) {
            // Show summary screen
            this.props.moduleState.onReady();
        } else {
            // Skip the module
            this.props.moduleState.onSkip();
        }
    };

    private readonly getFormattedPrice = (price: number = 0, currencyCode: string = 'USD'): string => {
        return this.props.context.cultureFormatter.formatCurrency(price, currencyCode);
    };

    private readonly enterGiftCardNumber = (giftCardNumber: string): void => {
        this.setState({
            giftCardNumber
        });
        this.clearError();
    };

    private readonly enterGiftCardPin = (giftCardPin: string): void => {
        this.setState({
            giftCardPin
        });
        this.clearError();
    };

    private readonly enterGiftCardExp = (giftCardExp: string): void => {
        this.setState({
            giftCardExp
        });
        this.clearError();
    };

    private readonly setError = (errorMessage: string): void => {
        this.props.telemetry.error('Error', errorMessage);
        this.props.telemetry.debug('Error', errorMessage);
        this.props.moduleState.setHasError(true);
        this.setState({
            errorMessage
        });
    };

    private readonly clearError = (): void => {
        this.props.moduleState.setHasError(false);
        this.setState({
            errorMessage: ''
        });
    };

    private readonly removeGiftCard = async (giftCardNumber: string): Promise<void> => {
        this.props.telemetry.information('Payment section gift card remove is called.');

        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState) {
            return;
        }

        await checkoutState.removeGiftCard({ giftCardNumber });
    };

    private readonly applyGiftCard = async (): Promise<void> => {
        this.props.telemetry.information('Payment section gift card apply is called.');

        if (this.state.isFetchingGiftCard) {
            return;
        }
        this.setState({
            isFetchingGiftCard: true
        });

        const checkoutState = this.props.data.checkout.result;
        const giftCardNumber = this.state.giftCardNumber.trim();
        const giftCardPin = this.state.giftCardPin.trim();
        const giftCardExp = this.state.giftCardExp.trim();

        const giftCardTypes = await this.getGiftCardTypes(giftCardNumber);
        const giftCardType = giftCardTypes && giftCardTypes[0];
        const isPinRequired = giftCardType && giftCardType.IsPinRequired;
        const isExpRequired = giftCardType && giftCardType.IsExpirationDateRequired;
        const tenderTypeId = giftCardType && giftCardType.PaymentMethodId;
        const giftCard = await this.getGiftCard(giftCardNumber, giftCardPin, giftCardExp, isPinRequired, isExpRequired, tenderTypeId);

        if (checkoutState && giftCard) {
            await checkoutState.addGiftCard({
                giftCard,
                additionalProperties: { Pin: giftCardPin, ExpirationDate: giftCardExp, TenderTypeId: tenderTypeId }
            });
            this.clearError();
            this.setState({
                giftCardNumber: '',
                giftCardPin: '',
                giftCardExp: '',
                isFetchingGiftCard: false
            });
            return Promise.resolve();
        }
        const input = this.inputRef && this.inputRef.current && this.inputRef.current.focus && (this.inputRef.current as HTMLElement);
        input && input.focus();
        this.setState({
            isFetchingGiftCard: false
        });
        this.props.telemetry.information('Payment section fetching gift card is failed.');
    };

    private readonly findGiftcardTenderTypes = (
        tenderTypes: TenderType[],
        operationId: RetailOperation,
        giftcardType: string
    ): string[] | undefined => {
        let matchedTenderTypes: TenderType[] | undefined;

        switch (giftcardType) {
            case SupportedGiftCardType.Internal:
                matchedTenderTypes = tenderTypes.filter(
                    tenderType => tenderType.OperationId === operationId && tenderType.ConnectorId === ''
                );
                break;
            case SupportedGiftCardType.External:
                matchedTenderTypes = tenderTypes.filter(
                    tenderType => tenderType.OperationId === operationId && tenderType.ConnectorId !== ''
                );
                break;
            default:
                throw new Error('Invalid gift card type');
        }

        if (matchedTenderTypes) {
            return matchedTenderTypes.map(tenderType => tenderType.TenderTypeId || '');
        }
        return;
    };

    private readonly getGiftCard = async (
        giftCardNumber: string,
        giftCardPin: string,
        giftCardExp: string,
        isPinRequired: boolean | undefined,
        isExpRequired: boolean | undefined,
        tenderTypeId: string | undefined
    ): Promise<GiftCard | undefined> => {
        const {
            resources: { noBalanceError, invalidCardInfoError, invalidCardTypeError, noCardPinError, noCardExpError }
        } = this.props;

        const supportedGiftCardType = this.props.context.app.config.giftCardSupported;

        if (!tenderTypeId) {
            return undefined;
        }

        const tenderTypes = await getTenderTypesAsync({ callerContext: this.props.context.actionContext, queryResultSettings: {} }).catch(
            error => {
                throw error;
            }
        );

        if (!tenderTypes) {
            throw new Error('Fail to get gift card tender line');
        }
        const internalGiftcardTenderTypes = this.findGiftcardTenderTypes(
            tenderTypes,
            OPERATIONS.PayGiftCertificate,
            SupportedGiftCardType.Internal
        );
        const externalGiftcardTenderTypes = this.findGiftcardTenderTypes(
            tenderTypes,
            OPERATIONS.PayGiftCertificate,
            SupportedGiftCardType.External
        );

        switch (supportedGiftCardType) {
            case undefined:
            case SupportedGiftCardType.Internal:
                if (!internalGiftcardTenderTypes?.includes(tenderTypeId)) {
                    this.setError(invalidCardTypeError);
                    return undefined;
                }
                break;
            case SupportedGiftCardType.External:
                if (!externalGiftcardTenderTypes?.includes(tenderTypeId)) {
                    this.setError(invalidCardTypeError);
                    return undefined;
                }
                break;
            case SupportedGiftCardType.Both:
                if (!internalGiftcardTenderTypes?.includes(tenderTypeId) && !externalGiftcardTenderTypes?.includes(tenderTypeId)) {
                    this.setError(invalidCardTypeError);
                    return undefined;
                }
                break;
            default:
                throw new Error('Unsupported gift card type');
        }

        if (isPinRequired && giftCardPin === '') {
            this.setError(noCardPinError);
            return undefined;
        }

        if (isExpRequired && giftCardExp === '') {
            this.setError(noCardExpError);
            return undefined;
        }

        const month = Number.parseInt(giftCardExp.split('/')[0], 10);
        const year = Number.parseInt(giftCardExp.split('/')[1], 10);

        return getGiftCardAsync({ callerContext: this.props.context.actionContext }, giftCardNumber, tenderTypeId, giftCardPin, month, year)
            .then(activeGiftCard => {
                if (!activeGiftCard.Balance || activeGiftCard.Balance === 0) {
                    this.setError(noBalanceError);
                    return;
                }
                return activeGiftCard;
            })
            .catch(error => {
                this.setError(invalidCardInfoError);
                return undefined;
            });
    };

    private readonly getGiftCardTypes = async (giftCardNumber: string): Promise<CardTypeInfo[] | undefined> => {
        const {
            resources: { emptyInputError, duplicatedCodeError, invalidCodeError },
            data: { checkout }
        } = this.props;

        if (!giftCardNumber) {
            this.setError(emptyInputError);
            return undefined;
        }

        const isDuplicated = checkout.result && checkout.result.giftCardExtends.some((card: GiftCard) => card.Id === giftCardNumber);
        if (isDuplicated) {
            this.setError(duplicatedCodeError);
            return undefined;
        }

        return resolveCardTypesAsync({ callerContext: this.props.context.actionContext }, giftCardNumber, CardType.GiftCard)
            .then(giftCardTypes => {
                if (!giftCardTypes || giftCardTypes.length === 0 || giftCardTypes[0] === undefined) {
                    this.setError(invalidCodeError);
                    return;
                }
                return giftCardTypes;
            })
            .catch(error => {
                this.setError(invalidCodeError);
                return undefined;
            });
    };
}

export default withModuleState(CheckoutGiftCard);
