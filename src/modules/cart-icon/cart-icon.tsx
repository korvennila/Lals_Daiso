/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { AddToCartBehavior, CartIconComponent } from '@msdyn365-commerce/components';
import { getUrlSync, IDictionary, IImageSettings, msdyn365Commerce, TelemetryEvent } from '@msdyn365-commerce/core';
import {
    CartLine,
    ChannelDeliveryOptionConfiguration,
    CartLineValidationResultsByLineId,
    OrgUnitLocation
} from '@msdyn365-commerce/retail-proxy';
import { validateCartAsync } from '@msdyn365-commerce-modules/cart-utilities';
import { ArrayExtensions, validateCartLinesInventory } from '@msdyn365-commerce-modules/retail-actions';
import {
    Button,
    getPayloadObject,
    getTelemetryAttributes,
    getTelemetryObject,
    INodeProps,
    ITelemetryContent,
    TelemetryConstant,
    UncontrolledTooltip,
    updateMaxQuantityForCartLineItem,
    urlCheck
} from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import React from 'react';

import { ICartIconData } from './cart-icon.data';
import { cartLinesSortOrder, ICartIconProps } from './cart-icon.props.autogenerated';
import { FlyoutCartLineItems, IFlyoutCartLineItemViewProps } from './components/flyout-cart-line-items';
import { getMiniCartData, IMiniCartData } from './utils/get-products-in-mini-cart';

export interface IMiniCartState {
    miniCartData: IMiniCartData;
    orgUnitLocations?: OrgUnitLocation[];
    isQuantityLimitsFeatureEnabled: boolean;
    isCartValid: boolean;
}

export interface ICartIconViewProps extends ICartIconProps<ICartIconData> {
    className: string;
    cartIcon: React.ReactNode;
    FlyoutContainer?: INodeProps;
    CartlinesWrapper: INodeProps;
    miniCartWrapper: INodeProps;
    miniCartItemWrapper: INodeProps;
    cartlines?: IFlyoutCartLineItemViewProps[];
    flyoutTitle: React.ReactNode;
    totalPrice: React.ReactNode;
    checkoutAsGuestButton?: React.ReactNode;
    checkoutAsSignInUserButton?: React.ReactNode;
    goToCartButton?: React.ReactNode;
    waitingComponent?: React.ReactNode;
    isCartLoading: boolean;
    checkoutBlockedDueToUnavailableFunds?: React.ReactNode;

    removeItemClickHandler(cartlineToRemove: CartLine): void;
}

/**
 *
 * Cart component.
 * @extends {React.PureComponent<ICartProps<ICartData>>}
 */
@observer
class CartIcon extends React.Component<ICartIconProps<ICartIconData>, IMiniCartState> {
    private readonly telemetryContent: ITelemetryContent;

    private readonly checkoutBySignInAttributes: IDictionary<string> | undefined;

    private readonly checkoutByGuestAttributes: IDictionary<string> | undefined;

    private readonly viewShoppingBagAttributes: IDictionary<string> | undefined;

    private retailMultiplePickUpOptionEnabled?: boolean = false;

    private channelDeliveryOptionConfig?: ChannelDeliveryOptionConfiguration;

    private lastValidatedCartVersion: number | undefined;

    constructor(props: ICartIconProps<ICartIconData>) {
        super(props);
        this.state = {
            miniCartData: {},
            isCartValid: true,
            isQuantityLimitsFeatureEnabled: false
        };
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        const payload = getPayloadObject(TelemetryEvent.CheckOut, this.telemetryContent, TelemetryConstant.Checkout);
        this.checkoutBySignInAttributes = getTelemetryAttributes(this.telemetryContent, payload);

        payload.contentAction.etext = TelemetryConstant.GuestCheckout;
        this.checkoutByGuestAttributes = getTelemetryAttributes(this.telemetryContent, payload);

        payload.contentAction.etext = TelemetryConstant.ViewShoppingBag;
        this.viewShoppingBagAttributes = getTelemetryAttributes(this.telemetryContent, payload);
    }

    public async componentDidMount(): Promise<void> {
        const context = this.props.context.actionContext;

        reaction(
            () => this.props.data.cart.result?.cart.CartLines,
            async () => {
                this.setState({
                    miniCartData: await getMiniCartData(context, this.props.data.cart.result!)
                });
            }
        );
        await this._setQuantityLimitsFeatureFlag();

        this.setState({
            orgUnitLocations: this.props.data.orgUnitLocations?.result
        });

        this._validateCart();
    }

    public componentDidUpdate(prevProps: ICartIconProps<ICartIconData>): void {
        this._validateCart();
    }

    public shouldComponentUpdate(nextProps: ICartIconProps<ICartIconData>, nextState: IMiniCartState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    // eslint-disable-next-line complexity -- disabling the complexity for this method for now as its causing lot of other warnings
    public render(): JSX.Element | null {
        const {
            id,
            typeName,
            config: { enableHoverCart, isAnonymousCheckout },
            context: {
                request: {
                    user: { isAuthenticated, signInUrl }
                }
            },
            context,
            resources
        } = this.props;

        const cart = (this.props.data.cart && this.props.data.cart.result) || undefined;
        const guestCheckoutUrl = getUrlSync('checkout', this.props.context.actionContext) || '';
        const cartUrl = getUrlSync('cart', this.props.context.actionContext) || '';
        const checkoutURL = this._getCheckoutURL(isAuthenticated, guestCheckoutUrl, signInUrl || '');
        const isCartEmpty = cart && cart.cart.CartLines && cart.cart.CartLines.length === 0;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- check config.
        const shouldShowMiniCart =
            cart?.isProductAddedToCart && this.props.context.app.config.addToCartBehavior === AddToCartBehavior.showMiniCart;
        const hasInvoiceLine = cart?.hasInvoiceLine;
        const emailDeliveryModeCode = this.props.context.request.channel?.EmailDeliveryModeCode;
        const cartLines = this._getCartLines();
        const validInventoryAcrossCartLines = validateCartLinesInventory(
            cart?.cart.CartLines ?? [],
            this.state.miniCartData.productAvailabilites ?? [],
            this.props.context.actionContext,
            this.state.miniCartData.products ?? [],
            emailDeliveryModeCode
        );
        const hasError =
            !validInventoryAcrossCartLines?.isValid ||
            (!validInventoryAcrossCartLines && !this.state.isCartValid) ||
            (cartLines ? cartLines.some(cartline => cartline.hasError) : false);
        const includeFlyout = this.props.data.cart && this.props.data.cart.status === 'SUCCESS' && enableHoverCart;
        const totalItemsInCart = cart?.totalItemsInCart ? cart.totalItemsInCart : 0;
        const goToCartButtonText = resources.goToCartButtonTitle.replace('{count}', totalItemsInCart.toString());
        const flyoutTitle = resources.flyoutTitle;
        const flyoutTooltip = {
            tag: UncontrolledTooltip,
            shouldShowMiniCart,
            placement: 'bottom-end',
            hideArrow: true,
            className: 'ms-cart-icon__flyout-container',
            trigger: 'hover',
            displayMode: 'FLYOUT',
            target: id,
            shouldShowCloseButton: true,
            cartPageUrl: cartUrl,
            hideAriaHidden: true
        };

        // If there are invoice lines, don't update mini cart price
        const price = (cart && !cart.hasInvoiceLine && cart.cart.TotalAmount) || undefined;
        const priceString = price
            ? resources.totalPriceFormatString.replace('{price}', context.cultureFormatter.formatCurrency(price))
            : '';
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        this.channelDeliveryOptionConfig = this.props.data.channelDeliveryOptionConfig?.result;
        this.retailMultiplePickUpOptionEnabled = this.props.data.featureState?.result?.find(
            feature => feature.Name === multiplePickupStoreSwitchName
        )?.IsEnabled;

        const viewProps = {
            ...this.props,
            cartIcon: (
                <CartIconComponent
                    cartLabel={resources.cartLabel}
                    cartQtyLabel={resources.cartQtyLabel}
                    context={context}
                    id={id}
                    typeName={typeName}
                    data={{ cart }}
                    telemetryContent={this.telemetryContent}
                />
            ),
            cartlines: cartLines,
            FlyoutContainer: includeFlyout ? flyoutTooltip : undefined,
            CartlinesWrapper: {
                className: 'ms-cart-icon__cart-lines'
            },
            miniCartWrapper: {
                className: classnames('ms-cart-icon'),
                id: this.props.id
            },
            miniCartItemWrapper: {
                className: classnames('msc-cart-lines-item')
            },

            // If there are invoice lines, don't update mini cart checkout button
            // Checkout button will display by default to maintain backward compatibility.  When Anonymous user checkout is enabled &&
            // user is authenticated then we will show the checkout button otherwise we will show the guest checkout button.
            checkoutAsSignInUserButton:
                !isCartEmpty && !hasInvoiceLine && (!isAnonymousCheckout || isAuthenticated) ? (
                    <Button
                        disabled={hasError}
                        className='ms-cart-icon__btn-checkout'
                        href={checkoutURL}
                        title={resources.checkoutButtonTitle}
                        {...this.checkoutBySignInAttributes}
                    >
                        {resources.checkoutButtonTitle}
                    </Button>
                ) : null,
            checkoutAsGuestButton:
                isAnonymousCheckout && !isCartEmpty && !isAuthenticated ? (
                    <Button
                        disabled={hasError}
                        className='ms-cart-icon__btn-guestcheckout'
                        href={guestCheckoutUrl}
                        title={resources.guestCheckoutButtonTitle}
                        {...this.checkoutByGuestAttributes}
                    >
                        {resources.guestCheckoutButtonTitle}
                    </Button>
                ) : null,
            goToCartButton: (
                <Button
                    className='ms-cart-icon__btn-gotocart'
                    href={cartUrl}
                    title={goToCartButtonText}
                    {...this.viewShoppingBagAttributes}
                >
                    {goToCartButtonText}
                </Button>
            ),
            checkoutBlockedDueToUnavailableFunds: null,
            flyoutTitle: <span className='ms-cart-icon__flyout-title'>{flyoutTitle}</span>,
            totalPrice: <div className='ms-cart-icon__subtotal'>{priceString}</div>
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private _validateCart(): void {
        const {
            data: { cart }
        } = this.props;
        const cartVersion = cart.result?.cart?.Version ?? undefined;
        if (this.lastValidatedCartVersion === cartVersion) {
            return;
        }

        this.lastValidatedCartVersion = cartVersion; // This field is populated to block concurrent requests

        if (this.state.isQuantityLimitsFeatureEnabled) {
            validateCartAsync(cart, this.props.telemetry, this.props.context)
                .then((result: CartLineValidationResultsByLineId | undefined) => {
                    this.setState({ isCartValid: !ArrayExtensions.hasElements(result?.ValidationResultsPairs) });
                })
                .catch(() => {
                    this.setState({ isCartValid: false });
                });
        } else {
            this.setState({ isCartValid: true });
        }
    }

    private _getCheckoutURL(isAuthenticated: boolean, guestCheckoutUrl: string, signInUrl: string): string {
        if (isAuthenticated) {
            return guestCheckoutUrl;
        }

        const isAbsoluteUrl = urlCheck(guestCheckoutUrl);
        let returnURL = guestCheckoutUrl;
        if (msdyn365Commerce.isBrowser && !isAbsoluteUrl) {
            returnURL = `${window.location.origin}${guestCheckoutUrl}`;
        }

        return `${signInUrl}${!signInUrl.includes('?') ? '?' : '&'}ru=${returnURL}`;
    }

    /**
     * Sort cartline items.
     * @param cartlines - Cartlines to be sorted.
     * @param sortOrder - Ascending or descending.
     * @returns - Sorted cartlines.
     */
    private readonly getSortedCartLines = (cartlines: CartLine[], sortOrder?: cartLinesSortOrder): CartLine[] => {
        const lines: CartLine[] = [...cartlines];
        const zero: number = 0;

        if (sortOrder === cartLinesSortOrder.descending) {
            return lines.sort((item1, item2) => (item2.LineNumber ?? zero) - (item1.LineNumber ?? zero));
        }
        return lines.sort((item1, item2) => (item1.LineNumber ?? zero) - (item2.LineNumber ?? zero));
    };

    private _getCartLines(): IFlyoutCartLineItemViewProps[] | null {
        const {
            context: {
                request: { channel: { PickupDeliveryModeCode } = { PickupDeliveryModeCode: undefined } }
            },
            config,
            telemetry,
            resources
        } = this.props;

        const imageSettings = this._getImageSettings(config.imageSettings);
        const cart = this.props.data.cart && this.props.data.cart.result;

        // Cart-icon could be placed in each page
        // so we check cart content to reduce number of RS calls
        return this.state.miniCartData.products && cart && cart.cart.CartLines && cart.cart.CartLines.length > 0
            ? FlyoutCartLineItems({
                  cartlines: this.getSortedCartLines(cart.cart.CartLines, config.cartLinesSortOrder),
                  products: this.state.miniCartData.products,
                  productAvailabilites: this.state.miniCartData.productAvailabilites,
                  productDeliveryOptions: this.state.miniCartData.deliveryOptions,
                  imageSettings,
                  outOfStockThreshold: this.props.context.app.config.outOfStockThreshold || 0,
                  isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                  maxCartlineQuantity: updateMaxQuantityForCartLineItem(this.props.context.app.config.maxQuantityForCartLineItem),
                  gridSettings: this.props.context.request.gridSettings!,
                  context: this.props.context,
                  typeName: this.props.typeName,
                  id: this.props.id,
                  resources: {
                      sizeString: resources.productDimensionTypeSize,
                      colorString: resources.productDimensionTypeColor,
                      configString: resources.productDimensionTypeConfiguration,
                      styleString: resources.productDimensionTypeStyle,
                      quantityDisplayString: resources.quantityDisplayText,
                      salesAgreementPricePrompt: resources.salesAgreementPricePrompt,
                      inputQuantityAriaLabel: '', // Not used
                      discountStringText: '', // Not used
                      originalPriceText: '',
                      currentPriceText: '',
                      shippingChargesText: '',
                      shippingText: resources.shippingText
                  },
                  telemetry,
                  removeButtonText: resources.removeCartButtonText,
                  outOfStockText: '', // Not used
                  outOfRangeOneText: '', // Not used
                  outOfRangeFormatText: '', // Not used
                  cartState: cart,
                  orgUnitLocations: this.state.orgUnitLocations,
                  removeItemClickHandler: this._removeItemFromCartHandler,
                  pickupDeliveryModeCode: PickupDeliveryModeCode,
                  telemetryContent: this.telemetryContent,
                  channelDeliveryOptionConfig: this.retailMultiplePickUpOptionEnabled ? this.channelDeliveryOptionConfig : undefined,
                  isQuantityLimitsFeatureEnabled: this.state.isQuantityLimitsFeatureEnabled,
                  catalogs: this.props.data.catalogs?.result
              })
            : null;
    }

    private readonly _getImageSettings = (imageSettings: IImageSettings | undefined): IImageSettings => {
        return (
            imageSettings || {
                viewports: {
                    xs: { q: 'w=80&h=94&m=6', w: 0, h: 0 },
                    sm: { q: 'w=148&h=174&m=6', w: 0, h: 0 },
                    lg: { q: 'w=148&h=174&m=6', w: 0, h: 0 }
                },
                lazyload: true
            }
        );
    };

    private readonly _removeItemFromCartHandler = (cartlineToRemove: CartLine) => {
        if (this.props.data.cart.result) {
            const input = {
                cartLineIds: [cartlineToRemove.LineId!.toString()]
            };
            this.props.data.cart.result.removeCartLines(input).catch(error => {
                this.props.telemetry.warning(error);
                this.props.telemetry.debug('Unable to Remove Cart Line');
            });
        }
    };

    private async _setQuantityLimitsFeatureFlag(): Promise<void> {
        const featureStatuses = await this.props.data.featureState;

        const isChannelQuantityLimitsFeatureEnabledInHq =
            featureStatuses?.find(
                featureState => featureState.Name === 'Dynamics.AX.Application.EcommerceQuantityLimitConfigurationsFeature'
            )?.IsEnabled || false;
        if (isChannelQuantityLimitsFeatureEnabledInHq) {
            this.setState({ isQuantityLimitsFeatureEnabled: true });
            return;
        }

        const useSiteBuilderSettings = featureStatuses?.find(
            featureState => featureState.Name === 'RevertToSiteBuilderOrderQuantityLimitsSettings'
        )?.IsEnabled;

        if (useSiteBuilderSettings) {
            const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
            if (!defaultOrderQuantityLimitsFeatureConfig || defaultOrderQuantityLimitsFeatureConfig === 'none') {
                this.setState({ isQuantityLimitsFeatureEnabled: false });
                return;
            }

            try {
                const featureStatuses = await this.props.data.featureState;
                const isQuantityLimitsFeatureEnabledInHq =
                    featureStatuses?.find(
                        featureState => featureState.Name === 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature'
                    )?.IsEnabled || false;
                if (!isQuantityLimitsFeatureEnabledInHq) {
                    this.setState({ isQuantityLimitsFeatureEnabled: false });
                    return;
                }
            } catch (error) {
                this.props.telemetry.warning(error);
                this.props.telemetry.debug('Unable to get feature states');
                this.setState({ isQuantityLimitsFeatureEnabled: false });
                return;
            }
            if (defaultOrderQuantityLimitsFeatureConfig === 'all') {
                this.setState({ isQuantityLimitsFeatureEnabled: true });
            } else {
                this.props.data.customerInformation
                    .then(customerInfo => {
                        const result =
                            !!customerInfo &&
                            ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
                                (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b));
                        this.setState({ isQuantityLimitsFeatureEnabled: result });
                    })
                    .catch(error => {
                        this.props.telemetry.warning(error);
                        this.props.telemetry.debug('Unable to get customer info');
                    });
            }
        } else {
            const cartConfiguration = await this.props.data.cartConfiguration;
            this.setState({ isQuantityLimitsFeatureEnabled: !(cartConfiguration?.IgnoreOrderSettings ?? false) });
            return;
        }
    }
}

export default CartIcon;
