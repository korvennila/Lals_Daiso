/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/// <reference types="bingmaps" />

/* eslint-disable no-duplicate-imports */
import * as Msdyn365 from '@msdyn365-commerce/core';
import { OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import { IModuleProps, INodeProps } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import { observable, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { ArrayExtensions } from '@msdyn365-commerce-modules/retail-actions';
import { IMapData } from './map.data';
import { IMapProps, IPushpinOptionsData } from './map.props.autogenerated';

/**
 * Header Interface.
 */
export interface IHeader {
    headerProps: INodeProps;
    heading: React.ReactNode;
}

/**
 * MapViewProps Interface.
 */
export interface IMapViewProps extends IMapProps<IMapData> {
    ModuleProps: IModuleProps;
    Header: IHeader;
    MapProps: INodeProps;
    Map: Microsoft.Maps.Map | undefined;
}

/**
 *
 * Map component.
 * @extends {React.Component<IMapProps<IMapData>>}
 */
@observer
class Map extends React.Component<IMapProps<IMapData>> {
    @observable public map: Microsoft.Maps.Map | undefined;
    private timeout: number = 500;

    private readonly mapRef: React.RefObject<HTMLElement> = React.createRef<HTMLElement>();

    public constructor(props: IMapProps<IMapData>) {
        super(props);
    }

    public componentDidMount(): void {
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: { channel }
                }
            }
        } = this.props;

        if (channel && !channel.BingMapsApiKey) {
            telemetry.error('BingMapsApiKey is missing.');
            return;
        }

        if (channel && !channel.BingMapsEnabled) {
            telemetry.error('Map is disabled from HQ.');
            return;
        }

        const loadMapAPIInput = {
            key: channel?.BingMapsApiKey,
            lang: this.props.context.actionContext.requestContext.locale,
            market: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode
        };

        if (
            this.props.data.storeSelectorStateManager?.result?.isMapApiLoaded ||
            this.props.data.distributorSelectorStateManager?.result?.isMapApiLoaded
        ) {
            this._initMap();
            if (this.props.data.distributorSelectorStateManager?.result?.isDistributorSelectorDialogOpen) {
                this._updateMapsForDistributor();
            } else {
                this._updateMap();
            }
        }

        when(
            () => !!this.props.data.storeSelectorStateManager?.result?.setMapModuleLoaded,
            () => {
                this.props.data.storeSelectorStateManager?.result?.setMapModuleLoaded(true);
            }
        );

        when(
            () => !!this.props.data.distributorSelectorStateManager?.result?.setMapModuleLoaded,
            () => {
                this.props.data.distributorSelectorStateManager?.result?.setMapModuleLoaded(true);
            }
        );

        reaction(
            () =>
                this.props.data.storeSelectorStateManager?.result?.loadMapApi ||
                this.props.data.distributorSelectorStateManager?.result?.loadMapApi,
            () => {
                if (this.props.data.distributorSelectorStateManager?.result?.loadMapApi) {
                    this.props.data.distributorSelectorStateManager?.result?.loadMapApi(loadMapAPIInput);
                } else {
                    this.props.data.storeSelectorStateManager?.result?.loadMapApi(loadMapAPIInput);
                }
            }
        );

        reaction(
            () =>
                this.props.data.storeSelectorStateManager?.result?.isMapApiLoaded ||
                this.props.data.distributorSelectorStateManager?.result?.isMapApiLoaded,
            () => {
                this._initMap();
            }
        );

        reaction(
            () => {
                return [
                    this.props.data.storeSelectorStateManager.result?.context?.orgUnitStoreInformation,
                    this.props.data.storeSelectorStateManager.result?.selectedStoreLocationId,
                    this.map
                ];
            },
            () => {
                this._updateMap();
            }
        );

        reaction(
            () => {
                return [
                    this.props.data.distributorSelectorStateManager?.result?.distributorList,
                    this.props.data.distributorSelectorStateManager?.result?.selectedDistributorId,
                    this.map
                ];
            },
            () => {
                this._updateMapsForDistributor();
            }
        );
    }

    public render(): JSX.Element | null {
        const {
            config: { heading, className },
            data
        } = this.props;

        const shouldDisplayMap = data.storeSelectorStateManager?.result?.isDialogOpen
            ? data.storeSelectorStateManager?.result?.listMapViewState.displayMap
            : data.distributorSelectorStateManager?.result?.isDistributorSelectorDialogOpen
            ? data.distributorSelectorStateManager?.result?.listMapViewState.displayMap
            : false;

        const viewProps: IMapViewProps = {
            ...this.props,
            ModuleProps: {
                tag: 'div',
                moduleProps: this.props,
                className: classname('ms-map', { show: shouldDisplayMap }, className)
            },
            Header: {
                headerProps: { className: 'ms-map__header' },
                heading: heading?.text && (
                    <Msdyn365.Text
                        className='ms-map__heading'
                        {...heading}
                        tag={heading.tag || 'h2'}
                        text={heading.text}
                        editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
                    />
                )
            },
            MapProps: {
                tag: 'div',
                className: 'ms-map__body',
                ref: this.mapRef
            },
            Map: this.map
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    /**
     * Method to be called on heading change.
     * @param event -Content Edit Event.
     */
    public handleHeadingChange = (event: Msdyn365.ContentEditableEvent): void => {
        this.props.config.heading!.text = event.target.value;
    };

    /**
     * Initialize the map.
     */
    private readonly _initMap = () => {
        const {
            context: {
                actionContext: {
                    requestContext: { channel }
                }
            },
            data
        } = this.props;

        if (data.storeSelectorStateManager?.result?.isMapApiLoaded || data.distributorSelectorStateManager?.result?.isMapApiLoaded) {
            const mapLoadOptions = {
                credentials: channel?.BingMapsApiKey,
                pushpinAccessible: true
            };
            this.map = new Microsoft.Maps.Map(this.mapRef.current as HTMLElement, mapLoadOptions);
            Microsoft.Maps.Events.addHandler(this.map, 'click', async () => {
                if (data.distributorSelectorStateManager?.result?.isDistributorSelectorDialogOpen) {
                    // Hide the distributor details that appear below the screen size of 768px.
                    data.distributorSelectorStateManager?.result?.updateDistributorMapVisibility(false);
                    await data.distributorSelectorStateManager?.result?.setSelectedDistributorId(undefined);
                } else {
                    await data.storeSelectorStateManager?.result?.setSelectedStoreLocationId(undefined);
                }
            });
        }
    };

    private readonly _updateMapsForDistributor = () => {
        const pushpinOptions = this.props.config.pushpinOptions;
        const distributorSelectorStateManager = this.props.data.distributorSelectorStateManager?.result;
        const distributorInfoList = distributorSelectorStateManager?.distributorList;
        const selectedDistributorId = distributorSelectorStateManager?.selectedDistributorId;

        if (this.map && ArrayExtensions.hasElements(distributorInfoList)) {
            let mapLocation: OrgUnitLocation | undefined;
            this.map.entities.clear();
            const pushpins: Microsoft.Maps.IPrimitive[] = [];

            const distributorList = distributorInfoList.filter(distributor => distributor.OrgUnit !== undefined);

            for (const [index, distributorInfo] of distributorList.entries()) {
                const orgUnit = distributorInfo.OrgUnit;

                if (orgUnit?.Latitude && orgUnit.Longitude) {
                    const isLocationSelected = selectedDistributorId === orgUnit?.RecordId;
                    const options = this._getPushpinOptions(isLocationSelected, index, pushpinOptions);
                    const pushpin = new Microsoft.Maps.Pushpin(new Microsoft.Maps.Location(orgUnit?.Latitude, orgUnit.Longitude), options);

                    Microsoft.Maps.Events.addHandler(pushpin, 'click', () => {
                        this.handleDistributorPushpinClick(orgUnit.RecordId);
                    });
                    isLocationSelected ? pushpins.unshift(pushpin) : pushpins.push(pushpin);

                    if (isLocationSelected) {
                        mapLocation = orgUnit;
                    }
                }
            }
            if (mapLocation) {
                const currentLocation = new Microsoft.Maps.Location(mapLocation.Latitude, mapLocation.Longitude);
                this.map.setView({ center: currentLocation });
            } else {
                this.map.setView({
                    bounds: Microsoft.Maps.LocationRect?.fromShapes(pushpins)
                });
            }

            this.map.setOptions({ pushpinAccessible: true } as Microsoft.Maps.IMapOptions);
            this.map.entities.push(pushpins);
        }
    };

    /**
     * Update the map.
     */
    private readonly _updateMap = () => {
        const pushpinOptions = this.props.config.pushpinOptions;
        const storeSelectorStateManager = this.props.data.storeSelectorStateManager?.result;
        const orgUnitStoreInformation = storeSelectorStateManager?.context?.orgUnitStoreInformation;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;

        if (this.map && orgUnitStoreInformation) {
            let mapLocation: OrgUnitLocation | undefined;
            this.map.entities.clear();
            const pushpins: Microsoft.Maps.IPrimitive[] = [];

            const storeLocationList = orgUnitStoreInformation.filter(store => store.OrgUnitAvailability !== undefined);

            for (const [index, unitStoreInfo] of storeLocationList.entries()) {
                const storeLocation = unitStoreInfo.OrgUnitAvailability?.OrgUnitLocation;

                if (storeLocation?.Latitude && storeLocation.Longitude) {
                    const isSelectedLocation = selectedStoreLocationId === storeLocation.OrgUnitNumber;
                    const options = this._getPushpinOptions(isSelectedLocation, index, pushpinOptions);
                    const pushpin = new Microsoft.Maps.Pushpin(
                        new Microsoft.Maps.Location(storeLocation.Latitude, storeLocation.Longitude),
                        options
                    );

                    Microsoft.Maps.Events.addHandler(pushpin, 'click', () => {
                        this.handleClickEvent(storeLocation.OrgUnitNumber);
                    });
                    isSelectedLocation ? pushpins.unshift(pushpin) : pushpins.push(pushpin);

                    if (isSelectedLocation) {
                        mapLocation = storeLocation;
                    }
                }
            }

            if (mapLocation) {
                const currentLocation = new Microsoft.Maps.Location(mapLocation.Latitude, mapLocation.Longitude);
                this.map.setView({ center: currentLocation });
            } else {
                // Create a LocationRect from array of pushpins and set the map view.
                this.map.setView({
                    bounds: Microsoft.Maps.LocationRect?.fromShapes(pushpins)
                });
            }

            this.map.setOptions({ pushpinAccessible: true } as Microsoft.Maps.IMapOptions);
            this.map.entities.push(pushpins);
        }
    };

    /**
     * Handle click event.
     * @param orgUnitNumber - Organization unit number.
     */
    private readonly handleClickEvent = (orgUnitNumber: string | undefined): void => {
        const storeSelectorStateManager = this.props.data.storeSelectorStateManager.result;
        storeSelectorStateManager?.setSelectedStoreLocationId(undefined);
        if (orgUnitNumber) {
            setTimeout(() => {
                storeSelectorStateManager?.setSelectedStoreLocationId(orgUnitNumber);
            }, this.timeout);
        }
    };

    /**
     * Handle the click event of the pushpin for distributors on the maps.
     * @param recordId - RecordId.
     */
    private readonly handleDistributorPushpinClick = (recordId: number | undefined): void => {
        const distributorSelectorStateManager = this.props.data.distributorSelectorStateManager?.result;
        // Show the distributor details that appear below the screen size of 768px.
        distributorSelectorStateManager?.updateDistributorMapVisibility(true);
        distributorSelectorStateManager?.setSelectedDistributorId(undefined);
        if (recordId) {
            setTimeout(() => {
                distributorSelectorStateManager?.setSelectedDistributorId(recordId);
            }, this.timeout);
        }
    };

    /**
     * Get the pushpin option.
     * @param isSelectedLocation - Is selected location.
     * @param index - Index.
     * @param pushpinOptions - PushpinOptions.
     * @returns - The pushpin options.
     */
    private readonly _getPushpinOptions = (isSelectedLocation: boolean, index: number, pushpinOptions?: IPushpinOptionsData) => {
        const text = pushpinOptions?.showIndex ? (index + 1).toString() : undefined;

        const size = pushpinOptions?.size || 1;
        const color = isSelectedLocation ? pushpinOptions?.selectionColor || pushpinOptions?.color : pushpinOptions?.color;
        const icon = this._getSvgIcon(size, color, text);

        return {
            // Fallback if icon doesn't render properly
            color: isSelectedLocation ? pushpinOptions?.selectionColor : pushpinOptions?.color,
            icon
        };
    };

    private readonly _getSvgIcon = (size: number, color?: string, text?: string) => {
        const baseValue: number = 32;
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${baseValue * size}" height="${baseValue * size}" viewBox="0 0 365 560">
                    <path fill="${color}" d="M182.9,551.7c0,0.1,0.2,0.3,0.2,0.3S358.3,283,358.3,194.6c0-130.1-88.8-186.7-175.4-186.9 C96.3,7.9,7.5,64.5,7.5,194.6c0,88.4,175.3,357.4,175.3,357.4S182.9,551.7,182.9,551.7z" />
                    ${text ? `<text x="185" y="280" style="font-size:220px;fill:#ffffff;" text-anchor="middle">${text}</text>` : ''}
                </svg>`;
    };
}

export default Map;
