/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/// <reference types="bingmaps" />

/* eslint-disable no-duplicate-imports */
import {
    Address,
    AddressPurpose,
    CartLine,
    CountryRegionInfo,
    SimpleProduct,
    StateProvinceInfo,
    TenderLine,
    TokenizedPaymentCard
} from '@msdyn365-commerce/retail-proxy';
import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import {
    ArrayExtensions,
    getFallbackImageUrl,
    getSimpleProducts,
    ObjectExtensions,
    ProductInput
} from '@msdyn365-commerce-modules/retail-actions';
import { format, getTelemetryObject, IModuleProps, ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { action, computed, observable, reaction, set } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { CheckoutModule, ErrorLocation } from '@msdyn365-commerce/global-state';
import { AutoSuggest } from '@msdyn365-commerce-modules/address';
import { IAutoSuggestOptions } from '@msdyn365-commerce-modules/address';
import { AddressCommon } from '@msdyn365-commerce-modules/address';
import { AddressFormat } from '@msdyn365-commerce-modules/address';
import { AddressItemType } from '@msdyn365-commerce-modules/address';
import { AddressMetaData } from '@msdyn365-commerce-modules/address';
import { AddressOperation, AddressType, IAddressResource, IAddressResponse } from '@msdyn365-commerce-modules/address';
import { AddressAddUpdate, IAddressAddUpdateProps } from '@msdyn365-commerce-modules/address';
import { AddressSelect, IAddressSelectProps } from '@msdyn365-commerce-modules/address';
import { AddressShow, IAddressShowProps } from '@msdyn365-commerce-modules/address';
import { ICheckoutShippingAddressData } from './checkout-shipping-address.data';
import { ICheckoutShippingAddressProps } from './checkout-shipping-address.props.autogenerated';
import {
    CheckoutPickupCartLines,
    defaultImageSettings,
    ICartLineWithProduct,
    ICheckoutShippingCartLineInfo,
    ICheckoutShippingCartLinesProps
} from './components/checkout-shipping-cartlines-images';
import { ErrorComponent } from '@msdyn365-commerce-modules/address';
import { focusOnCheckoutError } from '@msdyn365-commerce-modules/address';

/**
 * The checkout address props interface.
 */
export interface ICheckoutAddressProps extends ICheckoutShippingAddressProps<ICheckoutShippingAddressData>, IModuleStateProps {}

/**
 * The checkout shipping address view state.
 */
export interface ICheckoutShippingAddressViewState {
    isShowAddress: boolean;
    isShowAddresList: boolean;
    isShowAddOrUpdateAddress: boolean;
}

/**
 * The checkout shipping address state.
 */
export interface ICheckoutAddresState {
    shippingGroups: ICartLineWithProduct[];
    errorMessage?: string;
}

/**
 * The checkout shipping address view props.
 */
export interface ICheckoutShippingAddressViewProps extends ICheckoutAddressProps {
    className: string;
    currentOperation: AddressOperation;
    selectedAddress?: Address;
    addUpdateAddress: Address;
    addressListSelectedAddress: Address;
    countryRegionId: string;
    stateProvinceInfo?: StateProvinceInfo[];
    customerAddresses: Address[];
    validationError: object;
    addressActionResponse?: IAddressResponse;
    viewState: ICheckoutShippingAddressViewState;
    CheckoutShippingAddress: IModuleProps;
    isUpdating: boolean;
    hasError: boolean;
    showAddress: IAddressShowProps;
    showAddOrUpdateAddress: IAddressAddUpdateProps;
    cartLineImages?: React.ReactNode;
    showAddressSelect: IAddressSelectProps;
    alert?: React.ReactNode;
    checkoutErrorRef?: React.RefObject<HTMLElement>;
    showAddOrUpdateAddressHandler?(onSaveHandler?: () => void, onCancelHandler?: () => void): IAddressAddUpdateProps;
    showAddressSelectHandler?(
        onAddAddressHandler?: () => void,
        onSaveHandler?: () => void,
        onCancelHandler?: () => void
    ): IAddressSelectProps;
}

/**
 * IExpressPaymentDetail interface.
 */
interface IExpressPaymentDetails {
    email?: string;
    tenderLine?: TenderLine;
    tokenizedPaymentCard?: TokenizedPaymentCard;
    paymentTenderType?: string;
    address?: Address;
    isExpressCheckoutAppliedInCartPage: boolean;
    isExpressAddressAppliedInCartPage?: boolean;
}

/**
 *
 * Address component.
 * @extends {React.Component<ICheckoutShippingAddressProps<ICheckoutShippingAddressData>>}
 */
// @ts-expect-error
@withModuleState
@observer
class CheckoutShippingAddress extends React.Component<ICheckoutAddressProps, ICheckoutAddresState> {
    @observable private currentOperation: AddressOperation;

    @observable private selectedAddress?: Address;

    @observable private addUpdateAddress: Address;

    @observable private countryRegionId: string = 'USA';

    @observable private stateProvinceInfo?: StateProvinceInfo[];

    @observable private customerAddresses: Address[] = [];

    @observable private validationError: object;

    @observable private addressActionResponse?: IAddressResponse;

    @observable private isUpdating?: boolean;

    @observable private hasError?: boolean;

    @observable private addressListSelectedAddress: Address = {};

    private readonly addressCommon: AddressCommon;

    private addressFormat!: AddressFormat;

    private countryRegions: CountryRegionInfo[] = [];

    private addressPurposes: AddressPurpose[] = [];

    private readonly resources: IAddressResource;

    private readonly defaultAddressType: number = 6; // Default to Home

    private readonly telemetryContent?: ITelemetryContent;

    private autoSuggest?: AutoSuggest;

    private readonly multiplePickupStoreSwitchName: string = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';

    private retailMultiplePickUpOptionEnabled?: boolean = false;

    private readonly checkoutErrorRef: React.RefObject<HTMLElement> = React.createRef();

    public constructor(props: ICheckoutAddressProps) {
        super(props);
        this.state = { shippingGroups: [] };
        const { context, data, resources, telemetry } = this.props;

        this.addUpdateAddress = {};
        this.resources = resources;
        this.currentOperation = AddressOperation.List;
        this.countryRegions = data.countryRegions.result || [];
        this.addressPurposes = data.addressPurposes.result || [];
        this.customerAddresses = data.address.result || [];
        this.stateProvinceInfo = data.countryStates.result || [];
        this.addressCommon = new AddressCommon(context, resources, telemetry);
        this.addressFormat = new AddressFormat(
            this.countryRegions,
            new AddressMetaData({ ...resources }, this._getAddressFormatExcludeList()),
            this.addressPurposes
        );
        this.validationError = {};
        this.retailMultiplePickUpOptionEnabled = data.featureState.result?.find(
            feature => feature.Name === this.multiplePickupStoreSwitchName
        )?.IsEnabled;
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
    }

    public async componentDidMount(): Promise<void> {
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: { channel }
                }
            },
            config: { autoSuggestionEnabled, autoSuggestOptions },
            resources
        } = this.props;

        // Initializing data props
        this._dataInitialize(this.props);

        this.addressFormat = new AddressFormat(
            this.countryRegions,
            new AddressMetaData({ ...resources }, this._getAddressFormatExcludeList()),
            this.addressPurposes
        );

        this.props.data.checkout.then(() => {
            this._setDefaultCountryRegionId();
            this._initModuleState();
        });

        reaction(
            () => this.countryRegionId,
            () => {
                this._getStateProvinces();
            }
        );

        reaction(
            () => this.currentOperation,
            () => {
                this._getStateProvinces();
            }
        );

        reaction(
            () => this.props.data.checkout.result?.shippingAddressFromExpressCheckout,
            () => {
                if (!this.expressPaymentDetailsFromCartPage && this._canShip()) {
                    let address = this.props.data.checkout.result?.shippingAddressFromExpressCheckout;

                    if (address?.TwoLetterISORegionName) {
                        const threeLetterIsoRegionName = this.getThreeLetterIsoRegionName(address.TwoLetterISORegionName);

                        address = { ...address, ThreeLetterISORegionName: threeLetterIsoRegionName };

                        if (threeLetterIsoRegionName && threeLetterIsoRegionName !== this.countryRegionId) {
                            this._onCountryChange(threeLetterIsoRegionName);
                        }
                    }

                    this._updateCurrentOperation(AddressOperation.Add, address);
                    this._onAddressAddUpdateSubmit();
                }
            }
        );

        if (autoSuggestionEnabled) {
            if (channel && !channel.BingMapsApiKey) {
                telemetry.error('BingMapsApiKey is missing.');
                return;
            }

            if (channel && !channel.BingMapsEnabled) {
                telemetry.error('Map is disabled from HQ.');
                return;
            }

            const options: IAutoSuggestOptions = { ...autoSuggestOptions };
            this.autoSuggest = new AutoSuggest(
                telemetry,
                options,
                channel?.BingMapsApiKey,
                channel?.ChannelCountryRegionISOCode,
                channel?.DefaultLanguageId
            );

            // Customer doesn't have any address. Then add view will be loaded directly. Code for the same to handle that
            if (
                this.props.data.storeSelectorStateManager.result &&
                (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update)
            ) {
                await this.autoSuggest._loadMapAPI(await this.props.data.storeSelectorStateManager);
            }

            reaction(
                () =>
                    this.props.data.storeSelectorStateManager.result?.loadMapApi &&
                    (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update),
                async () => {
                    await this.autoSuggest?._loadMapAPI(await this.props.data.storeSelectorStateManager);
                }
            );

            reaction(
                () => this.props.data.storeSelectorStateManager.result?.isMapApiLoaded,
                async () => {
                    await this._attachMapAutoSuggest();
                }
            );
        }

        if (this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging) {
            reaction(
                () => this.props.data.checkout.result?.checkoutError,
                checkoutError => {
                    if (
                        checkoutError &&
                        checkoutError.errorLocation === ErrorLocation.CheckoutShippingAddress &&
                        checkoutError.errorMessage
                    ) {
                        this._setErrorMessage(checkoutError.errorMessage);
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.checkoutErrorFocus,
                checkoutErrorFocus => {
                    if (checkoutErrorFocus === CheckoutModule.CheckoutShippingAddress) {
                        focusOnCheckoutError(this.checkoutErrorRef, this.props.context.actionContext);
                    }
                }
            );
        }

        await this._initPickupGroup();
    }

    public async componentDidUpdate(): Promise<void> {
        if (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update) {
            if (this.props.data.storeSelectorStateManager.result?.isMapApiLoaded) {
                await this._attachMapAutoSuggest();
            }
        } else {
            this.autoSuggest?.disposeAutoSuggest();
        }
    }

    public shouldComponentUpdate(nextProps: ICheckoutAddressProps, nextState: ICheckoutAddresState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        if (!this._canShip()) {
            return null;
        }

        const {
            config,
            context,
            renderView,
            resources,
            moduleState: { hasError }
        } = this.props;
        const { headingImages, itemsText, singleItemText, errorMessageTitle } = resources;
        const { imageSettings } = config;

        // Line images
        const cartlines: ICheckoutShippingCartLineInfo[] = this.state.shippingGroups
            .filter(x => !ObjectExtensions.isNullOrUndefined(x.product))
            .map(line => ({
                lineId: line.cartLine.LineId ?? '',
                imageProps: {
                    requestContext: context.actionContext.requestContext,
                    className: 'ms-checkout-shipping-address__group-images-lines-line-image',
                    altText: line.product?.Name,
                    src: line.product?.PrimaryImageUrl ?? '',
                    fallBackSrc: getFallbackImageUrl(
                        line.product?.ItemId,
                        context.actionContext.requestContext.apiSettings,
                        context.request.app?.config?.OmniChannelMedia
                    ),
                    gridSettings: context.request.gridSettings!,
                    imageSettings: imageSettings ?? defaultImageSettings,
                    loadFailureBehavior: 'empty'
                },
                quantity: line.cartLine.Quantity ?? 0
            }));

        const numberOfCartLines = this._countItems(cartlines);
        const itemText = numberOfCartLines > 1 ? itemsText : singleItemText;
        const itemTitle = `(${format(itemText, numberOfCartLines)})`;

        const lineImageProps: ICheckoutShippingCartLinesProps = {
            moduleClassName: 'ms-checkout-shipping-address',
            cartLines: cartlines.filter(x => !ObjectExtensions.isNullOrUndefined(x)),
            itemTitle: itemTitle,
            title: headingImages,
            resources: this.props.resources
        };

        const cartLineImages: React.ReactNode = <CheckoutPickupCartLines {...lineImageProps} />;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const { featureState } = this.props.data;
        const isRetailMultiplePickUpOptionEnabled = featureState.result?.find(feature => feature.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;

        const errorMessage = this.state.errorMessage;

        const viewProps = {
            ...this.props,
            currentOperation: this.currentOperation,
            selectedAddress: this.selectedAddress,
            addUpdateAddress: this.addUpdateAddress,
            addressListSelectedAddress: this.addressListSelectedAddress,
            countryRegionId: this.countryRegionId,
            stateProvinceInfo: this.stateProvinceInfo,
            customerAddresses: this.customerAddresses,
            validationError: this.validationError,
            addressActionResponse: this.addressActionResponse,
            isUpdating: this.isUpdating,
            hasError: this.hasError,
            className: config.className,
            viewState: {
                isShowAddress: this.currentOperation === AddressOperation.Show && this.selectedAddress,
                isShowAddresList: this.currentOperation === AddressOperation.List && this.customerAddresses.length > 0,
                isShowAddOrUpdateAddress:
                    this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update
            },
            CheckoutShippingAddress: {
                moduleProps: this.props,
                className: classnames('ms-checkout-shipping-address', config.className)
            },
            showAddress: this._renderShowAddress(),
            alert: hasError && errorMessage && <ErrorComponent {...{ title: errorMessageTitle, message: errorMessage }} />,
            checkoutErrorRef: this.checkoutErrorRef,

            /**
             * Show address select.
             * @param onAddAddressHandler - On add address click function.
             * @param onSaveHandler - On save click function.
             * @param onCancelHandler - On cancel click function.
             * @returns - Renders select address.
             */
            showAddressSelectHandler: (onAddAddressHandler?: () => void, onSaveHandler?: () => void, onCancelHandler?: () => void) =>
                this._renderSelectAddress(onAddAddressHandler, onSaveHandler, onCancelHandler),

            /**
             * Show add/update address.
             * @param onSaveHandler - On save click function.
             * @param onCancelHandler - On cancel click function.
             * @returns - Renders select address.
             */
            showAddOrUpdateAddressHandler: (onSaveHandler?: () => void, onCancelHandler?: () => void) =>
                this._renderAddOrUpdateAddress(onSaveHandler, onCancelHandler),
            showAddOrUpdateAddress: this._renderAddOrUpdateAddress(),
            cartLineImages: isRetailMultiplePickUpOptionEnabled ? cartLineImages : undefined,
            showAddressSelect: this._renderSelectAddress()
        };

        return renderView(viewProps) as React.ReactElement;
    }

    /**
     * Initialize pickup group.
     */
    @action
    private readonly _initPickupGroup = async (): Promise<void> => {
        const pickupCartLines: CartLine[] = this._getCartLinesforDelivery();
        const cartLines: ICartLineWithProduct[] = [];

        try {
            const products = await this._getProductsByCartLines(
                this.props.data.checkout.result?.checkoutCart.cart.ChannelId || 0,
                pickupCartLines
            );
            for (const line of pickupCartLines) {
                const product: SimpleProduct | undefined = products.find(x => x.RecordId === line.ProductId);
                cartLines.push({ cartLine: line, product });
            }
            this.setState({ shippingGroups: cartLines });
        } catch (error) {
            this.props.telemetry.error(error);
            this.setState({ shippingGroups: [] });
        }
    };

    /**
     * On suggestion selected.
     * @param result - Suggestion result interface.
     */
    @action
    private readonly _onSuggestionSelected = async (result: Microsoft.Maps.ISuggestionResult): Promise<void> => {
        this._clearAddressFields();
        const address = this.addressFormat.getTranformedAddress(result, this.stateProvinceInfo);
        const timeout = 0;
        set(this.addUpdateAddress, { Street: '' });
        set(this.addUpdateAddress, { ZipCode: address.ZipCode });
        set(this.addUpdateAddress, { CountyName: address.CountyName });
        set(this.addUpdateAddress, { City: address.City });
        set(this.addUpdateAddress, { State: address.State });
        set(this.addUpdateAddress, { DistrictName: address.DistrictName });
        set(this.addUpdateAddress, { FullAddress: address.FullAddress });

        // Bing autosuggest put the complete address in the Street input box. Updating the street input box to show only street address.
        setTimeout(() => {
            set(this.addUpdateAddress, { Street: address.Street });
        }, timeout);
    };

    /**
     * Method to clear address fields.
     */
    @action
    private readonly _clearAddressFields = (): void => {
        const addressFormatItem = this.addressFormat.getAddressFormat(
            this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId
        );
        for (const formatAddress of addressFormatItem) {
            if (
                this.addUpdateAddress[formatAddress.name] !== undefined &&
                !this.autoSuggest?.excludedAddressFields.includes(formatAddress.name)
            ) {
                this.addressFormat[formatAddress.name] = '';
            }
        }
        this._clearValidation();
    };

    /**
     * Method to clear validation.
     */
    @action
    private readonly _clearValidation = (): void => {
        this.validationError = {};
    };

    public get expressPaymentDetailsFromCartPage(): IExpressPaymentDetails | null {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
        const properties =
            this.props.data.cart?.result?.cart?.ExtensionProperties?.find(property => property.Key === 'expressPaymentDetails')?.Value
                ?.StringValue ?? '';

        return properties ? (JSON.parse(properties) as IExpressPaymentDetails) : null;
    }

    /**
     * Method data initialization.
     * @param props -The checkout address properties.
     */
    private readonly _dataInitialize = (props: ICheckoutAddressProps): void => {
        const { data } = props;

        reaction(
            () => data.countryRegions.result,
            () => {
                this.countryRegions = data.countryRegions.result ?? [];
            }
        );

        reaction(
            () => data.addressPurposes.result,
            () => {
                this.addressPurposes = data.addressPurposes.result ?? [];
            }
        );

        reaction(
            () => data.address.result,
            () => {
                this.customerAddresses = data.address.result ?? [];
            }
        );

        reaction(
            () => data.countryStates.result,
            () => {
                this.stateProvinceInfo = data.countryStates.result ?? [];
            }
        );

        reaction(
            () => data.featureState.result,
            () => {
                this.retailMultiplePickUpOptionEnabled = data.featureState.result?.find(
                    feature => feature.Name === this.multiplePickupStoreSwitchName
                )?.IsEnabled;
            }
        );
    };

    /**
     * Method to get cart lines for delivery.
     * @returns The cart line collection.
     */
    private readonly _getCartLinesforDelivery = (): CartLine[] => {
        return this.props.data.checkout.result?.checkoutCart.cart.CartLines?.filter(line => this._isDelivery(line)) ?? [];
    };

    /**
     * Method to check cart line for delivery.
     * @param line -The cart line.
     * @returns True/false as per cart line delivery mode.
     */
    private readonly _isDelivery = (line: CartLine): boolean => {
        return this._isNotPickupMode(line.DeliveryMode) && (line.FulfillmentStoreId === undefined || line.FulfillmentStoreId === '');
    };

    /**
     * Method to check cart line for delivery.
     * @param deliveryMode -The delivery mode.
     * @returns True/false as per cart line delivery mode.
     */
    private readonly _isNotPickupMode = (deliveryMode: string | undefined): boolean => {
        const pickupDeliveryModeCode = this.props.context.request.channel?.PickupDeliveryModeCode;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const { channelDeliveryOptionConfig, featureState } = this.props.data;
        const retailMultiplePickUpOptionEnabled = featureState.result?.find(feature => feature.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;
        if (retailMultiplePickUpOptionEnabled && deliveryMode !== undefined) {
            const pickupDeliveryMode = channelDeliveryOptionConfig.result?.PickupDeliveryModeCodes?.some(
                pickupMode => pickupMode !== deliveryMode
            );
            return pickupDeliveryMode !== undefined ? pickupDeliveryMode : false;
        }
        return deliveryMode !== undefined && pickupDeliveryModeCode !== undefined && deliveryMode !== pickupDeliveryModeCode;
    };

    /**
     * Method to check cart line for delivery.
     * @param channelId - The channelId.
     * @param cartLines - Cart line collections.
     * @returns Collection of SimpleProduct.
     */
    private readonly _getProductsByCartLines = async (channelId: number, cartLines: CartLine[]): Promise<SimpleProduct[]> => {
        const actionContext = this.props.context.actionContext;
        const productInputs = cartLines
            .filter(line => !ObjectExtensions.isNullOrUndefined(line.ProductId))
            .map(
                line =>
                    new ProductInput(
                        line.ProductId || 0,
                        actionContext.requestContext.apiSettings,
                        channelId,
                        undefined,
                        actionContext.requestContext,
                        line.CatalogId || 0
                    )
            );
        return getSimpleProducts(productInputs, actionContext);
    };

    /**
     * Method to render add/update address.
     * @param onSaveHandler -- Handles onsave functionality.
     * @param onCancelHandler -- Handles oncancel functionality.
     * @returns Address app/update props.
     */
    private readonly _renderAddOrUpdateAddress = (onSaveHandler?: () => void, onCancelHandler?: () => void): IAddressAddUpdateProps => {
        const addressFormat =
            this.currentOperation === AddressOperation.Add && this.addressCommon.isAuthenticatedFlow()
                ? this.addressFormat
                : this.addressFormat;

        /**
         * On Cancel Button Function.
         */
        const onCancelButtonHandler = () => {
            this._resetView();
            onCancelHandler?.();
        };
        return AddressAddUpdate({
            isUpdating: this.isUpdating,
            resources: this.resources,
            addressType: AddressType.Shipping,
            addressFormat: addressFormat.getAddressFormat(this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId),
            defaultCountryRegionId: this.countryRegionId,
            defaultAddressType: this.defaultAddressType,
            selectedAddress: this.addUpdateAddress,
            validationError: this.validationError,
            hasError: this.hasError,
            addressActionResponse: this.addressActionResponse,
            telemetryContent: this.telemetryContent,
            dropdownDisplayData: addressFormat.getPrefilledAddressDropdownData(
                this.resources.addressStateDefaultSelectionText,
                this.stateProvinceInfo
            ),
            onInputChange: this._onAddressAddUpdateInputChange,
            onDropdownChange: this._onAddressAddUpdateDropdownChange,
            hasExternalSubmitGroup: this.props.moduleState.hasExternalSubmitGroup,

            /**
             * On Save Function.
             */
            onSave: () => {
                this.onSubmit();
                onSaveHandler?.();
            },

            onCancel: !this.selectedAddress && !this.addressCommon.isAuthenticatedFlow() ? () => {} : onCancelButtonHandler
        });
    };

    /**
     * Method to render select address.
     * @param onAddAddressHandler - To handle add address button click.
     * @param onSaveHandler - To handle save button click.
     * @param onCancelHandler - To handle cancel button click.
     * @returns Select address props.
     */
    private readonly _renderSelectAddress = (
        onAddAddressHandler?: () => void,
        onSaveHandler?: () => void,
        onCancelHandler?: () => void
    ): IAddressSelectProps => {
        /**
         * On Cancel Button Function.
         */
        const onCancelButtonHandler = () => {
            this._resetView();
            onCancelHandler?.();
        };
        return AddressSelect({
            addressFormat: this.addressFormat,
            addresses: this.customerAddresses,
            resources: this.resources,
            addressPurposes: this.addressPurposes,
            selectedAddress: this.addressListSelectedAddress,
            onAddressOptionChange: this._onAddressOptionChange,
            hasExternalSubmitGroup: this.props.moduleState.hasExternalSubmitGroup,
            telemetryContent: this.telemetryContent,

            /**
             * On Add Address Function.
             */
            onAddAddress: () => {
                this._goToAddAddress();
                onAddAddressHandler?.();
            },

            /**
             * On Save Function.
             */
            onSave: () => {
                this._onSelectAddress();
                onSaveHandler?.();
            },

            onCancel: !this.selectedAddress ? () => {} : onCancelButtonHandler,

            multipleAddressShippingEnabled: this.props.config.multipleAddressShippingEnabled
        });
    };

    /**
     * Method to render show address.
     * @returns Show address props.
     */
    private _renderShowAddress(): IAddressShowProps | null {
        if (this.selectedAddress) {
            return AddressShow({
                address: this.selectedAddress,
                addressFormat: this.addressFormat.getAddressFormat(this.selectedAddress.ThreeLetterISORegionName || ''),
                addressPurposes: this.addressPurposes
            });
        }

        return null;
    }

    /**
     * Method to render map auto suggest.
     */
    private readonly _attachMapAutoSuggest = async (): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (storeSelectorStateManager?.isMapApiLoaded) {
            this.autoSuggest?.attachAutoSuggest('#shipping_addressstreet', '#shipping_addressstreet_container', this._onSuggestionSelected);
        }
    };

    /**
     * Method gets called on address option change.
     * @param event - To get current option.
     */
    private readonly _onAddressOptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const addressRecordId = event.currentTarget.value;
        const selectedAddress = this.customerAddresses.find(address => (address.RecordId || '').toString() === addressRecordId);
        if (selectedAddress) {
            this.addressListSelectedAddress = selectedAddress;
        }
    };

    /**
     * Method to render map auto suggest.
     * @param name - Address name field.
     * @param value - Address name value field.
     */
    private readonly onAddressAddUpdate = (name: string, value: string | boolean) => {
        set(this.addUpdateAddress, { [name]: value });
        this.addressFormat.validateAddressFormat(this.addUpdateAddress, this.validationError, this.countryRegionId, name);
    };

    /**
     * Method to get called on address update change.
     * @param event - Input element.
     */
    private readonly _onAddressAddUpdateInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
        if (event.target.type === 'checkbox') {
            this.onAddressAddUpdate(event.target.name, event.target.checked);
        } else {
            const value = (event.target.value || '').replace(new RegExp('[<>]', 'gi'), '');
            this.onAddressAddUpdate(event.target.name, value);
        }
    };

    /**
     * Method to get called on address update dropdown change.
     * @param event - Select element.
     */
    private readonly _onAddressAddUpdateDropdownChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {
        this.onAddressAddUpdate(event.target.name, event.target.value);

        if (event.target.name === AddressItemType[AddressItemType.ThreeLetterISORegionName]) {
            this._onCountryChange(event.target.value);
        }
    };

    /**
     * Method to get called on address update submit.
     */
    private readonly _onAddressAddUpdateSubmit = (): void => {
        if (!this.addressFormat.validateAddressFormat(this.addUpdateAddress, this.validationError, this.countryRegionId)) {
            return;
        }

        let response: Promise<IAddressResponse>;
        if (this.addressCommon.isAuthenticatedFlow() && this._isNewAddress(this.addUpdateAddress)) {
            response =
                this.currentOperation === AddressOperation.Update
                    ? this.addressCommon.updateCustomerAddress(this.addUpdateAddress)
                    : this.addressCommon.addCustomerAddress(this.addUpdateAddress);
        } else {
            response = Promise.resolve({ address: this.addUpdateAddress });
        }

        this.isUpdating = true;
        this._updateModuleState();

        response.then(
            (result: IAddressResponse) => {
                this.isUpdating = false;

                if (result.address) {
                    this.hasError = false;
                    this._clearError();
                    if (result.customerAddresses) {
                        this._onAddOrUpdateSuccess({ customerAddresses: result.customerAddresses, address: result.address });
                    } else {
                        this._onAddOrUpdateSuccess({ address: result.address });
                    }
                } else {
                    this.hasError = true;
                    this.addressActionResponse = result;
                    this._updateModuleState();
                }
            },
            () => {
                this.hasError = true;
                this.isUpdating = false;
                this._updateModuleState();
            }
        );
    };

    /**
     * Method to get called on country change.
     * @param countryRegionId - Country region id.
     */
    private readonly _onCountryChange = (countryRegionId: string) => {
        this.countryRegionId = countryRegionId;
        const twoLetterIsoRegionName = this.addressFormat.getTwoLetterISORegionName(countryRegionId);
        set(this.addUpdateAddress, { ThreeLetterISORegionName: countryRegionId });
        set(this.addUpdateAddress, { TwoLetterISORegionName: twoLetterIsoRegionName });
        this.autoSuggest?.changeAutoSuggestionCountryCode(twoLetterIsoRegionName);
        this._clearAddressFields();
    };

    /**
     * Method to get all address format exclude list.
     * @returns Collection of address items.
     */
    private readonly _getAddressFormatExcludeList = (): AddressItemType[] => {
        const { config } = this.props;
        const addressFormatExcludeList: AddressItemType[] = [];

        if (!config.showAddressType) {
            addressFormatExcludeList.push(AddressItemType.AddressTypeValue);
        }

        addressFormatExcludeList.push(AddressItemType.IsPrimary);

        return addressFormatExcludeList;
    };

    /**
     * Method to get all state/provinces.
     */
    private readonly _getStateProvinces = (): void => {
        if (
            !this.countryRegionId ||
            !(this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update)
        ) {
            return;
        }

        this.addressCommon.getStateProvinces(this.countryRegionId).then((result: StateProvinceInfo[]) => {
            const stateInfo = result.some(state => state.StateId === this.addUpdateAddress.State);

            // Reset state if selected state not found in the list.
            if (!stateInfo) {
                set(this.addUpdateAddress, { State: '' });
            }

            this.stateProvinceInfo = result;
        });
    };

    /**
     * Method to set default country region id.
     */
    private _setDefaultCountryRegionId(): void {
        const { request } = this.props.context;
        const market = request.channel?.ChannelCountryRegionISOCode;
        this.countryRegionId = this.addressCommon.getDefaultCountryRegionId(this.countryRegionId, this.countryRegions, market);
    }

    /**
     * Method to get default address region id.
     * @returns - Address object from existing addresses.
     */
    private readonly _getDefaultAddress = (): Address | undefined => {
        if (this.customerAddresses) {
            const primaryAddress = this.customerAddresses.find((address: Address) => address.IsPrimary);
            return primaryAddress || (this.customerAddresses.length > 0 ? this.customerAddresses[0] : undefined);
        }
        return undefined;
    };

    /**
     * Method to get address from express payment details from cart page.
     * @returns - Address.
     */
    private readonly _getAddressFromCartExpressPaymentDetails = (): Address | undefined => {
        if (this.expressPaymentDetailsFromCartPage) {
            const { tokenizedPaymentCard, address, isExpressAddressAppliedInCartPage } = this.expressPaymentDetailsFromCartPage;

            let addressFromCartExpress: Address | undefined;

            if (isExpressAddressAppliedInCartPage) {
                addressFromCartExpress = address ? this.getExpressAddress(address) : undefined;
            } else {
                addressFromCartExpress = tokenizedPaymentCard ? this.getAddressFromTokenizedPaymentCard(tokenizedPaymentCard) : undefined;
            }

            return addressFromCartExpress;
        }
        return undefined;
    };

    /**
     * Get address from tokenizedPaymentCard.
     * @param tokenizedPaymentCard -- The tokenizedPaymentCard from the payment.
     * @returns The address.
     */
    private readonly getAddressFromTokenizedPaymentCard = (tokenizedPaymentCard: TokenizedPaymentCard): Address => {
        const twoLetterIsoRegionName = tokenizedPaymentCard.Country;

        const threeLetterIsoRegionName = twoLetterIsoRegionName ? this.getThreeLetterIsoRegionName(twoLetterIsoRegionName) : undefined;

        if (threeLetterIsoRegionName && threeLetterIsoRegionName !== this.countryRegionId) {
            this._onCountryChange(threeLetterIsoRegionName);
        }

        const address: Address = {
            TwoLetterISORegionName: twoLetterIsoRegionName,
            Name: tokenizedPaymentCard.NameOnCard,
            Street: tokenizedPaymentCard.Address1,
            StreetNumber: tokenizedPaymentCard.Address2,
            City: tokenizedPaymentCard.City,
            State: tokenizedPaymentCard.State,
            ZipCode: tokenizedPaymentCard.Zip,
            Phone: tokenizedPaymentCard.Phone,
            ThreeLetterISORegionName: threeLetterIsoRegionName,
            AddressTypeValue: this.defaultAddressType
        };

        return address;
    };

    /**
     * Get address from expressAddress.
     * @param expressAddress -- The expressAddress.
     * @returns The address.
     */
    private readonly getExpressAddress = (expressAddress: Address): Address => {
        const twoLetterIsoRegionName = expressAddress.TwoLetterISORegionName;

        const threeLetterIsoRegionName = twoLetterIsoRegionName ? this.getThreeLetterIsoRegionName(twoLetterIsoRegionName) : undefined;

        if (threeLetterIsoRegionName && threeLetterIsoRegionName !== this.countryRegionId) {
            this._onCountryChange(threeLetterIsoRegionName);
        }

        const address: Address = {
            ...expressAddress,
            ThreeLetterISORegionName: threeLetterIsoRegionName,
            AddressTypeValue: this.defaultAddressType
        };

        return address;
    };

    /**
     * Get three letter ISO region name from two letter ISO region name.
     * @param twoLetterIsoRegionName -- The three letter ISO region name.
     * @returns The three letter ISO region name.
     */
    private readonly getThreeLetterIsoRegionName = (twoLetterIsoRegionName: string): string | undefined => {
        const countryRegion = this.countryRegions.find(country => {
            return country.ISOCode?.toLowerCase() === twoLetterIsoRegionName.toLowerCase();
        });

        return countryRegion?.CountryRegionId;
    };

    /**
     * Method to initialize all module state.
     */
    private readonly _initModuleState = (): void => {
        this.props.moduleState.init({
            status: this._canShip() ? 'updating' : 'disabled',
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit
        });

        const checkoutState = this.props.data.checkout.result;

        if (this._canShip()) {
            let defaultAddress;
            const shippingCartLines: CartLine[] = this._getCartLinesforDelivery();

            if (checkoutState?.checkoutCart.cart.ShippingAddress) {
                defaultAddress = checkoutState.checkoutCart.cart.ShippingAddress;
            } else if (
                ArrayExtensions.hasElements(shippingCartLines) &&
                shippingCartLines[0].ShippingAddress !== undefined &&
                shippingCartLines[0].ShippingAddress.FullAddress !== ''
            ) {
                defaultAddress = shippingCartLines[0].ShippingAddress;
            } else if (this._getAddressFromCartExpressPaymentDetails()) {
                defaultAddress = this._getAddressFromCartExpressPaymentDetails();
            } else if (this._getDefaultAddress()) {
                defaultAddress = this._getDefaultAddress();
            } else {
                defaultAddress = checkoutState?.isExpressCheckoutApplied ? checkoutState.shippingAddressFromExpressCheckout : undefined;
            }

            if (defaultAddress && !this.addressCommon.isEmpty(defaultAddress)) {
                this._updateCurrentOperation(AddressOperation.Show, defaultAddress);
                this._setShippingAddress(defaultAddress);
                this._updateModuleState();
                checkoutState?.updateHasShippingAddress({ newHasShippingAddress: true });
            } else {
                this._updateCurrentOperation(AddressOperation.Add);
                checkoutState?.updateHasShippingAddress({ newHasShippingAddress: false });
            }
        }
    };

    /**
     * Method get called on submit address.
     */
    private readonly onSubmit = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this.props.telemetry.information('Shipping address submit for Add or Update operation.');
                this._onAddressAddUpdateSubmit();
                break;
            case AddressOperation.List:
                this.props.telemetry.information('Shipping address submit for List operation.');
                this._onSelectAddress();
                break;
            default:
                this.props.telemetry.error('Invalid operation');
        }
    };

    /**
     * Method get called on cancel.
     */
    private readonly onCancel = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this.props.telemetry.information('Shipping address cancel for Add or Update operation.');
                this._clearAddressFields();
                if (!(!this.selectedAddress && !this.addressCommon.isAuthenticatedFlow())) {
                    this._resetView();
                }

                break;
            case AddressOperation.List:
                this.props.telemetry.information('Shipping address cancel for List operation.');
                if (this.selectedAddress) {
                    this._resetView();
                }
                break;
            default:
                this.props.telemetry.error('Invalid operation');
        }
    };

    /**
     * Method get called on edit address.
     */
    private readonly onEdit = (): void => {
        this.props.telemetry.information('Shipping address onEdit is called.');

        if (this.addressCommon.isAuthenticatedFlow() && this.shippingAddress) {
            this._updateCurrentOperation(AddressOperation.List, this.shippingAddress);
        } else if (this.shippingAddress) {
            this._updateCurrentOperation(AddressOperation.Update, this.shippingAddress);
        }

        this._updateModuleState();
    };

    /**
     * Method to check if checkout cartlines are available fro shipping.
     * @returns - True/false as per the delivery mode.
     */
    private readonly _canShip = (): boolean => {
        const { checkout, channelDeliveryOptionConfig } = this.props.data;
        const { request } = this.props.context;
        const pickupDeliveryModeCode = request && request.channel && request.channel.PickupDeliveryModeCode;
        const emailDeliveryModeCode = request && request.channel && request.channel.EmailDeliveryModeCode;
        if (!checkout.result || !request.channel || checkout.result.checkoutCart.isEmpty || checkout.result.checkoutCart.hasInvoiceLine) {
            return false;
        }

        // @ts-expect-error: Type-checker not realizing above request.channel check
        return this.retailMultiplePickUpOptionEnabled
            ? checkout.result.checkoutCart.cart.CartLines?.some(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !==
                            channelDeliveryOptionConfig.result?.PickupDeliveryModeCodes?.find(
                                deliveryMode => deliveryMode === cartLine.DeliveryMode
                            ) && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              )
            : checkout.result.checkoutCart.cart.CartLines?.some(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              );
    };

    /**
     * Method get called on select address.
     */
    private readonly _onSelectAddress = () => {
        this._updateCurrentOperation(AddressOperation.Show, this.addressListSelectedAddress);
        this._setShippingAddress(this.addressListSelectedAddress);
        this._updateModuleState();
    };

    /**
     * Method get called on goto add address.
     */
    private readonly _goToAddAddress = () => {
        this._setDefaultCountryRegionId();
        this._updateCurrentOperation(AddressOperation.Add);
    };

    /**
     * Method get called on add/update success.
     * @param response - Retail api response.
     */
    private readonly _onAddOrUpdateSuccess = (response: IAddressResponse) => {
        if (response.customerAddresses) {
            this.customerAddresses = response.customerAddresses;
        }

        if (response.address) {
            this._updateCurrentOperation(AddressOperation.Show, response.address);
            this._setShippingAddress(response.address);
            this._updateModuleState();
        }
    };

    /**
     * Method get called on set Shipping Address.
     * @param address - Retail Api address result.
     */
    private readonly _setShippingAddress = (address: Address): void => {
        if (this.props.data.checkout.result) {
            const newShippingAddress = { ...address };

            if (address.ThreeLetterISORegionName && !newShippingAddress.TwoLetterISORegionName) {
                newShippingAddress.TwoLetterISORegionName = this.addressFormat.getTwoLetterISORegionName(address.ThreeLetterISORegionName);
            }

            this.props.data.checkout.result.updateShippingAddress({ newShippingAddress });
            this.props.data.checkout.result.checkoutCart.updateShippingAddress({ newShippingAddress }).catch(error => {
                this.props.telemetry.error(error);
            });
        }
    };

    @computed private get shippingAddress(): Address | undefined {
        return this.props.data.checkout.result?.shippingAddress;
    }

    /**
     * Method get called on reset view.
     */
    private readonly _resetView = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this._updateCurrentOperation(
                    this.addressCommon.isAuthenticatedFlow() ? AddressOperation.List : AddressOperation.Show,
                    this.shippingAddress
                );
                break;
            default:
                this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
        }
        this._updateModuleState();
    };

    /**
     * Update current operation.
     * @param operation - The address operation.
     * @param selectedAddress - The selected address.
     */
    private readonly _updateCurrentOperation = (operation: AddressOperation, selectedAddress?: Address) => {
        this.currentOperation = operation;
        this.selectedAddress = selectedAddress;

        if (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update) {
            this.addUpdateAddress = { ...this.selectedAddress } || {};
            set(this.addUpdateAddress, {
                ThreeLetterISORegionName: this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId
            });
            set(this.addUpdateAddress, {
                AddressTypeValue: this.addUpdateAddress.AddressTypeValue || this.defaultAddressType
            });
        } else if (this.currentOperation === AddressOperation.List) {
            this.addressListSelectedAddress = { ...this.selectedAddress } || {};
        }
    };

    /**
     * Update module state.
     */
    private readonly _updateModuleState = () => {
        if (this.currentOperation === AddressOperation.Show) {
            this.props.moduleState.onReady();
        } else if (this.isUpdating) {
            this.props.moduleState.onPending();
        } else {
            this.props.moduleState.onUpdating();
        }
    };

    /**
     * Method to check if the customer already has the address.
     * @param address - The address.
     */
    private readonly _isNewAddress = (address: Address): boolean => {
        for (const existingAddress of this.customerAddresses) {
            if (
                (address.Name ?? '') === existingAddress.Name &&
                (address.Street ?? '') === existingAddress.Street &&
                (address.StreetNumber ?? '') === existingAddress.StreetNumber &&
                (address.City ?? '') === existingAddress.City &&
                (address.State ?? '') === existingAddress.State &&
                (address.ZipCode ?? '') === existingAddress.ZipCode &&
                (address.Phone ?? '') === existingAddress.Phone &&
                (address.ThreeLetterISORegionName ?? '') === existingAddress.ThreeLetterISORegionName &&
                (address.AddressTypeValue ?? '') === existingAddress.AddressTypeValue
            ) {
                return false;
            }
        }

        return true;
    };

    @action
    private readonly _setErrorMessage = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.setState({
            errorMessage
        });
    };

    private readonly _clearError = (): void => {
        this.props.moduleState.setHasError(false);
        this.setState({
            errorMessage: ''
        });
    };

    /**
     * Returns count of products.
     * @param cartLine - The checkout shipping cart line info props.
     * @returns Number of products.
     */
    private readonly _countItems = (cartlines: ICheckoutShippingCartLineInfo[]): number => {
        return cartlines.reduce((count, line) => {
            return count + (line.quantity || 0);
        }, 0);
    };
}

export default CheckoutShippingAddress;
