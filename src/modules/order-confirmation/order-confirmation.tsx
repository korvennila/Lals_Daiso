/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import * as Msdyn365 from '@msdyn365-commerce/core';
import {
    ChannelDeliveryOptionConfiguration,
    ProductDeliveryOptions,
    SalesLine,
    SalesOrder,
    SimpleProduct,
    TransactionType
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import {
    Button,
    getPayloadObject,
    getTelemetryAttributes,
    getTelemetryObject,
    IModuleProps,
    INodeProps,
    ITelemetryContent,
    TelemetryConstant
} from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import get from 'lodash/get';
import { computed } from 'mobx';
import * as React from 'react';

import {
    IGetOrderSummaryInput,
    IHelp,
    IOrderSummary,
    IPaymentMethods,
    IPaymentMethodsInput
} from '@msdyn365-commerce-modules/order-management';
import { getGroups, IGroups } from '@msdyn365-commerce-modules/order-management';
import { getOrderInformation, getOrderInformationInput, IOrderInformation } from '@msdyn365-commerce-modules/order-management';
import { ISalesLine } from '@msdyn365-commerce-modules/order-management';
import { getSalesLines, getSalesLinesInput } from '@msdyn365-commerce-modules/order-management';
import { Label } from '@msdyn365-commerce-modules/order-management';
import { getTenderIdOperationIdMap, IPriceContext } from '@msdyn365-commerce-modules/order-management';
import { getOrderConfirmationHelp } from './components/get-help';
import { getOrderConfirmationOrderSummary } from './components/get-order-summary';
import { getOrderConfirmationPaymentMethods } from './components/get-payment-methods';
import { IOrderConfirmationData } from './order-confirmation.data';
import { IOrderConfirmationProps } from './order-confirmation.props.autogenerated';

export interface IOrderConfirmationViewProps extends IOrderConfirmationProps<IOrderConfirmationData> {
    moduleProps: IModuleProps;
    salesOrder?: SalesOrder;
    footerProps?: INodeProps;
    alert?: React.ReactNode;
    loading?: React.ReactNode;
    heading: React.ReactNode;
    backToShoppingLink?: React.ReactNode;
    orderInfomation?: IOrderInformation;
    salesLines?: ISalesLine[];
    groups?: IGroups;
    orderSummary?: IOrderSummary;
    payment?: IPaymentMethods;
    help?: IHelp;
}

/**
 *
 * OrderConfirmation component.
 * @extends {React.PureComponent<IOrderConfirmationProps<IOrderConfirmationData>>}
 */
class OrderConfirmation extends React.PureComponent<IOrderConfirmationProps<IOrderConfirmationData>> {
    private readonly moduleName: string = 'ms-order-confirmation';

    private readonly telemetryContent?: ITelemetryContent;

    private readonly backToShoppingAttributes?: Msdyn365.IDictionary<string>;

    constructor(props: IOrderConfirmationProps<IOrderConfirmationData>) {
        super(props);
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        const payLoad = getPayloadObject('click', this.telemetryContent, TelemetryConstant.BackToShopping);
        this.backToShoppingAttributes = getTelemetryAttributes(this.telemetryContent, payLoad);
    }

    @computed get isCurrentChannel(): boolean {
        if (!this.order) {
            return false;
        }
        return this.order.ChannelId === get(this.props, 'context.request.apiSettings.channelId');
    }

    @computed get isDataReady(): boolean {
        return get(this.props, 'data.orderHydration.status') === 'SUCCESS';
    }

    @computed get hasError(): boolean {
        return get(this.props, 'data.orderHydration.status') === 'FAILED';
    }

    @computed get order(): SalesOrder | undefined {
        return get(this.props, 'data.orderHydration.result.salesOrder');
    }

    @computed get products(): SimpleProduct[] {
        return get(this.props, 'data.orderHydration.result.products') || [];
    }

    @computed get deliveryOptions(): ProductDeliveryOptions[] {
        return get(this.props, 'data.orderHydration.result.deliveryOptions') || [];
    }

    @computed public get customerName(): Readonly<string | undefined> {
        const customer = this.props.data.accountInformation?.result;
        if (Msdyn365.isOboRequest(this.props.context.request)) {
            // For OBO scenario, display full customer name because multiple customers may have the same first name.
            return customer ? customer.Name : undefined;
        } else {
            return customer ? customer.FirstName || customer.Name : undefined;
        }
    }

    @computed get priceContext(): IPriceContext {
        const {
            id,
            typeName,
            context,
            telemetry,
            resources: { freePriceText }
        } = this.props;
        return {
            id,
            typeName,
            context,
            telemetry,
            freePriceText
        };
    }

    @computed get earnedPoints(): number {
        const loyaltyCard = this.props.data.loyaltyCard.result;
        if (loyaltyCard && loyaltyCard.RewardPoints && this.order) {
            const pointPrograms = new Set(loyaltyCard.RewardPoints.map(point => point.RewardPointId));
            const rewardLines = this.order.LoyaltyRewardPointLines || [];
            let total = 0;
            rewardLines.forEach(line => {
                if ((line.RewardPointAmountQuantity || 0) > 0 && pointPrograms.has(line.RewardPointId)) {
                    total += line.RewardPointAmountQuantity!;
                }
            });
            return total;
        }
        return 0;
    }

    @computed get orderSummaryProps(): IGetOrderSummaryInput | undefined {
        if (!this.order) {
            return;
        }
        const { request } = this.props.context;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const { channelDeliveryOptionConfig, featureState } = this.props?.data;
        const retailMultiplePickUpOptionEnabled = featureState?.result?.find(item => item.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;
        const pickupDeliveryModeCode = request && request.channel && request.channel.PickupDeliveryModeCode;
        const emailDeliveryModeCode = request && request.channel && request.channel.EmailDeliveryModeCode;
        const orderDetailsLines = this.order?.SalesLines;
        const canShip = orderDetailsLines?.some(orderDetailsLine =>
            orderDetailsLine.DeliveryMode && orderDetailsLine.DeliveryMode !== ''
                ? orderDetailsLine.DeliveryMode !==
                      this.getDeliveryMode(
                          orderDetailsLine,
                          retailMultiplePickUpOptionEnabled,
                          channelDeliveryOptionConfig?.result,
                          pickupDeliveryModeCode
                      ) && orderDetailsLine.DeliveryMode !== emailDeliveryModeCode
                : orderDetailsLine
        );
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- app configs are of generic type
        const isShowOrHideTaxEnabled = request.app.config.isEnableShowOrHideSalesTaxECommerceEnabled === true;

        const {
            resources: {
                orderSummaryHeading,
                orderSummaryItemsTotalLabel,
                orderSummaryShippingFeeLabel,
                orderSummaryTaxLabel,
                orderSummaryGrandTotalLabel,
                pointsEarnedLabel
            }
        } = this.props;
        return {
            order: this.order,
            earnedPoints: this.earnedPoints,
            priceContext: this.priceContext,
            resource: {
                orderSummaryHeading,
                orderSummaryItemsTotalLabel,
                orderSummaryShippingFeeLabel,
                orderSummaryTaxLabel,
                pointsEarnedLabel,
                orderSummaryGrandTotalLabel
            },
            canShip,
            isTaxIncludedInPrice: this.order.IsTaxIncludedInPrice,
            isShowTaxBreakUp: isShowOrHideTaxEnabled
        };
    }

    @computed get paymentMethodsProps(): IPaymentMethodsInput | undefined {
        const tenderTypes = this.props.data.tenderTypes.result;
        if (!this.order || !this.order.TenderLines || !tenderTypes) {
            return;
        }

        const locale = get(this.props, 'context.request.locale') || 'en-US';

        const {
            resources: {
                paymentMethodsTitle,
                creditCardEndingLabel,
                giftCardEndingLabel,
                amountCoveredLabel,
                cashUsedLabel,
                loyaltyCardUsedLabel,
                customerAccountUsedLabel
            }
        } = this.props;

        return {
            priceContext: this.priceContext,
            tenderLines: this.order.TenderLines,
            tenderIdOperationIdMap: getTenderIdOperationIdMap(tenderTypes),
            locale,
            resource: {
                paymentMethodsTitle,
                creditCardEndingLabel,
                giftCardEndingLabel,
                amountCoveredLabel,
                cashUsedLabel,
                loyaltyCardUsedLabel,
                customerAccountUsedLabel
            }
        };
    }

    public render(): JSX.Element {
        const {
            resources: {
                noSalesOrderText,
                genericErrorMessage,
                needHelpLabel,
                helpLineNumberLabel,
                loadingLabel,
                backToShopping,
                orderItemLabel,
                orderItemsLabel,
                pickupItemsHeader,
                pickingItemsLabel,
                shippingAddressTitle,
                shippingItemToYouLabel,
                shippingItemToOBOCustomerLabel,
                helpLineContactAriaLabel,
                emailItemsHeader,
                emailingItemsLabel
            },
            config: { heading, contactNumber, shouldShowQrCode, showTimeslot }
        } = this.props;

        const moduleProps = { moduleProps: this.props, className: classname('ms-order-confirmation', this.props.config.className) };
        const backToShoppingUrl = Msdyn365.getUrlSync('home', this.props.context.actionContext) || '';
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const { channelDeliveryOptionConfig, featureState } = this.props?.data;
        const retailMultiplePickUpOptionEnabled = featureState?.result?.find(item => item.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;

        let viewProps: IOrderConfirmationViewProps = {
            ...this.props,
            moduleProps,
            heading: heading && heading.text && (
                <Msdyn365.Text
                    {...heading}
                    className='ms-order-confirmation__heading'
                    text={heading.text}
                    tag={heading.tag || 'h2'}
                    editProps={{ onEdit: this.handleOrderConfirmationHeadingChange, requestContext: this.props.context.request }}
                />
            ),
            backToShoppingLink: backToShoppingUrl && (
                <Button className='ms-order-confirmation__btn-keep-shopping' href={backToShoppingUrl} {...this.backToShoppingAttributes}>
                    {backToShopping}
                </Button>
            ),
            footerProps: { className: 'ms-order-confirmation__footer' }
        };

        if (this.hasError) {
            viewProps = {
                ...viewProps,
                alert: <Label className='ms-order-confirmation__alert' label={genericErrorMessage} />
            };
            return this.props.renderView(viewProps) as React.ReactElement;
        }

        if (!this.isDataReady) {
            viewProps = {
                ...viewProps,
                loading: <Label className='ms-order-confirmation__loading' label={loadingLabel} />
            };
            return this.props.renderView(viewProps) as React.ReactElement;
        }

        if (!this.order) {
            viewProps = {
                ...viewProps,
                alert: <Label className='ms-order-confirmation__alert' label={noSalesOrderText} />
            };
            return this.props.renderView(viewProps) as React.ReactElement;
        }

        const isSalesInvoice = this.order.TransactionTypeValue === TransactionType.SalesInvoice;

        const salesLinesInput = getSalesLinesInput(
            this.props,
            this.moduleName,
            this.order,
            this.products,
            this.priceContext,
            true,
            showTimeslot,
            undefined,
            retailMultiplePickUpOptionEnabled,
            channelDeliveryOptionConfig?.result,
            this.deliveryOptions
        );
        const salesLines = salesLinesInput && getSalesLines(salesLinesInput);
        const orderInformationInput = getOrderInformationInput(
            this.props,
            this.moduleName,
            this.order,
            this.priceContext,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            isSalesInvoice,
            shouldShowQrCode ?? true
        );
        const orderInfomation = getOrderInformation(orderInformationInput);

        viewProps = {
            ...viewProps,
            salesOrder: this.order,
            orderInfomation,
            salesLines,
            groups:
                !isSalesInvoice && salesLines
                    ? getGroups({
                          moduleName: this.moduleName,
                          salesLines,
                          resources: {
                              orderItemLabel,
                              orderItemsLabel,
                              pickupItemsHeader,
                              pickingItemsLabel,
                              shippingAddressTitle,
                              shippingItemToYouLabel,
                              shippingItemToOBOCustomerLabel,
                              emailItemsHeader,
                              emailingItemsLabel
                          },
                          showTimeslot,
                          isConfirmationView: true,
                          retailMultiplePickUpOptionEnabled,
                          customerName: this.customerName,
                          isOboRequest: Msdyn365.isOboRequest(this.props.context.request)
                      })
                    : undefined,
            orderSummary: !isSalesInvoice && this.orderSummaryProps ? getOrderConfirmationOrderSummary(this.orderSummaryProps) : undefined,
            payment: !isSalesInvoice && this.paymentMethodsProps ? getOrderConfirmationPaymentMethods(this.paymentMethodsProps) : undefined,
            help:
                !isSalesInvoice && contactNumber
                    ? getOrderConfirmationHelp({
                          needHelpLabel,
                          helpLineNumberLabel,
                          contactNumber,
                          helpLineContactAriaLabel,
                          telemetryContent: this.telemetryContent
                      })
                    : undefined
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public handleOrderConfirmationHeadingChange = (event: Msdyn365.ContentEditableEvent) =>
        (this.props.config.heading!.text = event.target.value);

    private readonly getDeliveryMode = (
        salesLine: SalesLine,
        featureSate: boolean = false,
        channelDeliveryOptionConfig?: ChannelDeliveryOptionConfiguration,
        pickupDeliveryMode?: string
    ) => {
        if (!featureSate) {
            return pickupDeliveryMode;
        }
        return channelDeliveryOptionConfig?.PickupDeliveryModeCodes?.find(deliveryMode => deliveryMode === salesLine.DeliveryMode);
    };
}

export default OrderConfirmation;
