/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { FullProduct } from '@msdyn365-commerce/commerce-entities';
import * as MsDyn365 from '@msdyn365-commerce/core';
import { AsyncResult, CommerceList, CommerceListLine, SimpleProduct } from '@msdyn365-commerce/retail-proxy';
import { createGetByCustomerInput, removeLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CommerceListsDataActions.g';
import { getDeliveryOptionsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import {
    ArrayExtensions,
    getProductUrlSync,
    IProductInventoryInformation,
    QueryResultSettingsProxy
} from '@msdyn365-commerce-modules/retail-actions';
import {
    getTelemetryObject,
    IModuleProps,
    INodeProps,
    ITelemetryContent,
    updateMaxQuantityForCartLineItem
} from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';

import getItemsInWishlists, { ActiveWishlistInput } from './actions/get-items-in-wishlists';
import { IWishlistItemViewProps, WishlistItem, WishlistItemsStatusMessage } from './components';
import { IWishlistItemsData } from './wishlist-items.data';
import { IHeadingData, IWishlistItemsProps } from './wishlist-items.props.autogenerated';

export interface IWishlistItemActionMessageState {
    productId: number;
    itemKey: string;
    userMessage: string;
    statusCssString: string;
    messageGlyph: string;
    isOpen: boolean;
    isError: boolean;
}

export type wishlistStatus = 'LOADING' | 'SUCCESS' | 'FAILED' | 'EMPTY';

export interface IWishlistItemsViewProps extends IWishlistItemsProps<IWishlistItemsData> {
    WishlistItems: IModuleProps;
    status?: wishlistStatus;
    statusMessage?: React.ReactNode;
    heading?: React.ReactNode;
    Products?: INodeProps;
    Product?: INodeProps;
    ProductDetails?: INodeProps;
    ProductDimensions?: INodeProps;
    products?: IWishlistItemViewProps[];
    telemetryContent?: ITelemetryContent;
    statusNotExistsMessage?: React.ReactNode;
}

/**
 *
 * WishlistItems component.
 * @extends {React.PureComponent<IWishlistItemsProps<IWishlistItemsData>, IWishlistItemActionMessageState>}
 */
@observer
class WishlistItems extends React.Component<IWishlistItemsProps<IWishlistItemsData>, IWishlistItemActionMessageState> {
    private readonly telemetryContent: ITelemetryContent;
    constructor(props: IWishlistItemsProps<IWishlistItemsData>) {
        super(props);
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
    }

    public async componentDidMount(): Promise<void> {
        this.setState({ isError: false });
    }

    public shouldComponentUpdate(nextProps: IWishlistItemsProps<IWishlistItemsData>, nextState: IWishlistItemActionMessageState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        const { heading, className } = this.props.config;
        const { emptyWishlistText, wishlistErrorGettingWishlist, noLongerExitsWishlistItemText } = this.props.resources;
        const { cart, productAvailability, wishlists, products } = this.props.data;

        if (cart.status === 'LOADING' || productAvailability.status === 'LOADING' || wishlists.status === 'LOADING') {
            const errorProps: IWishlistItemsViewProps = {
                ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className)
                },
                status: 'LOADING',

                statusMessage: <WishlistItemsStatusMessage errorType='LOADING' text='Loading...' />,
                heading: this._renderHeading(heading)
            };
            return this.props.renderView(errorProps);
        }

        if (cart.status === 'FAILED' || productAvailability.status === 'FAILED' || wishlists.status === 'FAILED') {
            const errorProps: IWishlistItemsViewProps = {
                ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className)
                },
                status: 'FAILED',
                statusMessage: <WishlistItemsStatusMessage errorType='FAILED' text={wishlistErrorGettingWishlist} />,
                heading: this._renderHeading(heading)
            };

            return this.props.renderView(errorProps);
        }

        const productsList = products && (products as AsyncResult<FullProduct[]>).result;

        if (productsList && productsList.length === 0) {
            const emptyViewProps: IWishlistItemsViewProps = {
                ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className)
                },
                status: 'EMPTY',
                statusMessage: <WishlistItemsStatusMessage errorType='EMPTY' text={emptyWishlistText} />,
                heading: this._renderHeading(heading)
            };

            return this.props.renderView(emptyViewProps);
        }

        const viewProps: IWishlistItemsViewProps = {
            ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
            WishlistItems: {
                moduleProps: this.props,
                className: classnames('ms-wishlist-items', className)
            },
            status: 'SUCCESS',
            heading: this._renderHeading(heading),
            Products: {
                className: 'ms-wishlist-items__products',
                tag: 'ul'
            },
            Product: {
                className: 'ms-wishlist-items__product',
                tag: 'li'
            },
            ProductDetails: {
                className: 'ms-wishlist-items__product-link',
                tag: 'a'
            },
            telemetryContent: this.telemetryContent,
            ProductDimensions: {
                className: 'ms-wishlist-items__product-dimensions'
            },
            products: productsList && this._renderProductList(productsList),
            statusNotExistsMessage:
                productsList && this._getProductNotExists(productsList, emptyWishlistText, noLongerExitsWishlistItemText)
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public handleHeadingChange = (event: MsDyn365.ContentEditableEvent) => (this.props.config.heading!.text = event.target.value);

    private _getProductNotExists(products: FullProduct[], emptytext: string, noLongerExisttext: string): JSX.Element | null {
        if (this.state && this.state.isError) {
            if (products.length === 0) {
                return <WishlistItemsStatusMessage errorType='SUCCESS' text={emptytext} />;
            }
            return (
                <WishlistItemsStatusMessage
                    className={'ms-wishlist-items__message-exists-product'}
                    errorType='SUCCESS'
                    text={noLongerExisttext}
                />
            );
        }
        return null;
    }
    private _renderProductList(products: FullProduct[]): IWishlistItemViewProps[] {
        const {
            priceFree,
            originalPriceText,
            currentPriceText,
            addToCartButtonText,
            outOfStockText,
            removeButtonText,
            productDimensionTypeColor,
            productDimensionTypeSize,
            productDimensionTypeStyle,
            productDimensionTypeAmount
        } = this.props.resources;
        const { context, telemetry } = this.props;
        const { imageSettings, enableImageProductLink } = this.props.config;

        return products.map((product: FullProduct, index) => {
            const currentProductProps = {
                product: product.ProductDetails,
                price: product.ProductPrice,
                context,
                wishlistState: this.state,
                productUrl: getProductUrlSync(product.ProductDetails, context.actionContext, undefined),
                imageSettings,
                removeFromWishlistText: removeButtonText,
                isInStock: this._isProductInStock(product),
                addToCartText: addToCartButtonText,
                outOfStockText,
                index,
                itemKey: `${product.ProductDetails.RecordId}-${product.ProductDetails.ItemId}-${index}`,
                telemetry,
                moduleId: this.props.id,
                moduleTypeName: this.props.typeName,
                enableImageProductLink,
                inventoryInformationLabel: this._inventoryLabel(product),
                inventoryLabelClassName: this._inventoryClassName(product),
                telemetryContent: this.telemetryContent,
                handlers: {
                    onAddToCart: this._addItemToCart,
                    onRemoveItem: this._removeItemFromWishlist,
                    onDismiss: this._onDismiss
                },
                resources: {
                    productDimensionTypeColor,
                    productDimensionTypeSize,
                    productDimensionTypeStyle: product.ProductDetails.IsGiftCard ? productDimensionTypeAmount : productDimensionTypeStyle,
                    freePriceText: priceFree,
                    originalPriceText,
                    currentPriceText
                }
            };
            return WishlistItem(currentProductProps)!;
        });
    }

    // Dismiss alert when addingToCart/removeItem
    private readonly _onDismiss = () => {
        this.setState({
            isOpen: false
        });
    };

    private readonly _renderHeading = (heading?: IHeadingData): JSX.Element | undefined => {
        if (!heading) {
            return undefined;
        }
        return (
            <MsDyn365.Text
                className='ms-wishlist-items__heading'
                tag={heading.tag || 'h2'}
                text={heading.text}
                editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
            />
        );
    };

    private readonly _addItemToCart = async (product: SimpleProduct, itemKey: string): Promise<void> => {
        const { context, data, resources, telemetry } = this.props;
        const { cart, productAvailability } = data;
        const { addedToCartSuccessMessage, addedToCartFailureMessage, invoiceInCartErrorMessage } = resources;

        const productInventoryInformation = this._getProductInventory({ ProductDetails: product }, productAvailability.result);

        if (context) {
            if (cart.result) {
                // Check if the product delivery mode is electronic
                const emailDeliveryModeCode = this.props.context.actionContext.requestContext.channel?.EmailDeliveryModeCode;

                const deliveryOptions = await getDeliveryOptionsAsync(
                    {
                        callerContext: this.props.context.actionContext,
                        queryResultSettings: QueryResultSettingsProxy.getPagingFromInputDataOrDefaultValue(this.props.context.actionContext)
                    },
                    [product.RecordId]
                );
                const validateQuantity = this.isQuantityValidationRequired();
                const quantity = this.respectQuantityLimits() ? product?.Behavior?.MinimumQuantity ?? 1 : 1;

                const addProductToCartInput = {
                    product,
                    count: quantity,
                    enableStockCheck: context.app.config.enableStockCheck,
                    availableQuantity: productInventoryInformation
                        ? productInventoryInformation.ProductAvailableQuantity.AvailableQuantity
                        : 0,
                    additionalProperties: { validateQuantity: validateQuantity },
                    isAddEmailDeliveryItemToCart:
                        ArrayExtensions.hasElements(deliveryOptions) &&
                        ArrayExtensions.hasElements(deliveryOptions[0].DeliveryOptions) &&
                        deliveryOptions[0].DeliveryOptions[0].Code === emailDeliveryModeCode
                };

                cart.result
                    .addProductToCart(addProductToCartInput)
                    .then(async result => {
                        if (result.status === 'SUCCESS') {
                            this.setState({
                                productId: product.RecordId,
                                itemKey,
                                userMessage: addedToCartSuccessMessage,
                                statusCssString: 'success',
                                messageGlyph: 'fas fa-check',
                                isOpen: true
                            });
                        } else if (result.substatus === 'MAXQUANTITY') {
                            const curQuantity =
                                (await cart).cart?.CartLines?.find(item => item.ProductId === product.RecordId)?.Quantity || 0;
                            const maxQtyLimitReachedMessage = this._getInventoryValueMessage(productInventoryInformation, curQuantity);

                            this.setState({
                                productId: product.RecordId,
                                itemKey,
                                userMessage: maxQtyLimitReachedMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        } else if (result.substatus === 'QUANTITYLIMITS' && validateQuantity) {
                            const maxQtyLimitReachedMessage = result.errorDetails?.LocalizedMessage!;

                            this.setState({
                                productId: product.RecordId,
                                itemKey,
                                userMessage: maxQtyLimitReachedMessage || addedToCartFailureMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        } else if (result.substatus === 'INVOICEINCART') {
                            this.setState({
                                productId: product.RecordId,
                                itemKey,
                                userMessage: result.errorDetails?.LocalizedMessage || invoiceInCartErrorMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        } else {
                            this.props.telemetry.debug('[wishlist-items] Unable to Update Cart Line from the wishlist');
                            this.setState({
                                productId: product.RecordId,
                                itemKey,
                                userMessage: addedToCartFailureMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        }
                    })
                    .catch(error => {
                        telemetry.warning(error);
                        telemetry.debug('[wishlist-items] Error trying to Update Cart Line from the wishlist');
                        this.setState({
                            productId: product.RecordId,
                            itemKey,
                            userMessage: addedToCartFailureMessage,
                            statusCssString: 'danger',
                            messageGlyph: 'fas fa-exclamation-triangle',
                            isOpen: true
                        });
                    });
            }
        }
    };

    private isQuantityValidationRequired = (): boolean => {
        const isChannelQuantityLimitsFeatureEnabledInHq =
            this.props.data.featureState.result?.find(
                featureState => featureState.Name === 'Dynamics.AX.Application.EcommerceQuantityLimitConfigurationsFeature'
            )?.IsEnabled || false;

        const isOrderQuantityLimitsFeatureEnabled = this.isOrderQuantityLimitsFeatureEnabled();
        return isOrderQuantityLimitsFeatureEnabled || isChannelQuantityLimitsFeatureEnabledInHq;
    };

    private respectQuantityLimits = (): boolean => {
        const isOrderQuantityLimitsFeatureEnabled = this.isOrderQuantityLimitsFeatureEnabled();
        const validateLimitsPerLine = this.props.data.cartConfiguration?.result?.ValidateDefaultOrderSettingsPerLine ?? false;
        return isOrderQuantityLimitsFeatureEnabled && validateLimitsPerLine;
    };

    private isOrderQuantityLimitsFeatureEnabled = (): boolean => {
        const isOrderQuantityLimitsFeatureEnabledInHq =
            this.props.data.featureState.result?.find(
                featureState => featureState.Name === 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature'
            )?.IsEnabled || false;

        if (!isOrderQuantityLimitsFeatureEnabledInHq) {
            return false;
        }

        const useSiteBuilderSettings = this.props.data.featureState.result?.find(
            featureState => featureState.Name === 'RevertToSiteBuilderOrderQuantityLimitsSettings'
        )?.IsEnabled;

        if (useSiteBuilderSettings) {
            const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;

            const customerInfo = this.props.data.customerInformation.result;

            const isOrderQuantityLimitsFeatureEnabledInSiteSettings =
                defaultOrderQuantityLimitsFeatureConfig === 'all' ||
                ((customerInfo &&
                    ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
                        (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b))) ??
                    false);

            return isOrderQuantityLimitsFeatureEnabledInSiteSettings;
        } else {
            const cartConfiguration = this.props.data.cartConfiguration?.result;
            return !(cartConfiguration?.IgnoreOrderSettings ?? false);
        }
    };

    private readonly _removeItemFromWishlist = (productId: number): void => {
        const { context, data, telemetry } = this.props;
        const { wishlists } = data;
        let noLongerLineExist: CommerceListLine[] | undefined = [];
        if (context && context.actionContext) {
            const userToken = context.request.user.isAuthenticated && context.request.user.token;
            const wishlistLineId = this._getWishlistLineIdFromProductId(productId);
            if (userToken && wishlists.result && wishlists.result[0] && wishlistLineId) {
                removeLinesAsync({ callerContext: context.actionContext }, wishlists.result[0].Id, [{ LineId: wishlistLineId }])
                    .then(commerceList => {
                        const castCommerceList: CommerceList | null = commerceList as CommerceList | null;

                        if (castCommerceList && castCommerceList.Id && context.request.user.isAuthenticated) {
                            noLongerLineExist = this._getProductsNoLongerExists(castCommerceList);
                            if (noLongerLineExist && noLongerLineExist.length > 0) {
                                this._removeNoLongerExistsLines(noLongerLineExist);
                            } else {
                                context.actionContext.update(createGetByCustomerInput({}, null), [castCommerceList]);
                                getItemsInWishlists(new ActiveWishlistInput(), context.actionContext)
                                    .then(products => {
                                        const castSimpleProducts: FullProduct[] | null = products as FullProduct[] | null;
                                        if (castSimpleProducts && castSimpleProducts.length > 0) {
                                            this.setState({ isError: false });
                                            context.actionContext.update(new ActiveWishlistInput(), castSimpleProducts);
                                        }
                                    })
                                    .catch(error => {
                                        telemetry.warning('[wishlist-items] Unable to hyderate the wishlist with product information');
                                        telemetry.error(error);
                                    });
                            }
                        }
                    })
                    .catch(error => {
                        telemetry.warning('[wishlist-items] Unable remove items from the wishlist');
                        telemetry.error(error);
                    });
            } else {
                telemetry.warning("[wishlist-items] Unable remove items from the wishlist user token or lineItemID wasn't found");
            }
        }
    };

    private _getInventoryValueMessage(product: IProductInventoryInformation | undefined, curQuantity: number): string {
        const { context, resources } = this.props;
        const { maxQuantityLimitText } = resources;

        const maxQuantityForLineItem = updateMaxQuantityForCartLineItem(context.app.config.maxQuantityForCartLineItem);

        if (!product || !product.ProductAvailableQuantity.AvailableQuantity || !context.app.config.enableStockCheck) {
            return maxQuantityLimitText
                .replace('{maxQuantity}', maxQuantityForLineItem.toString())
                .replace('{curQuantity}', curQuantity.toString());
        }

        const minInventory = Math.min(maxQuantityForLineItem, product.ProductAvailableQuantity.AvailableQuantity);

        return maxQuantityLimitText.replace('{maxQuantity}', minInventory.toString()).replace('{curQuantity}', curQuantity.toString());
    }

    private _getProductInventory(
        product: FullProduct,
        productInventoryCollection: IProductInventoryInformation[] | undefined
    ): IProductInventoryInformation | undefined {
        if (productInventoryCollection && productInventoryCollection.length > 0) {
            for (const productResult of productInventoryCollection) {
                if (product.ProductDetails.RecordId === productResult.ProductAvailableQuantity.ProductId) {
                    return productResult;
                }
            }
        }
        return undefined;
    }

    private readonly _inventoryLabel = (product: FullProduct): string | undefined => {
        const { productAvailability } = this.props.data;
        if (productAvailability && productAvailability.result) {
            const productInventoryInformation = this._getProductInventory(product, productAvailability.result);
            if (productInventoryInformation) {
                return productInventoryInformation.StockLevelLabel;
            }
        }

        return undefined;
    };

    private readonly _inventoryClassName = (product: FullProduct): string | undefined => {
        const { productAvailability } = this.props.data;
        if (productAvailability && productAvailability.result) {
            const productInventoryInformation = this._getProductInventory(product, productAvailability.result);
            if (productInventoryInformation && productInventoryInformation.StockLevelCode) {
                return `ms-wishlist-items__${productInventoryInformation.StockLevelCode.toLowerCase()}`;
            }
        }

        return undefined;
    };

    private readonly _isProductInStock = (product: FullProduct): boolean => {
        const { data, context } = this.props;
        const { productAvailability } = data;

        if (!context.app.config.enableStockCheck) {
            return true;
        }

        if (!productAvailability.result || !product.ProductDetails) {
            return false;
        }

        for (const productResult of productAvailability.result) {
            if (
                productResult.ProductAvailableQuantity &&
                productResult.ProductAvailableQuantity.ProductId &&
                productResult.ProductAvailableQuantity.ProductId === product.ProductDetails.RecordId
            ) {
                return productResult.IsProductAvailable;
            }
        }

        return false;
    };

    private readonly _getWishlistLineIdFromProductId = (productId: number): number | null => {
        const { wishlists } = this.props.data;

        if (
            !wishlists.result ||
            wishlists.result.length === 0 ||
            !wishlists.result[0].CommerceListLines ||
            wishlists.result[0].CommerceListLines.length === 0
        ) {
            this.props.telemetry.error('Wishlist content is empty, module wont render.');
            return null;
        }

        const foundWishlistItem = wishlists.result[0].CommerceListLines.filter(commerceListLine => {
            return commerceListLine.ProductId === productId;
        });

        if (foundWishlistItem && foundWishlistItem[0].LineId) {
            return foundWishlistItem[0].LineId;
        }
        return null;
    };

    private readonly _getProductsNoLongerExists = (castCommerceList: CommerceList): CommerceListLine[] | undefined => {
        const noLongerExist: CommerceListLine[] | undefined = [];
        castCommerceList.CommerceListLines?.map(line => {
            const { products } = this.props.data;
            const productsList = products && (products as AsyncResult<FullProduct[]>).result!;

            const skipRemove = productsList.filter(product => product.ProductDetails.RecordId === line.ProductId);
            if (skipRemove.length === 0) {
                noLongerExist?.push({ LineId: line.LineId });
            }
        });
        return noLongerExist;
    };

    private readonly _removeNoLongerExistsLines = (noLongerLineExist: CommerceListLine[]) => {
        const { context, data, telemetry } = this.props;
        const { wishlists } = data;
        if (context && context.actionContext) {
            const userToken = context.request.user.isAuthenticated && context.request.user.token;
            if (userToken && wishlists.result && wishlists.result[0]) {
                removeLinesAsync({ callerContext: context.actionContext }, wishlists.result[0].Id, noLongerLineExist)
                    .then(commerceList => {
                        const castCommerceList: CommerceList | null = commerceList as CommerceList | null;
                        if (castCommerceList && castCommerceList.Id && context.request.user.isAuthenticated) {
                            context.actionContext.update(createGetByCustomerInput({}, null), [castCommerceList]);
                            getItemsInWishlists(new ActiveWishlistInput(), context.actionContext)
                                .then(products => {
                                    const castSimpleProducts: FullProduct[] | null = products as FullProduct[] | null;
                                    if (castSimpleProducts && castSimpleProducts.length > 0) {
                                        this.setState({ isError: true });
                                        context.actionContext.update(new ActiveWishlistInput(), castSimpleProducts);
                                    }
                                })
                                .catch(error => {
                                    telemetry.warning('[wishlist-items] Unable to hyderate the wishlist with product information');
                                    telemetry.error(error);
                                });
                        }
                    })
                    .catch(error => {
                        telemetry.warning('[wishlist-items] Unable remove items from the wishlist');
                        telemetry.error(error);
                    });
            } else {
                telemetry.warning("[wishlist-items] Unable remove items from the wishlist user token or lineItemID wasn't found");
            }
        }
    };
}

export default WishlistItems;
