/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { AsyncResultStatus } from '@msdyn365-commerce/core';
import { CheckoutModule, ErrorLocation, IGiftCardExtend } from '@msdyn365-commerce/global-state';
// import { CardType } from '@msdyn365-commerce/retail-proxy';
import { retrieveCardPaymentAcceptResultAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
// import { resolveCardTypesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import {
    // Address,
    // CardPaymentAcceptResult,
    CartLine
    // TokenizedPaymentCard
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateProps, withModuleState, EnabledPaymentsForOBO } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps, INodeProps, Modal } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import get from 'lodash/get';
import { action, computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { AsyncResultStatusCode, GetCheckoutReturnUrl } from '@msdyn365-commerce-modules/checkout';
import { AddPaymentFormComponent } from '@msdyn365-commerce-modules/checkout';
import { ErrorComponent } from '@msdyn365-commerce-modules/checkout';
import { Iframe } from '@msdyn365-commerce-modules/checkout';
import {
    paymentConnectorAmountMessage,
    paymentConnectorExtraContextMessage,
    PaymentConnectorPostMessageType
    // paymentConnectorSubmitMessage
} from '@msdyn365-commerce-modules/checkout';
import { WaitingComponent } from '@msdyn365-commerce-modules/checkout';
import { IVisibilityObserverProps, withVisibilityObserver } from '@msdyn365-commerce-modules/checkout';
import getCardPaymentAcceptPointAction, { GetCardPaymentAcceptPointInput } from './actions/get-card-payment-accept-point';
import { ICheckoutPaymentInstrumentData } from './checkout-payment-instrument.data';
import { ICheckoutPaymentInstrumentProps } from './checkout-payment-instrument.props.autogenerated';
import PaymentInformationComponent from './components/payment-information';
import {
    focusOnCheckoutError
    // setCheckoutErrors
} from '@msdyn365-commerce-modules/checkout';

export interface ICheckoutPaymentInstrumentModuleProps
    extends ICheckoutPaymentInstrumentProps<ICheckoutPaymentInstrumentData>,
        IModuleStateProps,
        IVisibilityObserverProps {}

interface ICheckoutPaymentInstrumentState {
    errorMessage?: string;
    isFetchingPaymentConnector?: boolean;
    paymentConnectorHeight?: number;
    isPaymentVerificationRequried?: boolean;
    paymentVerificationPostData?: string;
    isPaymentProcessing?: boolean;
    isOverlayModal?: boolean;
    isExpressCheckoutApplied?: boolean;
    errorPaymentConnectorId?: string;
}

export interface ICheckoutPaymentOverlayModal {
    modal: INodeProps;
}

export interface ICheckoutPaymentInstrumentViewProps extends ICheckoutPaymentInstrumentProps<{}>, ICheckoutPaymentInstrumentState {
    className?: string;
    checkoutPaymentInstrument: IModuleProps;
    waiting?: React.ReactNode;
    alert?: React.ReactNode;
    paymentInformation?: React.ReactNode;
    addPaymentForm?: React.ReactNode;
    overlayModal?: ICheckoutPaymentOverlayModal;
    isVisible?: boolean;
    checkoutErrorRef?: React.RefObject<HTMLElement>;
}

const zeroAmount = 0;

/**
 *
 * CheckoutPaymentInstrument component.
 * @extends {React.Component<ICheckoutPaymentInstrumentProps<ICheckoutPaymentInstrumentData>>}
 */
// @ts-expect-error
@withModuleState
@observer
export class CheckoutPaymentInstrument extends React.PureComponent<ICheckoutPaymentInstrumentModuleProps> {
    @computed get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.loyaltyAmount ? checkoutState.loyaltyAmount : 0;
    }

    @computed get getCustomerAccountAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.customerAccountAmount ? checkoutState.customerAccountAmount : 0;
    }

    @computed get getGiftCardTotalAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count: number, giftCard: IGiftCardExtend) => {
            const balance: number = giftCard.Balance || 0;
            return count + balance;
        }, 0);
    }

    @computed public get amountDue(): number {
        const {
            data: { checkout }
        } = this.props;
        if (!checkout.result) {
            return 0;
        }

        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart.cart;
        if (!cart || !cart.CartLines || cart.CartLines.length === 0) {
            return 0;
        }

        // Use the card for payment after all other payment methods
        return (cart.TotalAmount || zeroAmount) - this.getGiftCardTotalAmount - this.getLoyaltyAmount - this.getCustomerAccountAmount;
    }

    @computed get shouldPaidByCard(): boolean {
        const {
            data: { checkout },
            config
        } = this.props;
        if (!checkout.result) {
            return false;
        }

        const checkoutResult = checkout.result;

        const { paymentTenderType, tokenizedPaymentCard, isExpressAddressApplied } = checkoutResult;
        const isPaidByOtherPaymentSource =
            config.paymenTenderType?.toLocaleLowerCase() !== paymentTenderType?.toLocaleLowerCase() &&
            (tokenizedPaymentCard || isExpressAddressApplied);

        return this.amountDue > zeroAmount && !isPaidByOtherPaymentSource;
    }

    @computed get isCartContainsItemsForShipping(): boolean {
        const pickupDeliveryModeCode = get(this.props, 'context.request.channel.PickupDeliveryModeCode');
        const emailDeliveryModeCode = get(this.props, 'context.request.channel.EmailDeliveryModeCode');
        const { channelDeliveryOptionConfig, featureState } = this.props.data;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const retailMultiplePickUpOptionEnabled = featureState?.result?.find(feature => feature.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;

        return retailMultiplePickUpOptionEnabled
            ? (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).some(
                  (cartLine: CartLine) =>
                      cartLine.DeliveryMode !==
                          channelDeliveryOptionConfig.result?.PickupDeliveryModeCodes?.find(
                              deliveryMode => deliveryMode === cartLine.DeliveryMode
                          ) && cartLine.DeliveryMode !== emailDeliveryModeCode
              )
            : (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).some(
                  (cartLine: CartLine) =>
                      cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
              );
    }

    @computed get isCartHasSelectedDeliveryMethods(): boolean {
        return (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).every(
            (cartLine: CartLine) => !!cartLine.DeliveryMode
        );
    }

    @computed get asyncResultStatus(): AsyncResultStatus | undefined {
        const isLoading = Object.values(this.props.data).some(data => get(data, 'status') === AsyncResultStatusCode.LOADING);
        if (isLoading) {
            return AsyncResultStatusCode.LOADING;
        }

        const isSuccess = Object.values(this.props.data).every(data => get(data, 'status') === AsyncResultStatusCode.SUCCESS);
        if (isSuccess) {
            return AsyncResultStatusCode.SUCCESS;
        }

        const isFailed = Object.values(this.props.data).some(data => get(data, 'status') === AsyncResultStatusCode.FAILED);
        if (isFailed) {
            return AsyncResultStatusCode.FAILED;
        }
        return;
    }

    @computed get hasSelectedItem(): boolean {
        return !!get(this.props.data, 'checkoutState.result.tokenizedPaymentCard');
    }

    @computed get shouldReloadAcceptPage(): boolean {
        return !get(this.props.data, 'cardPaymentAcceptPoint.result.NotReloadAcceptPageContentWhenAmountChanged');
    }

    @computed get requestUrlOrigin(): string {
        const origin = get(window, 'location.origin');
        const requestUrl =
            typeof get(this.props, 'context.request.url.requestUrl') === 'string'
                ? new URL(get(this.props, 'context.request.url.requestUrl'))
                : get(this.props, 'context.request.url.requestUrl');
        return origin || requestUrl.origin;
    }

    public state: ICheckoutPaymentInstrumentState = {
        isFetchingPaymentConnector: true
    };

    private readonly moduleClassName: string = 'ms-checkout-payment-instrument';

    private readonly iframeRef: React.RefObject<Iframe> = React.createRef();

    private readonly checkoutErrorRef: React.RefObject<HTMLElement> = React.createRef();

    public componentDidMount(): void {
        when(
            () => this.asyncResultStatus !== AsyncResultStatusCode.LOADING,
            () => {
                this.init();

                this._handleExpressCheckout();
            }
        );
        reaction(
            () => this.asyncResultStatus !== AsyncResultStatusCode.FAILED && this.shouldPaidByCard,
            () => {
                this.togglePayment();
            }
        );

        reaction(
            () => this.amountDue,
            async () => {
                if (
                    this.shouldReloadAcceptPage &&
                    !this.props.data.checkout.result?.isExpressCheckoutApplied &&
                    this.amountDue > zeroAmount &&
                    !this.props.data.checkout.result?.isPaymentVerificationRedirection
                ) {
                    await this.onEdit();

                    this.props.telemetry.information(
                        `AmountDue is updated and onEdit() is called for payment instrument ${this.props.config.paymenTenderType ?? ''}.`
                    );
                }

                // send amount to payment connector
                const message = paymentConnectorAmountMessage(this.amountDue);
                this.postMessageToIframe(message, false /* setPending */);
            }
        );

        reaction(
            () => this.props.data.checkout.result?.isExpressCheckoutApplied,
            () => {
                this._handleExpressCheckout();
            }
        );

        if (this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging) {
            reaction(
                () => this.props.data.checkout.result?.checkoutError,
                checkoutError => {
                    if (
                        (this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId ===
                            this.props.data.checkout.result?.checkoutErrorPaymentConnectorId ||
                            this.state.errorPaymentConnectorId) &&
                        checkoutError &&
                        checkoutError.errorLocation === ErrorLocation.CheckoutPaymentInstrument &&
                        checkoutError.errorMessage
                    ) {
                        this.setErrorMessage(checkoutError.errorMessage);
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.checkoutErrorFocus,
                checkoutErrorFocus => {
                    if (
                        (this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId ===
                            this.props.data.checkout.result?.checkoutErrorPaymentConnectorId ||
                            this.state.errorPaymentConnectorId) &&
                        checkoutErrorFocus === CheckoutModule.CheckoutPaymentInstrument
                    ) {
                        focusOnCheckoutError(this.checkoutErrorRef, this.props.context.actionContext);
                    }
                }
            );
        }

        // Reaction for new checkout flow.
        if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
            reaction(
                () =>
                    this.props.data.checkout.result?.redirectAdditionalContext &&
                    this.props.data.checkout.result?.redirectPaymentConnectorId,
                () => {
                    if (
                        !this.props.data.checkout.result?.isExpressCheckoutApplied &&
                        this.props.data.checkout.result?.redirectAdditionalContext &&
                        this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId ===
                            this.props.data.checkout.result?.redirectPaymentConnectorId
                    ) {
                        this.handleAdditionalContext(this.props.data.checkout.result.redirectAdditionalContext);

                        this.props.telemetry.information(
                            `For single payment auth, handle Additional Context in reaction for payment instrument ${this.props.config
                                .paymenTenderType ?? ''}.`
                        );
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.isPlaceOrderEnabledInRedirection,
                () => {
                    if (
                        !this.props.data.checkout.result?.isExpressCheckoutApplied &&
                        this.props.data.checkout.result?.isPlaceOrderEnabledInRedirection &&
                        this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId ===
                            this.props.data.checkout.result?.redirectPaymentConnectorId
                    ) {
                        this.init();

                        this.props.telemetry.information(`For single payment auth, isPlaceOrderEnabledInRedirection is updated to
                         ${
                             this.props.data.checkout.result?.isPlaceOrderEnabledInRedirection
                         } and init() is called for payment instrument ${this.props.config.paymenTenderType ?? ''}.`);
                    }
                }
            );
        }
    }

    // eslint-disable-next-line complexity -- from existing code.
    public render(): JSX.Element | null {
        const {
            errorMessage,
            isFetchingPaymentConnector,
            paymentConnectorHeight,
            isPaymentVerificationRequried,
            isPaymentProcessing,
            isOverlayModal,
            isExpressCheckoutApplied
        } = this.state;
        const {
            moduleState: { isReady, hasError, hasInitialized, isPending, hasExternalSubmitGroup },
            config: { iFrameHeightOverride, paymentStyleOverride, className, showBillingAddress, paymenTenderType },
            resources,
            data: { checkout, cardPaymentAcceptPoint },
            visibilityObserver
        } = this.props;

        const isVisible = visibilityObserver && visibilityObserver.isVisible;

        const isSinglePayment = checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout;

        if (!hasInitialized || (this.asyncResultStatus !== AsyncResultStatusCode.FAILED && !this.shouldPaidByCard)) {
            this.props.context.telemetry.error('Checkout payment content is empty, module wont render');
            return null;
        }

        if (this.props.context.request.user.isOBORequest && EnabledPaymentsForOBO.PaymentInstrument === 0) {
            this.props.context.telemetry.information('isOBORequest is enabled, Checkout payment instrument module wont render');
            return null;
        }

        const { AcceptPageUrl, AcceptPageContent, MessageOrigin } = cardPaymentAcceptPoint.result ?? {
            AcceptPageUrl: undefined,
            AcceptPageContent: undefined,
            MessageOrigin: undefined
        };

        const { tokenizedPaymentCard, tenderLine, billingAddress } = checkout.result || {
            tokenizedPaymentCard: undefined,
            tenderLine: undefined,
            billingAddress: undefined
        };

        const paymentTenderTypeClassName = paymenTenderType ? `${this.moduleClassName}-${paymenTenderType.toLowerCase()}` : '';

        const viewProps: ICheckoutPaymentInstrumentViewProps = {
            ...this.props,
            ...this.state,
            isVisible,
            className,
            checkoutErrorRef: this.checkoutErrorRef,

            checkoutPaymentInstrument: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, paymentTenderTypeClassName, className)
            },
            waiting: !isReady &&
                !isExpressCheckoutApplied &&
                this.asyncResultStatus !== AsyncResultStatusCode.FAILED &&
                (this.asyncResultStatus === AsyncResultStatusCode.LOADING || isFetchingPaymentConnector || isPending) && (
                    <WaitingComponent {...{ message: resources.loadingMessage }} />
                ),
            alert: hasError && errorMessage && <ErrorComponent {...{ title: resources.errorMessageTitle, message: errorMessage }} />,
            paymentInformation: (isExpressCheckoutApplied ||
                (isReady && !isSinglePayment && !isPaymentVerificationRequried && !isPaymentProcessing)) && (
                <PaymentInformationComponent
                    tokenizedPaymentCard={tokenizedPaymentCard}
                    tenderLine={tenderLine}
                    billingAddress={showBillingAddress ? billingAddress : undefined}
                    canEdit={!hasExternalSubmitGroup}
                    onEdit={this.onEdit}
                    resources={resources}
                />
            ),
            addPaymentForm: !isExpressCheckoutApplied &&
                (!isReady || isSinglePayment || isPaymentVerificationRequried) &&
                !isPaymentProcessing &&
                (AcceptPageUrl || AcceptPageContent) &&
                isVisible && (
                    <AddPaymentFormComponent
                        acceptPageUrl={AcceptPageUrl}
                        acceptPageContent={AcceptPageContent}
                        messageOrigin={MessageOrigin}
                        onSubmit={this.onSubmit}
                        onCancel={this.onCancel}
                        onIFrameMessage={this.onIFrameMessage}
                        iframeRef={this.iframeRef}
                        canSubmit={!hasExternalSubmitGroup}
                        canCancel={!hasExternalSubmitGroup && this.hasSelectedItem}
                        iFrameHeightOverride={iFrameHeightOverride || paymentConnectorHeight}
                        requestUrlOrigin={this.requestUrlOrigin}
                        isFetchingPaymentConnector={isFetchingPaymentConnector}
                        paymentStyleOverride={paymentStyleOverride}
                        resources={resources}
                    />
                ),
            overlayModal: {
                modal: {
                    tag: Modal,
                    className: `${this.moduleClassName}__overlay-modal`,
                    isOpen: isOverlayModal
                }
            }
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    // private readonly onIFrameMessage = async (event: MessageEvent): Promise<void> => {
    //     let result;
    //     try {
    //         if (typeof event.data !== 'string') {
    //             return;
    //         }
    //         result = JSON.parse(event.data);
    //     } catch (error) {
    //         this.setTerminalError(error);
    //         return;
    //     }

    //     const shouldCheckConnectorId = this.props.config.shouldCheckConnectorId;

    //     const paymentConnectorId = this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId;

    //     if (!result || !result.type || (shouldCheckConnectorId && result.id !== paymentConnectorId)) {
    //         if (shouldCheckConnectorId && result.type && !result.id) {
    //             this.props.telemetry.error('User connector id flag is checked but connector id is not sent from the connector.');
    //             console.error(
    //                 `${this.props.config.paymenTenderType ??
    //                     ''} User connector id flag is checked but connector id is not sent from the connector.`
    //             );
    //         }

    //         return;
    //     }

    //     const { type, value, express = false } = result;

    //     // If express flag in the result is true, then regular payment module should not handle this message.
    //     if (express) {
    //         return;
    //     }

    //     this.props.telemetry.information(`Payment instrument ${this.props.config.paymenTenderType ?? ''} handles onIframeMessage ${type}.`);

    //     switch (type) {
    //         case PaymentConnectorPostMessageType.Height:
    //             // The payment connector will post height after it completes initialization
    //             this.setState({
    //                 isFetchingPaymentConnector: false,
    //                 paymentConnectorHeight: value
    //             });

    //             // send amount to payment connector
    //             const message = paymentConnectorAmountMessage(this.amountDue);
    //             this.postMessageToIframe(message, false /* setPending */);

    //             if (this.props.config.isPrimaryPayment) {
    //                 this.props.moduleState.onUpdating();
    //             }

    //             return;
    //         case PaymentConnectorPostMessageType.Result:
    //             this.handlePaymentResult(value);
    //             return;
    //         case PaymentConnectorPostMessageType.CardPrefix:
    //             await this.handlePaymentCardPrefix(value);
    //             return;
    //         case PaymentConnectorPostMessageType.Error:
    //             this.handlePaymentError(value);
    //             return;
    //         case PaymentConnectorPostMessageType.Redirect:
    //             this.handlePaymentRedirect(value);
    //             return;
    //         case PaymentConnectorPostMessageType.Showoverlay:
    //             this.showOverlayModal(true);
    //             return;
    //         case PaymentConnectorPostMessageType.Hideoverlay:
    //             this.showOverlayModal(false);
    //             return;
    //         default:
    //             return;
    //         // Do nothing
    //     }
    // };

    private readonly onIFrameMessage = async (event: MessageEvent): Promise<void> => {
        let result;
        try {
            if (typeof event.data !== 'string') {
                return;
            }
            result = JSON.parse(event.data);
        } catch (error) {
            this.setTerminalError(error);
            return;
        }

        if (result.type === PaymentConnectorPostMessageType.Height) {
            this.setState({
                isFetchingPaymentConnector: false,
                paymentConnectorHeight: result.value
            });
            this.postMessageToIframe(paymentConnectorAmountMessage(this.amountDue), false);
        }
    };

    // @action
    // private readonly handlePaymentResult = (resultAccessCode: string, isRedirectedFromPaymentGateway: boolean = false): void => {
    //     const {
    //         data: { checkout, cardPaymentAcceptPoint },
    //         config: { isPrimaryPayment, paymenTenderType },
    //         context: { actionContext },
    //         resources: { termsAndConditionErrorMessage }
    //     } = this.props;

    //     const cartId = checkout.result?.checkoutCart.cart.Id || '';
    //     const paymentConnectorId = cardPaymentAcceptPoint.result?.PaymentConnectorId;

    //     const settings = {
    //         ReturnUrl: GetCheckoutReturnUrl(actionContext),
    //         ...(paymentConnectorId && { PaymentConnectorId: paymentConnectorId })
    //     };

    //     if (checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
    //         const cardPaymentAcceptResult: CardPaymentAcceptResult = {
    //             AccessCode: resultAccessCode,
    //             Settings: settings
    //         };

    //         checkout.result
    //             .updateCardPaymentAcceptResult({ newCardPaymentAcceptResult: cardPaymentAcceptResult })
    //             .then(async () => {
    //                 if (isRedirectedFromPaymentGateway) {
    //                     this.props.data.checkout.result?.checkoutCart.refreshCart({});

    //                     this.props.moduleState.setHasError(false);
    //                     this.props.moduleState.onReady();
    //                     this.setState({
    //                         terminalError: null,
    //                         errorMessage: null
    //                     });
    //                     this.props.moduleState.setIsSubmitContainer(true);

    //                     await checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
    //                     await checkout.result?.updateIsPaymentSectionContainerReady({ newIsPaymentSectionContainerReady: true });
    //                 } else if (isPrimaryPayment) {
    //                     this.props.moduleState.setHasError(false);
    //                     this.props.moduleState.onReady();
    //                     this.setState({
    //                         terminalError: null,
    //                         errorMessage: null
    //                     });
    //                     this.props.moduleState.setIsSubmitContainer(true);
    //                 } else {
    //                     if (
    //                         checkout.result?.isTermsAndConditionChecked !== false ||
    //                         checkout.result.isTermsAndConditionAccepted !== false
    //                     ) {
    //                         this.props.moduleState.onSkip();
    //                         await checkout.result?.updateIsPaymentSectionContainerReady({ newIsPaymentSectionContainerReady: true });
    //                     } else {
    //                         this.props.moduleState.setHasError(true);
    //                         this.setErrorMessage(termsAndConditionErrorMessage);
    //                     }
    //                 }
    //             })
    //             .catch(async (error: Error) => {
    //                 // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
    //                 await this.updatePaymentAcceptPageData();
    //                 this.setTerminalError(error);
    //             })
    //             .finally(() => {
    //                 this.setState({ isPaymentProcessing: false });
    //             });

    //         return;
    //     }

    //     retrieveCardPaymentAcceptResultAsync({ callerContext: this.props.context.actionContext }, resultAccessCode, [], cartId, settings)
    //         .then(async cardPaymentAcceptResult => {
    //             const { TenderLine, TokenizedPaymentCard, AdditionalContext } = cardPaymentAcceptResult || {};

    //             await this.saveBillingAddress(TokenizedPaymentCard);

    //             if (AdditionalContext) {
    //                 this.handleAdditionalContext(AdditionalContext);
    //             } else {
    //                 if (!TokenizedPaymentCard) {
    //                     this.setTerminalError(new Error('No TokenizedPaymentCard found'));
    //                     return;
    //                 }
    //                 const checkoutState = this.props.data.checkout.result;
    //                 if (checkoutState) {
    //                     // Try to update card prefix, if it is not set already.
    //                     // Adyen connector does not send msax-cc-cardprefix message
    //                     // but it sets the card prefix in tokenized card
    //                     if (!checkoutState.cardPrefix) {
    //                         const cardPrefix =
    //                             TokenizedPaymentCard &&
    //                             TokenizedPaymentCard.CardTokenInfo &&
    //                             TokenizedPaymentCard.CardTokenInfo.MaskedCardNumber;
    //                         if (cardPrefix) {
    //                             await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
    //                         }
    //                     }

    //                     if (!TokenizedPaymentCard.CardTypeId) {
    //                         const cardTypeId = await this.getCardTypeId(checkoutState.cardPrefix || '');
    //                         if (!cardTypeId) {
    //                             const error = new Error('The specified card type is not supported.');
    //                             error.name = 'CARDTYPENOTFOUND';
    //                             this.setTerminalError(error);
    //                             return;
    //                         }

    //                         TokenizedPaymentCard.CardTypeId = cardTypeId;
    //                     }

    //                     await checkoutState.updateTenderLine({ newTenderLine: TenderLine });
    //                     await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: TokenizedPaymentCard });
    //                     await checkoutState.updatePaymentTenderType({ newPaymentTenderType: paymenTenderType });

    //                     // In case of PSD2 redirect, cart we be updated in server side so refresh cart.
    //                     if (isRedirectedFromPaymentGateway) {
    //                         this.props.data.checkout.result?.checkoutCart.refreshCart({});
    //                     }

    //                     this.props.moduleState.setHasError(false);
    //                     this.props.moduleState.onReady();
    //                     this.setState({
    //                         terminalError: null,
    //                         errorMessage: null
    //                     });
    //                     this.props.moduleState.setIsSubmitContainer(true);
    //                 }
    //             }
    //         })
    //         .catch(error => {
    //             // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
    //             this.updatePaymentAcceptPageData();
    //             this._handleCheckoutError(error);
    //         })
    //         .finally(() => {
    //             this.setState({
    //                 isPaymentProcessing: false
    //             });
    //         });
    // };

    // @action
    // private readonly handlePaymentCardPrefix = async (cardPrefix: string): Promise<void> => {
    //     const checkoutState = this.props.data.checkout.result;
    //     if (checkoutState) {
    //         await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
    //     }
    // };

    // @action
    // private readonly handlePaymentRedirect = (redirectData: string): void => {
    //     this.setState({
    //         isPaymentVerificationRequried: true,
    //         paymentVerificationPostData: redirectData
    //     });
    //     this.props.moduleState.setHasError(false);
    //     this.onContainerReady();
    // };

    // private readonly showOverlayModal = (isShow: boolean): void => {
    //     this.setState({ isOverlayModal: isShow });
    // };

    // private readonly getCardTypeId = async (cardPrefix: string = ''): Promise<string | undefined> => {
    //     try {
    //         const response = await resolveCardTypesAsync({ callerContext: this.props.context.actionContext }, cardPrefix, CardType.Unknown);
    //         if (response && response.length > 0) {
    //             return response[0].TypeId;
    //         }
    //     } catch (error) {
    //         this.props.context.telemetry.error('Call to resolveCardTypesAsync failed.', error);
    //     }
    //     return undefined;
    // };

    private readonly redirectToPaymentVerification = async (): Promise<void> => {
        const { isPaymentVerificationRequried, paymentVerificationPostData } = this.state;
        if (!isPaymentVerificationRequried || !paymentVerificationPostData) {
            return;
        }

        const checkoutState = this.props.data.checkout.result;
        if (checkoutState) {
            await checkoutState.updatePaymentTenderType({ newPaymentTenderType: this.props.config.paymenTenderType });
            await checkoutState.saveDataInStorage({});
            await checkoutState.updateIsPaymentVerificationRequired({ newIsPaymentVerificationRequired: true });
        }

        const redirectInfo = JSON.parse(paymentVerificationPostData);
        const { url, data } = redirectInfo;
        const form = document.createElement('form');

        form.method = 'POST';
        form.action = url;

        for (const propertyName of Object.keys(data)) {
            const element = document.createElement('input');
            element.name = propertyName;
            element.value = data[propertyName];
            form.appendChild(element);
        }

        document.body.appendChild(form);
        form.submit();

        this.props.telemetry.information(
            `RedirectToPaymentVerification is submitted for payment instrument ${this.props.config.paymenTenderType ?? ''}.`
        );
    };

    // private readonly handlePaymentError = (value?: { Message: string }[]): void => {
    //     const {
    //         resources: { defaultSubmitErrorMessage = 'An error occurred in payment method details. Please try again.' }
    //     } = this.props;
    //     if (!value || value.length === 0) {
    //         // Fallback, if no message could be translated from payment accept page response
    //         this.setErrorMessage(defaultSubmitErrorMessage);
    //         return;
    //     }
    //     this.setErrorMessage(value.map((_value: { Message: string }) => _value.Message).join('\n'));
    // };

    @action
    // private readonly init = (): void => {
    //     const {
    //         data: { checkout },
    //         config
    //     } = this.props;

    //     const moduleStatusWhenExpressCheckoutApplied = checkout.result?.isExpressCheckoutApplied ? 'ready' : 'updating';

    //     this.props.moduleState.init({
    //         onEdit: this.onEdit,
    //         onCancel: this.onCancel,
    //         onSubmit: this.onSubmit,
    //         onContainerReady: this.onContainerReady,
    //         isCancellable: false,
    //         status: this.shouldPaidByCard ? moduleStatusWhenExpressCheckoutApplied : 'disabled'
    //     });

    //     if (
    //         checkout.result?.isPaymentVerificationRedirection &&
    //         !(checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && !checkout.result.isPlaceOrderEnabledInRedirection)
    //     ) {
    //         if (config.paymenTenderType === checkout.result?.paymentTenderType) {
    //             const { requestFormData, query } = this.props.context.request;

    //             const formData = btoa(JSON.stringify(requestFormData ?? { redirectResult: query?.redirectResult }));

    //             this.setState({
    //                 isPaymentProcessing: true
    //             });

    //             this.props.moduleState.onPending();
    //             this.handlePaymentResult(formData, true);
    //         }
    //     } else if (this.asyncResultStatus === AsyncResultStatusCode.FAILED) {
    //         this.setState({
    //             isFetchingPaymentConnector: false
    //         });
    //         this.setTerminalError(new Error('Failed in load data'));
    //     } else if (checkout.result?.isExpressCheckoutApplied) {
    //         this._handleExpressCheckout();
    //     }
    // };
    private readonly init = async (): Promise<void> => {
        try {
            const {
                context: { request }
            } = this.props;

            this.props.moduleState.init({
                onEdit: this.onEdit,
                onCancel: this.onCancel,
                onSubmit: this.onSubmit,
                onContainerReady: this.onContainerReady,
                isCancellable: false,
                status: this.shouldPaidByCard ? 'updating' : 'disabled'
            });

            // Safely access query parameters
            const url = new URL(request.url.requestUrl);
            const queryParams = new URLSearchParams(url.search); // Pass url.search instead of url

            // Check if this is a redirect from N-Genius
            if (queryParams.get('ref')) {
                this.setState({ isPaymentProcessing: true });
                this.props.moduleState.onPending();
                this.handlePaymentResultFromQuery(Object.fromEntries(queryParams));
            } else if (this.asyncResultStatus === AsyncResultStatusCode.FAILED) {
                this.setState({ isFetchingPaymentConnector: false });
                this.setTerminalError(new Error('Failed to load data'));
            }
        } catch (error) {
            this.setTerminalError(error instanceof Error ? error : new Error('Initialization failed'));
            this.setState({ isFetchingPaymentConnector: false });
        }
    };

    @action
    private readonly handlePaymentResultFromQuery = (query: { [key: string]: string }): void => {
        const {
            data: { checkout },
            context: { actionContext }
        } = this.props;

        const transactionId = query.transactionId;
        const status = query.status; // e.g., "SUCCESS", "FAILED"
        const cartId = checkout.result?.checkoutCart.cart.Id || '';

        if (!transactionId || !status) {
            this.setTerminalError(new Error('Missing transaction details in redirect'));
            return;
        }

        // Map N-Genius status to Dynamics 365 Commerce payment status
        const paymentSuccess = status.toUpperCase() === 'SUCCESS';
        const resultAccessCode = btoa(JSON.stringify({ transactionId, status })); // Encode for Retail Server

        retrieveCardPaymentAcceptResultAsync({ callerContext: actionContext }, resultAccessCode, [], cartId, {
            ReturnUrl: GetCheckoutReturnUrl(actionContext),
            PaymentConnectorId: 'NGENIUS'
        })
            .then(async cardPaymentAcceptResult => {
                const { TokenizedPaymentCard, TenderLine } = cardPaymentAcceptResult || {};
                if (!TokenizedPaymentCard && paymentSuccess) {
                    this.setTerminalError(new Error('No TokenizedPaymentCard returned from N-Genius'));
                    return;
                }

                const checkoutState = checkout.result;
                if (checkoutState) {
                    if (paymentSuccess) {
                        await checkoutState.updateTenderLine({ newTenderLine: TenderLine });
                        await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: TokenizedPaymentCard });
                        await checkoutState.updatePaymentTenderType({ newPaymentTenderType: this.props.config.paymenTenderType });
                        checkoutState.checkoutCart.refreshCart({});

                        this.props.moduleState.setHasError(false);
                        this.props.moduleState.onReady();
                        this.setState({ errorMessage: null, isPaymentProcessing: false });
                    } else {
                        this.setErrorMessage('Payment failed. Please try again.');
                        this.updatePaymentAcceptPageData(); // Refresh for a new session
                    }
                }
            })
            .catch(error => {
                this.setTerminalError(error);
                this.updatePaymentAcceptPageData();
            });
    };

    @action
    private readonly setTerminalError = (terminalError: Error): void => {
        this.props.telemetry.exception(terminalError);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        const {
            resources: { genericErrorMessage, cardTypeErrorMessage }
        } = this.props;
        let errorMessage = genericErrorMessage;

        switch (terminalError.name) {
            case 'CARDTYPENOTFOUND': {
                errorMessage = cardTypeErrorMessage;
                break;
            }
            default:
        }

        this.setState({
            terminalError,
            errorMessage
        });
    };

    @action
    private readonly setErrorMessage = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.setState({
            errorMessage
        });
    };

    private readonly updatePaymentAcceptPageData = async (): Promise<void> => {
        const {
            context: { actionContext },
            config: { showBillingAddress, paymenTenderType, shouldPassLocaleToiFrame },
            context: {
                request: { apiSettings }
            },
            data: { checkout }
        } = this.props;

        const input = {
            showBillingAddress,
            paymenTenderType,
            apiSettings,
            shouldEnableSinglePaymentAuthorizationCheckout: checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout,
            amountDue: this.amountDue,
            shouldPassLocaleToiFrame
        };

        this.setState({
            isFetchingPaymentConnector: true
        });

        const checkoutState = checkout.result;
        if (checkoutState) {
            await checkoutState.updatePaymentTenderType({ newPaymentTenderType: undefined });
            await checkoutState.updateTenderLine({ newTenderLine: undefined });
            await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: undefined });
        }

        getCardPaymentAcceptPointAction(new GetCardPaymentAcceptPointInput(input), actionContext)
            .then(paymentAcceptPoint => {
                // In case, add form is not hidden. We need to explicitly reset value to force re-rendering.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });

                // IMPORTANT: Do NOT set isFetchingPaymentConnector = false in getCardPaymentAcceptPointAction success response.
                // The payment connector will post a message with content height when payment is ready.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), paymentAcceptPoint);
                this.setState({ paymentConnectorId: paymentAcceptPoint.PaymentConnectorId });

                // For new checkout flow, redirect additionContext comes from Checkout API exception and will be handled in below.
                if (checkoutState?.shouldEnableSinglePaymentAuthorizationCheckout && checkoutState.redirectAdditionalContext) {
                    this.handleAdditionalContext(checkoutState.redirectAdditionalContext);
                }
            })
            .catch((error: Error) => {
                this.setTerminalError(error);

                this.setState({
                    isFetchingPaymentConnector: false
                });

                // IMPORTANT: Clear the AcceptPageUrl and AcceptPageContent. It should not re-use the previous session for the security reason.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });
            });
    };

    private readonly postMessageToIframe = (message: object, setPending: boolean) => {
        const postMessage = get(this.iframeRef, 'current.postMessage');
        if (postMessage) {
            if (setPending) {
                this.props.moduleState.onPending();
            }
            postMessage(message);
        }
    };

    private readonly handleAdditionalContext = (additionalContext: string): void => {
        const message = paymentConnectorExtraContextMessage(additionalContext);
        this.postMessageToIframe(message, true /* setPending */);

        // eslint-disable-next-line no-console -- log the message for more information.
        console.log('Post payment connector extraContext message.');
    };

    // private readonly saveBillingAddress = async (tokenizedPaymentCard?: TokenizedPaymentCard): Promise<void> => {
    //     const { showBillingAddress } = this.props.config;
    //     const checkoutState = this.props.data.checkout.result;

    //     // If we use billing address provided by adyen, billing address returned in TokenizedPaymentCard.
    //     if (checkoutState && showBillingAddress && tokenizedPaymentCard && tokenizedPaymentCard.Zip) {
    //         const billingAddress: Address = {
    //             ThreeLetterISORegionName: tokenizedPaymentCard.Country,
    //             Name: tokenizedPaymentCard.House === 'N/A' ? '' : tokenizedPaymentCard.House,
    //             Street: tokenizedPaymentCard.Address1,
    //             StreetNumber: tokenizedPaymentCard.Address2,
    //             City: tokenizedPaymentCard.City,
    //             State: tokenizedPaymentCard.State,
    //             ZipCode: tokenizedPaymentCard.Zip,
    //             Phone: tokenizedPaymentCard.Phone
    //         };
    //         await checkoutState.updateBillingAddress({ newBillingAddress: billingAddress });
    //     }
    // };

    @action
    private readonly togglePayment = () => {
        if (this.shouldPaidByCard && this.props.moduleState.isDisabled) {
            this.props.moduleState.onUpdating();
        } else if (!this.shouldPaidByCard && !this.props.moduleState.isDisabled) {
            this.props.moduleState.setHasError(false);
            this.props.moduleState.onDisable();
        }
    };

    // @action
    // private readonly onSubmit = (): void => {
    //     const { isPrimaryPayment = true, paymenTenderType } = this.props.config;

    //     this.props.telemetry.information(`Payment instrument ${paymenTenderType ?? ''} onSubmit is called.`);

    //     if (isPrimaryPayment) {
    //         this.postMessageToIframe(paymentConnectorSubmitMessage(), true /* setPending */);
    //     } else {
    //         this.props.moduleState.onSkip();
    //     }
    // };

    @action
    private readonly onSubmit = (): void => {
        this.props.telemetry.information(`Payment instrument ${this.props.config.paymenTenderType ?? ''} onSubmit is called.`);
        this.setState({ isPaymentProcessing: true });
        // No postMessage needed; N-Genius will redirect after "Pay Now" is clicked
    };

    @action
    private readonly onCancel = (): void => {
        this.props.telemetry.information(`Payment instrument ${this.props.config.paymenTenderType ?? ''} onCancel is called.`);

        if (this.hasSelectedItem) {
            this.props.moduleState.onReady();
        } else {
            this.props.moduleState.onUpdating();
        }
    };

    // eslint-disable-next-line @typescript-eslint/member-ordering -- Keep existing order.
    @action
    private readonly onEdit = async (): Promise<void> => {
        this.props.telemetry.information(`Payment instrument ${this.props.config.paymenTenderType ?? ''} onEdit is called.`);

        this.props.moduleState.onUpdating();

        await this.props.data.checkout.result?.updateIsExpressCheckoutApplied({ newIsExpressCheckoutApplied: false });

        if (this.props.data.checkout.result?.isExpressAddressApplied) {
            await this.props.data.checkout.result.updateIsExpressAddressApplied({ newIsExpressAddressApplied: false });
        }

        // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
        this.updatePaymentAcceptPageData();
    };

    @action
    private readonly onContainerReady = (): void => {
        this.props.telemetry.information(`Payment instrument ${this.props.config.paymenTenderType ?? ''} onContainerReady is called.`);

        this.redirectToPaymentVerification();
        this.props.moduleState.setIsSubmitContainer(false);
    };

    // @action
    // // eslint-disable-next-line @typescript-eslint/no-explicit-any
    // private readonly _handleCheckoutError = (error: any): void => {
    //     const checkoutResult = this.props.data.checkout.result;

    //     this.setState({
    //         errorPaymentConnectorId: this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId
    //     });

    //     if (checkoutResult && checkoutResult.shouldEnableCheckoutErrorDisplayMessaging) {
    //         this.props.telemetry.exception(error);
    //         this.props.moduleState.setHasError(true);

    //         const errorCode = error && error.name ? error.name : '';
    //         setCheckoutErrors(errorCode, this.props.resources, !!checkoutResult.isExpressCheckoutApplied, this.props.context.actionContext);
    //     } else {
    //         this.setTerminalError(error);
    //     }
    // };

    @action
    private readonly _handleExpressCheckout = (): void => {
        this.props.telemetry.information(
            `IsExpressCheckoutApplied is updated to ${
                this.props.data.checkout.result?.isExpressCheckoutApplied
            } for payment instrument ${this.props.config.paymenTenderType ?? ''}.`
        );

        if (this.props.data.checkout.result?.isExpressCheckoutApplied && this.props.config.paymenTenderType) {
            this.props.moduleState.setHasError(false);
            this.props.moduleState.onReady();
            this.setState({
                terminalError: null,
                errorMessage: null,
                isPaymentProcessing: false,
                isExpressCheckoutApplied: true
            });
            this.props.moduleState.setIsSubmitContainer(true);
        } else {
            this.setState({ isExpressCheckoutApplied: false });
        }
    };
}

export default withVisibilityObserver(CheckoutPaymentInstrument);
