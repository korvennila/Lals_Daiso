/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { PriceComponent } from '@msdyn365-commerce/components';
import { CheckoutModule, ErrorLocation, ICheckoutState } from '@msdyn365-commerce/global-state';
import { Cart, ChannelDeliveryOptionConfiguration, FilterDeliveryModeOption } from '@msdyn365-commerce/retail-proxy';
import { getDeliveryOptionsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { Address, CartLine, DeliveryOption } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { QueryResultSettingsProxy, StringExtensions } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, Waiting } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import get from 'lodash/get';
import { action, computed, observable, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { ErrorComponent } from '@msdyn365-commerce-modules/checkout';
import { ICheckoutDeliveryOptionsData } from './checkout-delivery-options.data';
import {
    filterDeliveryModeOption,
    ICheckoutDeliveryOptionsProps,
    useDefaultDeliveryOption
} from './checkout-delivery-options.props.autogenerated';
import DescriptionComponent from './components/checkout-delivery-options.description';
import ErrorMessageComponent from './components/checkout-delivery-options.error-message';
import ErrorTitleComponent from './components/checkout-delivery-options.error-title';
import RadioButtonComponent from './components/checkout-delivery-options.radio-button';
import { focusOnCheckoutError } from '@msdyn365-commerce-modules/checkout';

export interface ICheckoutDeliveryOptionsModuleProps
    extends ICheckoutDeliveryOptionsProps<ICheckoutDeliveryOptionsData>,
        IModuleStateProps {}

export interface ICheckoutDeliveryOption {
    DeliveryOption: INodeProps;
    description?: React.ReactNode;
    price?: React.ReactNode;
}

export interface ICheckoutDeliveryOptionEdit extends ICheckoutDeliveryOption {
    code: string;
    radioButton?: React.ReactNode;
}

export interface ICheckoutDeliveryOptionsList {
    DeliveryOptionsList: INodeProps;
    list: ICheckoutDeliveryOptionEdit[];
}

export interface ICheckoutDeliveryOptionsError {
    Error: INodeProps;
    title: React.ReactNode;
    message: React.ReactNode;
}

export interface ICheckoutDeliveryOptionsViewState {
    isLoading: boolean;
    isError: boolean;
    isShowList: boolean;
    isShowSelected: boolean;
    isShowSaveButton: boolean;
    isShowEditButton: boolean;
    isShowCancelButton: boolean;
}

export interface ICheckoutDeliveryOptionsViewProps extends ICheckoutDeliveryOptionsProps<{}> {
    CheckoutDeliveryOptions: IModuleProps;
    selectedItemId: string;
    deliveryOptionsData: DeliveryOption[];
    isLoading: boolean;
    errorMessageData: string;
    viewState: ICheckoutDeliveryOptionsViewState;
    deliveryOptions?: ICheckoutDeliveryOptionsList;
    deliveryOptionSelected?: ICheckoutDeliveryOption;
    errorMessage?: ICheckoutDeliveryOptionsError;
    waiting?: React.ReactNode;
    saveButton?: React.ReactNode;
    editButton?: React.ReactNode;
    cancelButton?: React.ReactNode;
    alert?: React.ReactNode;
    checkoutErrorRef?: React.RefObject<HTMLElement>;
    onDeliveryOptionChange(event: React.ChangeEvent<HTMLInputElement>): void;
    onSave(): void;
    onEdit(): void;
    onCancel(): void;
}

/**
 *
 * CheckoutDeliveryOptions component.
 * @extends {React.Component<ICheckoutDeliveryOptionsProps<ICheckoutDeliveryOptionsData>>}
 */
// @ts-expect-error
@withModuleState
@observer
class CheckoutDeliveryOptions extends React.Component<ICheckoutDeliveryOptionsModuleProps> {
    @observable private selectedItemId: string = '';

    @observable private deliveryOptions: DeliveryOption[] = [];

    @observable private isLoading: boolean = false;

    @observable private errorMessage?: string;

    @computed private get isDataReady(): boolean {
        return (this.props.data.checkout.result && this.props.data.checkout.status) === 'SUCCESS';
    }

    public get expressPaymentDetailsFromCartPage() {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
        const properties =
            this.props.data.cart?.result?.cart?.ExtensionProperties?.find(property => property.Key === 'expressPaymentDetails')?.Value
                ?.StringValue ?? '';

        return properties ? JSON.parse(properties) : null;
    }

    public get isExpressPaymentAppliedInCartPage(): boolean {
        return this.expressPaymentDetailsFromCartPage?.isExpressCheckoutAppliedInCartPage ?? false;
    }

    private cartDeliveryMode?: string;

    private retailMultiplePickUpOptionEnabled?: boolean = false;

    private channelDeliveryOptionConfig?: ChannelDeliveryOptionConfiguration;

    private readonly telemetryContent?: ITelemetryContent;

    private readonly isSelectDefaultOptionEnabled?: boolean;

    private readonly checkoutErrorRef: React.RefObject<HTMLElement> = React.createRef();

    public constructor(props: ICheckoutDeliveryOptionsModuleProps) {
        super(props);
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        this.isSelectDefaultOptionEnabled =
            this.props.config.useDefaultDeliveryOption && this.props.config.useDefaultDeliveryOption !== useDefaultDeliveryOption.none;
    }

    public async componentDidMount(): Promise<void> {
        when(
            () => this.isDataReady,
            async () => {
                await this.init();
            }
        );

        reaction(
            () => this.props.data.checkout.result?.shippingAddress,
            async () => {
                await this.loadDeliveryOptions();
                this.props.moduleState.setIsCancellable(false);

                await this.props.data.checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
            }
        );

        reaction(
            () => this.props.data.checkout.result?.isExpressCheckoutApplied,
            async isExpressCheckoutApplied => {
                if (isExpressCheckoutApplied && this.canShip() && !this.isExpressPaymentAppliedInCartPage) {
                    await this.loadDeliveryOptions();
                    this.props.moduleState.setIsCancellable(false);

                    await this.props.data.checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
                }
            }
        );

        if (this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging) {
            reaction(
                () => this.props.data.checkout.result?.checkoutError,
                checkoutError => {
                    if (
                        checkoutError &&
                        checkoutError.errorLocation === ErrorLocation.CheckoutDeliveryOptions &&
                        checkoutError.errorMessage
                    ) {
                        this.setError(checkoutError.errorMessage);
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.checkoutErrorFocus,
                checkoutErrorFocus => {
                    if (checkoutErrorFocus === CheckoutModule.CheckoutDeliveryOptions) {
                        focusOnCheckoutError(this.checkoutErrorRef, this.props.context.actionContext);
                    }
                }
            );
        }
    }

    public shouldComponentUpdate(nextProps: ICheckoutDeliveryOptionsModuleProps, nextState: ICheckoutDeliveryOptionsViewState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        this.channelDeliveryOptionConfig = this.props.data.channelDeliveryOptionConfig?.result;
        this.retailMultiplePickUpOptionEnabled = this.props.data.featureState?.result?.find(
            feature => feature.Name === multiplePickupStoreSwitchName
        )?.IsEnabled;

        if (!this.canShip()) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }

        const {
            moduleState: { isReady, isUpdating, hasError }
        } = this.props;
        const isError = !this.isLoading && hasError;
        const isShowList = !this.isLoading && !hasError && isUpdating && !this.isSelectDefaultOptionEnabled;
        const isShowSelected = !this.isLoading && !hasError && isReady;
        const { errorMessageTitle, deliveryOptionAriaLabel } = this.props.resources;

        const viewProps = {
            ...this.props,
            onDeliveryOptionChange: this.onDeliveryOptionChange,
            selectedItemId: this.selectedItemId,
            deliveryOptionsData: this.deliveryOptions,
            isLoading: this.isLoading,
            alert: this.errorMessage && <ErrorComponent {...{ title: errorMessageTitle, message: this.errorMessage }} />,
            errorMessageData: this.errorMessage,
            viewState: {
                isLoading: this.isLoading,
                isError,
                isShowList,
                isShowSelected,
                isShowSaveButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup,
                isShowEditButton: isShowSelected && !this.props.moduleState.hasExternalSubmitGroup,
                isShowCancelButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup && !!this.getSavedDeliveryOption()
            },
            CheckoutDeliveryOptions: {
                moduleProps: this.props,
                className: classname('ms-checkout-delivery-options', this.props.config.className)
            },
            deliveryOptions: {
                DeliveryOptionsList: {
                    className: 'ms-checkout-delivery-options__list',
                    role: 'list',
                    'aria-label': deliveryOptionAriaLabel
                },
                list: this.getDeliveryOptionList()
            },
            deliveryOptionSelected: this.getDeliveryOptionSelected(),
            errorMessage: this.getErrorMessage(),
            waiting: <Waiting />,
            checkoutErrorRef: this.checkoutErrorRef,
            saveButton: this.getSaveButton(),
            editButton: this.getEditButton(),
            cancelButton: this.getCancelButton(),
            onSave: this.onSave,
            onEdit: this.onEdit,
            onCancel: this.onCancel
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    @action
    private readonly init = async (): Promise<void> => {
        this.props.moduleState.init({
            onEdit: this.isSelectDefaultOptionEnabled ? undefined : this.onEdit,
            onCancel: this.isSelectDefaultOptionEnabled ? undefined : this.onCancel,
            onSubmit: this.isSelectDefaultOptionEnabled ? undefined : this.onSubmit,
            status:
                !(this.props.config.useDefaultDeliveryOption === useDefaultDeliveryOption.notDisplaySelectedDeliveryOption) &&
                this.canShip()
                    ? 'updating'
                    : 'disabled'
        });

        this.cartDeliveryMode = this.getSavedDeliveryOption();
        await this.loadDeliveryOptions();
    };

    private readonly canShip = (): boolean => {
        const hasInvoice = this.props.data.checkout.result?.checkoutCart.hasInvoiceLine;
        return !hasInvoice && this.getCartLinesForShipping().length > 0;
    };

    private readonly isDeliveryModeExists = (deliveryMode: string | undefined): boolean => {
        if (deliveryMode) {
            if (this.deliveryOptions.find(deliveryOption => deliveryOption.Code === deliveryMode)) {
                return true;
            }
        }
        return false;
    };

    private readonly getDeliveryOptionSelected = (): ICheckoutDeliveryOption | null => {
        const selectedItem = this.deliveryOptions.find(deliveryOption => deliveryOption.Code === this.selectedItemId);
        if (!selectedItem) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }

        const { id, typeName, context } = this.props;
        const { priceFree } = this.props.resources;
        const price = get(selectedItem, 'ShippingChargeAmount', 0);
        const channelConfig = this.props.context.request.channel;
        return {
            DeliveryOption: { className: 'ms-checkout-delivery-options__option-selected' },
            description: <DescriptionComponent {...{ description: selectedItem.Description }} />,
            price: (
                <PriceComponent
                    id={id}
                    typeName={typeName}
                    context={context}
                    className='ms-checkout-delivery-options__price'
                    data={{ price: { CustomerContextualPrice: price } }}
                    freePriceText={priceFree}
                    currencyCode={channelConfig?.Currency}
                />
            )
        };
    };

    private readonly getErrorMessage = (): ICheckoutDeliveryOptionsError => {
        const { errorMessageTitle } = this.props.resources;
        return {
            // @ts-expect-error
            CheckoutDeliveryOptionsError: { tag: 'span', className: 'ms-address-form__error', role: 'alert', 'aria-live': 'assertive' },
            title: <ErrorTitleComponent {...{ title: errorMessageTitle }} />,
            message: <ErrorMessageComponent {...{ message: this.errorMessage }} />
        };
    };

    private readonly getDeliveryOptionList = (): ICheckoutDeliveryOptionEdit[] => {
        const count = this.deliveryOptions.length;
        const { priceFree } = this.props.resources;
        const { id, typeName, context } = this.props;
        const channelConfig = this.props.context.request.channel;

        return this.deliveryOptions.map((deliveryOption: DeliveryOption, index: number) => {
            return {
                DeliveryOption: { className: 'ms-checkout-delivery-options__option', role: 'listitem' },
                code: deliveryOption.Code || '',
                radioButton: (
                    <RadioButtonComponent
                        {...{
                            isChecked: deliveryOption.Code === this.selectedItemId,
                            value: deliveryOption.Code,
                            ariaSetSize: count,
                            ariaPosInSet: index + 1,
                            ariaLabel: `${deliveryOption.Description!}`,
                            onChange: this.onDeliveryOptionChange,
                            telemetryContent: this.telemetryContent
                        }}
                    />
                ),
                description: (
                    <DescriptionComponent
                        {...{
                            description: deliveryOption.Description
                        }}
                    />
                ),
                price: (
                    <PriceComponent
                        id={id}
                        typeName={typeName}
                        context={context}
                        className='ms-checkout-delivery-options__price'
                        data={{ price: { CustomerContextualPrice: get(deliveryOption, 'ShippingChargeAmount', 0) } }}
                        freePriceText={priceFree}
                        currencyCode={channelConfig?.Currency}
                    />
                )
            };
        });
    };

    private readonly getSaveButton = (): React.ReactNode => {
        const { saveBtnLabel = 'Save' } = this.props.resources;
        return (
            <Button
                className='ms-checkout-delivery-options__btn-save'
                title={saveBtnLabel}
                color='primary'
                disabled={!this.selectedItemId}
                onClick={this.onSave}
            >
                {saveBtnLabel}
            </Button>
        );
    };

    private readonly getEditButton = (): React.ReactNode => {
        const { editBtnLabel = 'Change' } = this.props.resources;
        return (
            <Button className='ms-checkout-delivery-options__btn-edit' title={editBtnLabel} color='primary' onClick={this.onEdit}>
                {editBtnLabel}
            </Button>
        );
    };

    private readonly getCancelButton = (): React.ReactNode => {
        const { cancelBtnLabel = 'Cancel' } = this.props.resources;
        return (
            <Button className='ms-checkout-delivery-options__btn-cancel' title={cancelBtnLabel} color='secondary' onClick={this.onCancel}>
                {cancelBtnLabel}
            </Button>
        );
    };

    private readonly setError = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.errorMessage = errorMessage;
    };

    private readonly clearError = (): void => {
        this.props.moduleState.setHasError(false);
        this.errorMessage = undefined;
    };

    private readonly onSave = async (): Promise<void> => {
        await this.onSubmit();
    };

    private readonly onEdit = async (): Promise<void> => {
        this.props.telemetry.information('Delivery options onEdit is called.');

        this.clearError();
        this.onUpdating();
        await this.props.data.checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
    };

    private readonly onSubmit = async (): Promise<void> => {
        this.props.telemetry.information('Delivery options onSubmit is called.');

        await this.updateCartDeliverySpecification(this.selectedItemId);
        await this.props.data.checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
    };

    private readonly onCancel = async (): Promise<void> => {
        this.props.telemetry.information('Delivery options onCancel is called.');

        // Reset to the saved value
        const savedDeliveryOption = this.getSavedDeliveryOption();
        if (savedDeliveryOption) {
            this.selectedItemId = savedDeliveryOption;
            this.onReady();

            await this.props.data.checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
        } else {
            this.onUpdating();
        }
    };

    private readonly getSavedDeliveryOption = (): string | undefined => {
        const cartLinesForShipping = this.getCartLinesForShipping();
        return cartLinesForShipping[0] && cartLinesForShipping[0].DeliveryMode;
    };

    private readonly updateCartDeliverySpecification = async (deliveryModeId: string): Promise<void> => {
        if (deliveryModeId.trim() === '') {
            return;
        }

        const { resources } = this.props;
        const checkoutState = this.props.data.checkout.result as ICheckoutState;
        const updateCartDeliverySpecificationInput = {
            deliveryModeId,
            shippingAddress: checkoutState.shippingAddress,
            channelDeliveryOptionConfig: this.retailMultiplePickUpOptionEnabled ? this.channelDeliveryOptionConfig : undefined
        };

        this.clearError();
        this.onPending();

        await checkoutState.checkoutCart
            .updateCartDeliverySpecification(updateCartDeliverySpecificationInput)
            .then(response => {
                if (response.status === 'FAILED') {
                    const errorMessage = `${response.errorDetails?.LocalizedMessage}`;
                    this.setError(StringExtensions.isNullOrEmpty(errorMessage) ? resources.genericErrorMessage : errorMessage);
                }

                this.onReady();
                this.props.moduleState.setIsCancellable(true);
            })
            .catch(() => {
                this.setError(resources.genericErrorMessage);
            });
    };

    private readonly getCartLinesForShipping = (): CartLine[] => {
        const { request } = this.props.context;
        const pickupDeliveryModeCode = request && request.channel && request.channel.PickupDeliveryModeCode;
        const emailDeliveryModeCode = request && request.channel && request.channel.EmailDeliveryModeCode;

        return this.retailMultiplePickUpOptionEnabled
            ? ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).filter(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !==
                            this.channelDeliveryOptionConfig?.PickupDeliveryModeCodes?.find(
                                deliveryMode => deliveryMode === cartLine.DeliveryMode
                            ) && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              )
            : ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).filter(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              );
    };

    private readonly getDeliveryOptions = async (shippingAddress: Address): Promise<void> => {
        if (!this.props.data.checkout.result) {
            return;
        }

        const { context, resources, config } = this.props;
        const cartState = this.props.data.checkout.result?.checkoutCart;
        const cartId = (cartState.cart as Cart).Id;

        if (context) {
            this.isLoading = true;
            this.deliveryOptions = [];
            this.selectedItemId = '';
            this.clearError();

            try {
                let originalDeliveryMode: string = '';
                const shippingCartLines = this.getCartLinesForShipping();
                const hasShippingDeliveryLines = shippingCartLines && shippingCartLines.length > 0 && shippingCartLines[0].DeliveryMode;
                if (hasShippingDeliveryLines) {
                    // First store the delivery mode, so that we can restore the shipping information.
                    originalDeliveryMode = shippingCartLines[0].DeliveryMode || '';

                    // Clear the delivery information on retail server, so GetDeliveryOptions charge calculation works correctly
                    const cart = cartState.cart;
                    await cartState.clearCartLinesDeliveryInformation({
                        cart,
                        channelDeliveryOptionConfiguration: this.channelDeliveryOptionConfig
                    });
                }

                // TODO: Check if we can move this getDeliveryOptions to checkout state
                let deliveryOptionFilter: FilterDeliveryModeOption;
                switch (config.filterDeliveryModeOption) {
                    case filterDeliveryModeOption.none:
                        deliveryOptionFilter = FilterDeliveryModeOption.None;
                        break;
                    case filterDeliveryModeOption.filterOutNonCarrierDeliveryMode:
                        deliveryOptionFilter = FilterDeliveryModeOption.FilterOutNonCarrierDeliveryMode;
                        break;
                    default:
                        deliveryOptionFilter = FilterDeliveryModeOption.FilterOutNonCarrierDeliveryMode;
                }
                const response = await getDeliveryOptionsAsync(
                    {
                        callerContext: context.actionContext,
                        queryResultSettings: QueryResultSettingsProxy.getPagingFromInputDataOrDefaultValue(context.actionContext)
                    },
                    cartId,
                    shippingAddress,
                    [],
                    deliveryOptionFilter,
                    true
                );

                if (hasShippingDeliveryLines) {
                    await this.updateCartDeliverySpecification(originalDeliveryMode);
                }

                if (response && response.length > 0) {
                    this.deliveryOptions = response;
                }
            } catch {
                this.setError(resources.genericErrorMessage);
            }

            if (this.deliveryOptions.length === 0) {
                this.setError(resources.deliveryOptionsNotFound);
            } else if (this.cartDeliveryMode && this.isDeliveryModeExists(this.cartDeliveryMode)) {
                this.selectedItemId = this.cartDeliveryMode;
                this.cartDeliveryMode = undefined;
                this.onReady();

                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
                this.props.data.checkout.result?.updateHasCartDeliveryMode({ newHasCartDeliveryMode: true });

                if (!this.props.data.checkout.result?.isPaymentVerificationRedirection) {
                    await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
                }
            } else {
                this.onUpdating();
                this.selectedItemId = this.deliveryOptions.length > 0 ? this.deliveryOptions[0].Code || '' : ''; // By default, select first delivery

                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
                this.props.data.checkout.result?.updateHasCartDeliveryMode({ newHasCartDeliveryMode: !!this.isSelectDefaultOptionEnabled });
            }

            this.isLoading = false;
        }
    };

    private readonly getStoredDeliveryOptions = async (): Promise<void> => {
        if (!this.props.data.checkout.result) {
            return;
        }

        const { context } = this.props;
        const cartState = this.props.data.checkout.result.checkoutCart;

        if (context) {
            this.isLoading = true;
            this.deliveryOptions = [];
            this.selectedItemId = '';
            this.clearError();

            let originalDeliveryMode: string = '';
            const shippingCartLines = this.getCartLinesForShipping();
            const hasShippingDeliveryLines = shippingCartLines && shippingCartLines.length > 0 && shippingCartLines[0].DeliveryMode;
            if (hasShippingDeliveryLines) {
                // First store the delivery mode, so that we can restore the shipping information.
                originalDeliveryMode = shippingCartLines[0].DeliveryMode || '';

                // Clear the delivery information on retail server, so GetDeliveryOptions charge calculation works correctly
                const cart = cartState.cart;
                await cartState.clearCartLinesDeliveryInformation({
                    cart,
                    channelDeliveryOptionConfiguration: this.channelDeliveryOptionConfig
                });
                if (hasShippingDeliveryLines) {
                    await this.updateCartDeliverySpecification(originalDeliveryMode);
                }
            }

            if (this.cartDeliveryMode) {
                this.selectedItemId = this.cartDeliveryMode;
                this.cartDeliveryMode = undefined;
                this.onReady();

                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
                this.props.data.checkout.result?.updateHasCartDeliveryMode({ newHasCartDeliveryMode: true });

                if (!this.props.data.checkout.result.isPaymentVerificationRedirection) {
                    await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
                }
            }

            this.isLoading = false;
        }
    };

    private readonly loadDeliveryOptions = async (): Promise<void> => {
        const shippingAddress = this.props.data.checkout.result?.shippingAddress;

        if (this.canShip() && shippingAddress) {
            if (
                !this.props.data.checkout.result?.isPaymentVerificationRedirection ||
                this.isSelectDefaultOptionEnabled ||
                this.props.data.checkout.result?.isExpressCheckoutApplied
            ) {
                await this.getDeliveryOptions(shippingAddress);
            }

            if (this.props.data.checkout.result?.isPaymentVerificationRedirection) {
                await this.getStoredDeliveryOptions();
            }

            if (
                this.isSelectDefaultOptionEnabled ||
                this.props.data.checkout.result?.isExpressCheckoutApplied ||
                this.isExpressPaymentAppliedInCartPage
            ) {
                this.onSubmit();
            }
        }
    };

    private readonly onDeliveryOptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const deliveryModeId = event.currentTarget.value;
        this.selectedItemId = deliveryModeId;
    };

    private readonly onReady = () => {
        if (!(this.props.config.useDefaultDeliveryOption === useDefaultDeliveryOption.notDisplaySelectedDeliveryOption)) {
            this.props.moduleState.onReady();
        }
    };

    private readonly onUpdating = () => {
        if (!(this.props.config.useDefaultDeliveryOption === useDefaultDeliveryOption.notDisplaySelectedDeliveryOption)) {
            this.props.moduleState.onUpdating();
        }
    };

    private readonly onPending = () => {
        if (!this.isSelectDefaultOptionEnabled) {
            this.props.moduleState.onPending();
        }
    };
}

export default CheckoutDeliveryOptions;
