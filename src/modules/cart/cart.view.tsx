/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { IInvoiceSummaryLines } from '@msdyn365-commerce-modules/invoice-payment-summary';
import { IOrderSummaryLines } from '@msdyn365-commerce-modules/order-summary-utilities';
import { ArrayExtensions, StringExtensions } from '@msdyn365-commerce-modules/retail-actions';
import { ICartViewProps, IOrderSummaryErrors } from './cart';
import { ICartlinesViewProps } from './components/cart-line-items';
import { ICartLineItemViewProps } from './components/cart-line-items-promotion';
import {
    Button,
    getPayloadObject,
    getTelemetryAttributes,
    INodeProps,
    ITelemetryContent,
    Node,
    TelemetryConstant
} from '@msdyn365-commerce-modules/utilities';
import * as React from 'react';
import { ICartProps as ICartExtensionProps, ICartResources } from './cart.props.autogenerated';

/**
 * Toggle Bopis Function.
 * @param cartLine -CartLine.
 * @param isBopisSelected -Boolean.
 * @returns Toggle Bopis.
 */
const toggleBopisHandler = (cartLine: ICartlinesViewProps, isBopisSelected: boolean) => () => {
    cartLine.pickUpInStore?.callbacks.toggleBopis(!isBopisSelected);
};

/**
 * Change Store Function.
 * @param cartLine -CartLine.
 * @returns Toggle Bopis.
 */
const onChangeStoreHandler = (cartLine: ICartlinesViewProps) => () => {
    cartLine.pickUpInStore?.callbacks.toggleBopis(true);
};

/**
 * Render Bopis block.
 * @param cartLine - The cart line view props.
 * @param resources - Module resource strings.
 * @param storeSelector - Store selector element.
 * @param telemetryContent - The telemetry object.
 * @param emailDeliveryModeCode - The email delivery mode code.
 * @returns JSX Element.
 */
const renderBopisBlock = (
    cartLine: ICartlinesViewProps,
    resources: ICartResources,
    storeSelector: React.ReactNode | undefined,
    telemetryContent?: ITelemetryContent,
    emailDeliveryModeCode?: string
): JSX.Element | null => {
    // If it is electronic item cart line, then return null for BOPISBlock.
    if (!cartLine.pickUpInStore || !storeSelector || cartLine.data?.cartline.DeliveryMode === emailDeliveryModeCode) {
        return null;
    }

    const {
        shipInsteadDisplayText,
        shipToAddressDisplayText,
        pickItUpDisplayText,
        pickUpAtStoreWithLocationText,
        changeStoreDisplayText
    } = resources;

    const isBopisSelected = cartLine.pickUpInStore.isBopisSelected;

    const payLoad = getPayloadObject('click', telemetryContent!, TelemetryConstant.PickupInStore);
    const puckUpinStoreAttribute = getTelemetryAttributes(telemetryContent!, payLoad);

    return (
        <Node {...cartLine.pickUpInStore.ContainerProps}>
            <div className='msc-cart-line__bopis-method'>
                {isBopisSelected ? (
                    <span className='pick-up'>{pickUpAtStoreWithLocationText}</span>
                ) : (
                    <span className='ship'>{shipToAddressDisplayText}</span>
                )}
            </div>
            {isBopisSelected && (
                <div className='msc-cart-line__bopis-fullfilment'>
                    <span className='msc-cart-line__bopis-fullfilment-store'>{cartLine.pickUpInStore.orgUnitName}</span>
                    <Button role='link' className='msc-cart-line__bopis-changestore' onClick={onChangeStoreHandler(cartLine)}>
                        {changeStoreDisplayText}
                    </Button>
                </div>
            )}
            <Button
                className='msc-cart-line__bopis-btn'
                {...puckUpinStoreAttribute}
                onClick={toggleBopisHandler(cartLine, isBopisSelected)}
            >
                {isBopisSelected ? shipInsteadDisplayText : pickItUpDisplayText}
            </Button>
        </Node>
    );
};

/**
 * Render Bopis block.
 * @param cartLine - The cart line view props.
 * @param resources - Module resource strings.
 * @param storeSelector - Store selector element.
 * @param telemetryContent - The telemetry object.
 * @param emailDeliveryModeCode - The email delivery mode code.
 * @returns JSX Element.
 */
const renderGroupBopisBlock = (
    cartLine: ICartlinesViewProps,
    resources: ICartResources,
    storeSelector: React.ReactNode | undefined,
    telemetryContent?: ITelemetryContent,
    emailDeliveryModeCode?: string
): JSX.Element | null => {
    // If it is electronic item cart line, then return null for GroupBOPISBlock.
    if (!cartLine.pickUpInStore || !storeSelector || cartLine.data?.cartline.DeliveryMode === emailDeliveryModeCode) {
        return null;
    }

    const { changeStoreDisplayText, shipInsteadDisplayText, pickItUpDisplayText } = resources;

    const isBopisSelected = cartLine.pickUpInStore.isBopisSelected;

    const payLoad = getPayloadObject('click', telemetryContent!, TelemetryConstant.PickupInStore);
    const puckUpinStoreAttribute = getTelemetryAttributes(telemetryContent!, payLoad);

    return (
        <>
            {isBopisSelected ? (
                <Button role='link' className='msc-cart-line__remove-item msc-btn' onClick={onChangeStoreHandler(cartLine)}>
                    {changeStoreDisplayText}
                </Button>
            ) : null}
            <Button
                role='link'
                className='msc-cart-line__remove-item msc-btn'
                {...puckUpinStoreAttribute}
                onClick={toggleBopisHandler(cartLine, isBopisSelected)}
            >
                {isBopisSelected ? shipInsteadDisplayText : pickItUpDisplayText}
            </Button>
        </>
    );
};

/**
 * Render Cart Lines.
 * @param cartLine - The cart line view props.
 * @param resources - Module resource strings.
 * @param storeSelector - Store selector element.
 * @param telemetryContent - The telemetry object.
 * @param isMultiplePickUp - FLag to check if there multiple pickups.
 * @param emailDeliveryModeCode - The email delivery mode code.
 * @returns JSX Element.
 */
const renderCartLine = (
    cartLine: ICartlinesViewProps,
    resources: ICartResources,
    storeSelector: React.ReactNode | undefined,
    telemetryContent?: ITelemetryContent,
    isMultiplePickUp?: boolean,
    emailDeliveryModeCode?: string
): JSX.Element => {
    if (cartLine.error === resources.outOfStockErrorMessage) {
        return (
            <Node className='msc-cart-line__actions'>
                {cartLine.addToWishlist}
                {cartLine.remove}
            </Node>
        );
    }

    if (isMultiplePickUp) {
        return (
            <Node className='msc-cart-line-group__extra-actions'>
                {renderGroupBopisBlock(cartLine, resources, storeSelector, telemetryContent, emailDeliveryModeCode)}
                {cartLine.addToOrderTemplate}
                {cartLine.addToWishlist}
                {cartLine.remove}
            </Node>
        );
    }

    if (cartLine.addToOrderTemplate) {
        return (
            <Node className='msc-cart-line__extra-actions'>
                {cartLine.addToOrderTemplate}
                {cartLine.addToWishlist}
                {cartLine.remove}
            </Node>
        );
    }

    return (
        <Node className='msc-cart-line__actions'>
            {cartLine.addToWishlist}
            {cartLine.remove}
        </Node>
    );
};

/**
 * Render Cart Lines.
 * @param cartLines - The cart line view props.
 * @param resources - Module resource strings.
 * @param storeSelector - Store selector element.
 * @param telemetryContent - The telemetry object.
 * @param isMultiplePickUp - Flag to check if there multiple pickups.
 * @param emailDeliveryModeCode - The email delivery mode code.
 * @returns JSX Element.
 */
const renderCartlinesInternal = (
    cartLines: ICartlinesViewProps[],
    resources: ICartResources,
    storeSelector: React.ReactNode | undefined,
    telemetryContent?: ITelemetryContent,
    isMultiplePickUp?: boolean,
    emailDeliveryModeCode?: string
): JSX.Element[] | JSX.Element => {
    return cartLines.map((cartLine, index) => {
        const itemIndex = index;
        return (
            <div className='msc-cart-lines-item' key={itemIndex}>
                {cartLine.cartline}
                <span className='msc-cart-lines-button-container'>
                    {isMultiplePickUp
                        ? null
                        : renderBopisBlock(cartLine, resources, storeSelector, telemetryContent, emailDeliveryModeCode)}
                    {renderCartLine(cartLine, resources, storeSelector, telemetryContent, isMultiplePickUp, emailDeliveryModeCode)}
                </span>
            </div>
        );
    });
};

/**
 * Render Cart Lines.
 * @param props - The cart line props.
 * @param cartLines - The cart line view props.
 * @param resources - Module resource strings.
 * @param storeSelector - Store selector element.
 * @param waitingComponent - Waiting component element.
 * @param cartLoadingStatus - Cart loading status string.
 * @param isCartDataResult - Flag to check if there is cart data.
 * @param telemetryContent - The telemetry object.
 * @param isMultiplePickUp - Flag to check if there multiple pickups.
 * @param emailDeliveryModeCode - The email delivery mode code.
 * @returns JSX Element.
 */
const renderCartlines = (
    props: ICartViewProps & ICartExtensionProps<{}>,
    cartLines: ICartlinesViewProps[] | undefined,
    resources: ICartResources,
    storeSelector: React.ReactNode | undefined,
    waitingComponent: React.ReactNode,
    cartLoadingStatus: string,
    isCartDataResult: boolean,
    telemetryContent?: ITelemetryContent,
    isMultiplePickUp?: boolean,
    emailDeliveryModeCode?: string
): JSX.Element[] | JSX.Element => {
    if (cartLoadingStatus) {
        return <>{cartLoadingStatus}</>;
    }

    // Props.CartlinesWrapper is only required on cart lines and when multiple pickup mode is disabled. This is also required to handle the empty cart styling.
    // Else, empty cart multiple pickup mode is disabled falls under the other cart line wrapper which is creating issue with Empty cart scenario.
    if (cartLines) {
        return props.multiplePickUpEnabled ? (
            renderCartlinesInternal(cartLines, resources, storeSelector, telemetryContent, isMultiplePickUp, emailDeliveryModeCode)
        ) : (
            <Node {...props.CartlinesWrapper}>
                {renderCartlinesInternal(cartLines, resources, storeSelector, telemetryContent, isMultiplePickUp, emailDeliveryModeCode)}
            </Node>
        );
    }

    return isCartDataResult ? (
        <div className='msc-cart__empty-cart'>
            <div className='msc-cart-line'>{props.slots.emptyCart}</div>
        </div>
    ) : (
        <>{waitingComponent}</>
    );
};

/**
 * Render Cart Lines group title.
 * @param cartLine - The cart line view props.
 * @param resources - Module resource strings.
 * @param count - Count of products.
 * @returns JSX Element.
 */
const renderCartLinesGroupTitle = (cartLine: ICartlinesViewProps, resources: ICartResources, count: number) => {
    const isBopisSelected = cartLine.pickUpInStore?.isBopisSelected;
    const { itemLabel, itemsLabel } = resources;
    const itemCountOne: number = 1;
    const suffix = count > itemCountOne ? itemsLabel : itemLabel;
    const countTitle = `(${count} ${suffix})`;
    return (
        <>
            <Node className='msc-cart-lines-group-wrapper__bopis-heading-title'>
                {isBopisSelected ? (
                    <p className='msc-cart-lines-group-wrapper__bopis-heading-title-st'>
                        {cartLine.pickUpInStore?.deliveryOption}
                        {', '}
                        {cartLine.pickUpInStore?.orgUnitName}
                    </p>
                ) : null}
                <p className='msc-cart-lines-group-wrapper__bopis-heading-title-ct'>{countTitle}</p>
            </Node>
        </>
    );
};

/**
 * Render Cart Lines group title.
 * @param cartLine - The cart line view props.
 * @param resources - Module resource strings.
 * @param count - Count of products.
 * @param emailDeliveryModeCode - The email delivery mode code.
 * @returns JSX Element.
 */
const renderCartLinesGroupHeader = (
    cartLine: ICartlinesViewProps,
    resources: ICartResources,
    count: number,
    emailDeliveryModeCode?: string
) => {
    const isBopisSelected = cartLine.pickUpInStore?.isBopisSelected;
    const { pickUpText, shippingText, emailshippingText, payInvoicesDisplayText } = resources;
    let groupTitle: string;

    groupTitle = isBopisSelected ? pickUpText : shippingText;
    if (cartLine.data && cartLine.data.cartline.IsInvoiceLine) {
        groupTitle = payInvoicesDisplayText;
    } else if (!StringExtensions.isNullOrEmpty(emailDeliveryModeCode)) {
        groupTitle = cartLine.data && cartLine.data.cartline.DeliveryMode === emailDeliveryModeCode ? emailshippingText : groupTitle;
    }

    return (
        <>
            <div className='msc-cart-lines-group-wrapper__bopis-heading'>
                <p className={`msc-cart-lines-group-wrapper__bopis-heading-${groupTitle.toLowerCase().replace(' ', '-')}-icon`} />
                <p className={`msc-cart-lines-group-wrapper__bopis-heading-${groupTitle.toLowerCase().replace(' ', '-')}`}>{groupTitle}</p>
                {renderCartLinesGroupTitle(cartLine, resources, count)}
            </div>
        </>
    );
};

/**
 * Returns count of products.
 * @param cartLine - The cart line view props.
 * @returns Number of products.
 */
const countItems = (cartLine: ICartlinesViewProps[]): number => {
    let countItem = 0;
    const defaultItemCount = 0;
    countItem = cartLine.reduce((count, item) => {
        return count + (item.data?.cartline.Quantity ?? defaultItemCount);
    }, defaultItemCount);
    return countItem;
};

/**
 * Render Cart Lines group.
 * @param props - The cart line view props.
 * @param resources - Module resource strings.
 * @returns JSX Element.
 */
const renderCartLinesGroup = (props: ICartViewProps & ICartExtensionProps<{}>, resources: ICartResources): JSX.Element | undefined => {
    if (props.cartLinesGroup && ArrayExtensions.hasElements(props.cartLinesGroup)) {
        return (
            <div className='msc-cart-lines-group'>
                {props.cartLinesGroup.map(cartlines => {
                    return (
                        <div key={cartlines[0].cartlineId} className='msc-cart-lines-group-wraper'>
                            {renderCartLinesGroupHeader(
                                cartlines[0],
                                resources,
                                countItems(cartlines),
                                props.context.actionContext.requestContext.channel?.EmailDeliveryModeCode
                            )}
                            {renderCartlines(
                                props,
                                cartlines,
                                props.resources,
                                props.storeSelector,
                                props.waitingComponent,
                                props.cartLoadingStatus,
                                props.cartDataResult,
                                props.telemetryContent,
                                props.multiplePickUpEnabled,
                                props.context.actionContext.requestContext.channel?.EmailDeliveryModeCode
                            )}
                        </div>
                    );
                })}
            </div>
        );
    }
    return props.cartDataResult ? (
        <div className='msc-cart__empty-cart'>
            <div className='msc-cart-line'>{props.slots.emptyCart}</div>
        </div>
    ) : (
        <>{props.waitingComponent}</>
    );
};

/**
 * Render error block.
 * @param errorData - Error component.
 * @returns JSX Element.
 */
const renderErrorBlock = (errorData: IOrderSummaryErrors | undefined): JSX.Element | null => {
    if (!errorData || !ArrayExtensions.hasElements(errorData.errors)) {
        return null;
    }
    return (
        <Node {...errorData.Wrapper}>
            {errorData.header}
            {errorData.errors}
        </Node>
    );
};

/**
 * Render invoice summary.
 * @param invoiceSummaryLines - Invoice summary component.
 * @param orderSummaryItems - Order summary component.
 * @param props - The module props.
 * @returns JSX Element.
 */
const renderInvoiceSummarylines = (
    invoiceSummaryLines: IInvoiceSummaryLines | undefined,
    orderSummaryItems: INodeProps,
    props: ICartViewProps
): JSX.Element | null => {
    if (!invoiceSummaryLines) {
        props.context.telemetry.error('InvoiceSummary content is empty, module wont render');
        return null;
    }
    return (
        <Node {...orderSummaryItems}>
            {invoiceSummaryLines.invoices}
            {invoiceSummaryLines.giftCard}
            {invoiceSummaryLines.loyalty}
            {invoiceSummaryLines.orderTotal}
        </Node>
    );
};

/**
 * Render order summary.
 * @param orderSummaryLines - Order summary component.
 * @param orderSummaryItems - Order summary items component.
 * @param props - The module props.
 * @returns JSX Element.
 */
const renderOrderSummarylines = (
    orderSummaryLines: IOrderSummaryLines | undefined,
    orderSummaryItems: INodeProps,
    props: ICartViewProps
): JSX.Element | null => {
    if (!orderSummaryLines) {
        props.context.telemetry.error('OrderSummary content is empty, module wont render');
        return null;
    }
    return (
        <Node {...orderSummaryItems}>
            {orderSummaryLines.subtotal}
            {orderSummaryLines.totalDiscounts ? orderSummaryLines.totalDiscounts : null}
            {orderSummaryLines.shipping}
            {orderSummaryLines.otherCharge}
            {orderSummaryLines.tax}
            {orderSummaryLines.orderTotal}
        </Node>
    );
};

/**
 * Render error block.
 * @param promotions - The module view props.
 * @returns JSX Element.
 */
const renderPromotions = (promotions: ICartLineItemViewProps): JSX.Element | undefined => {
    return (
        <>
            <Node {...promotions.promotionMessageWrapper}>
                {promotions.promotionMessage}
                <Node className='msc-cart__promotion_link-section'>{promotions.promotionSeeAllLink}</Node>
                {promotions.promotionDialog}
            </Node>
        </>
    );
};

/**
 * Render order summary checkout.
 * @param props - The module view props.
 * @returns JSX Element.
 */
const renderOrderSummaryCheckout = (props: ICartViewProps): JSX.Element | undefined => {
    return (
        <Node className='msc-order-summary__checkout'>
            {props.cart?.hasInvoiceLine ? null : props.promoCode}
            <Node className='msc-order-summary__checkout__action'>
                {props.checkoutAsSignInUserButton}
                {props.checkoutAsGuestButton}
                {props.expressCheckoutButton && ArrayExtensions.hasElements(props.expressCheckoutButton) ? (
                    <Node {...props.ExpressCheckoutSectionWrapper}>{props.expressCheckoutButton}</Node>
                ) : null}
            </Node>
            {props.createTemplateFromCartButton}
        </Node>
    );
};

/**
 * Render order summary checkout button.
 * @param props - The module view props.
 * @returns JSX Element.
 */
const renderOrderSummaryCheckoutButton = (props: ICartViewProps): JSX.Element | undefined => {
    return (
        <Node className='msc-order-summary__checkout-button'>
            {props.checkoutAsSignInUserButton}
            {props.checkoutAsGuestButton}
        </Node>
    );
};

/**
 * Render cart view.
 * @param props - The module view props.
 * @returns JSX Element.
 */
const CartView: React.FC<ICartViewProps & ICartExtensionProps<{}>> = (props: ICartViewProps & ICartExtensionProps<{}>) => {
    const totalItemCountOne: number = 1;
    const updatedTitle = (
        <h1 className='msc-cart__heading'>
            {props.resources.cartTitle}
            <span className='msc-cart__heading-count-items'>
                {` (${Number(props.cart?.totalItemsInCart)} ${props.cart?.totalItemsInCart !== totalItemCountOne ? 'items' : 'item'})`}
            </span>
        </h1>
    );
    return (
        <>
            <div className='msc-cart__free-shipping-container'>
                {!props.cartDataResult && (
                    <Node className='msc-cart__free-shipping-info'>
                        <h1>{props.freeShippingContent}</h1>
                    </Node>
                )}
            </div>
            <div className={props.className} id={props.id} {...props.renderModuleAttributes(props)}>
                {props.checkoutBlockedDueToUnavailableFunds}
                {updatedTitle}
                <div className='ms-cart__estimated-total'>{props.orderSummaryLineitems?.orderTotal}</div>
                {renderOrderSummaryCheckoutButton(props)}
                {!props.cart?.hasInvoiceLine && props.promotionOptions && renderPromotions(props.promotionOptions)}
                {props.cart?.hasInvoiceLine || props.multiplePickUpEnabled
                    ? renderCartLinesGroup(props, props.resources)
                    : renderCartlines(
                          props,
                          props.cartlines,
                          props.resources,
                          props.storeSelector,
                          props.waitingComponent,
                          props.cartLoadingStatus,
                          props.cartDataResult
                      )}
                {props.orderSummaryHeading && (
                    <Node {...props.OrderSummaryWrapper}>
                        <Node className='msc-order-summary__items'>
                            {props.orderSummaryHeading}
                            {props.cart?.hasInvoiceLine
                                ? renderInvoiceSummarylines(props.invoiceSummaryLineitems, props.OrderSummaryItems, props)
                                : renderOrderSummarylines(props.orderSummaryLineitems, props.OrderSummaryItems, props)}
                            {renderErrorBlock(props.OrderSummaryErrors)}
                        </Node>
                        {renderOrderSummaryCheckout(props)}
                    </Node>
                )}
                {props.storeSelector}
            </div>
        </>
    );
};

export default CartView;
