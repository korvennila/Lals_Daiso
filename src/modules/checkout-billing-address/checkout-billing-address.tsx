/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/// <reference types="bingmaps" />

/* eslint-disable no-duplicate-imports */
import * as Msdyn365 from '@msdyn365-commerce/core';
import { CheckoutModule, ErrorLocation, IGiftCardExtend } from '@msdyn365-commerce/global-state';
import { Address, AddressPurpose, CountryRegionInfo, StateProvinceInfo } from '@msdyn365-commerce/retail-proxy';
import { IModuleStateProps, withModuleState, EnabledPaymentsForOBO } from '@msdyn365-commerce-modules/checkout-utilities';
import { getTelemetryObject, IModuleProps, ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { action, computed, observable, reaction, set } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { AutoSuggest } from '@msdyn365-commerce-modules/address';
import { IAutoSuggestOptions } from '@msdyn365-commerce-modules/address';
import { AddressCommon } from '@msdyn365-commerce-modules/address';
import { AddressFormat } from '@msdyn365-commerce-modules/address';
import { AddressItemType } from '@msdyn365-commerce-modules/address';
import { AddressMetaData } from '@msdyn365-commerce-modules/address';
import { AddressOperation, AddressType, IAddressResource, IAddressResponse } from '@msdyn365-commerce-modules/address';
import { AddressAddUpdate, IAddressAddUpdateProps } from '@msdyn365-commerce-modules/address';
import { AddressBillingCheckbox } from '@msdyn365-commerce-modules/address';
import { AddressBillingHeading } from '@msdyn365-commerce-modules/address';
import { AddressShow, IAddressShowProps } from '@msdyn365-commerce-modules/address';
import { ICheckoutBillingAddressData } from './checkout-billing-address.data';
import { ICheckoutBillingAddressProps, ICheckoutBillingAddressResources } from './checkout-billing-address.props.autogenerated';
import { ErrorComponent } from '@msdyn365-commerce-modules/address';
import { focusOnCheckoutError } from '@msdyn365-commerce-modules/address';

/**
 * Props interface.
 */
export interface IProps extends ICheckoutBillingAddressProps<ICheckoutBillingAddressData>, IModuleStateProps {}

/**
 * Checkout billing address view state interface.
 */
export interface ICheckoutBillingAddressViewState {
    isShowAddress: boolean;
    isShowAddOrUpdateAddress: boolean;
    isShowSameAsShippingCheckbox: boolean;
    errorMessage?: string;
}

/**
 * Checkout billing address view props interface.
 */
export interface ICheckoutBillingAddressViewProps extends IProps {
    className: string;
    currentOperation: AddressOperation;
    selectedAddress?: Address;
    addUpdateAddress: Address;
    countryRegionId: string;
    stateProvinceInfo?: StateProvinceInfo[];
    validationError: object;
    addressActionResponse?: IAddressResponse;
    viewState: ICheckoutBillingAddressViewState;
    CheckoutBillingAddress: IModuleProps;
    sameAsShippingCheckbox: React.ReactNode;
    heading: React.ReactNode;
    showAddress: IAddressShowProps;
    showAddOrUpdateAddress: IAddressAddUpdateProps;
    alert?: React.ReactNode;
    checkoutErrorRef?: React.RefObject<HTMLElement>;
}

/**
 *
 * CheckoutBillingAddress component.
 * @extends {React.PureComponent<ICheckoutBillingAddressProps<ICheckoutBillingAddressData>>}
 */
// @ts-expect-error
@withModuleState
@observer
class CheckoutBillingAddress extends React.Component<IProps, ICheckoutBillingAddressViewState> {
    @observable private currentOperation: AddressOperation;

    @observable private isBillingAddressSameAsShipping: boolean;

    @observable private selectedAddress?: Address;

    @observable private addUpdateAddress: Address;

    @observable private countryRegionId: string = 'USA';

    @observable private stateProvinceInfo?: StateProvinceInfo[];

    @observable private validationError: object;

    @observable private readonly addressActionResponse?: IAddressResponse;

    private readonly addressCommon: AddressCommon;

    private addressFormat: AddressFormat;

    private countryRegions: CountryRegionInfo[] = [];

    private addressPurposes: AddressPurpose[] = [];

    private readonly resources: IAddressResource;

    private readonly defaultAddressType: number = 6; // Default to Home

    // private addRenderRef: React.RefObject<AddressAdd>;
    private readonly telemetryContent?: ITelemetryContent;

    private autoSuggest?: AutoSuggest;

    private readonly checkoutErrorRef: React.RefObject<HTMLElement> = React.createRef();

    public constructor(props: IProps) {
        super(props);
        const { context, data, resources, telemetry } = this.props;

        this.addUpdateAddress = {};
        this.validationError = {};
        this.isBillingAddressSameAsShipping = false;
        this.resources = resources;
        this.currentOperation = AddressOperation.List;
        this.addressPurposes = data.addressPurposes.result || [];
        this.countryRegions = data.countryRegions.result?.filter(country => country.CountryRegionId === 'ARE') || [];
        this.stateProvinceInfo = data.countryStates.result || [];
        this.addressCommon = new AddressCommon(context, resources, telemetry);
        // this.addressFormat = new AddressFormat(
        //     this.countryRegions,
        //     new AddressMetaData({ ...resources }, this._getAddressFormatExcludeList()),
        //     this.addressPurposes
        // );

        //modified
        this.addressFormat = new AddressFormat(
            this.countryRegions,
            this._getAddressMetaData(resources),
            //new AddressMetaData({ ...resources }, this._getAddressFormatExcludeList(), this._getAddressFormatIncludeList()),
            this.addressPurposes
        );
        //modified end
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );

        this.state = {
            isShowAddress: false,
            isShowAddOrUpdateAddress: false,
            isShowSameAsShippingCheckbox: false,
            errorMessage: ''
        };

        // This.addRenderRef = React.createRef();
    }
    private _getAddressMetaData(resources: ICheckoutBillingAddressResources): AddressMetaData {
        const addressMetadata = new AddressMetaData(
            { ...resources },
            this._getAddressFormatExcludeList(),
            this._getAddressFormatIncludeList()
        );

        // this.updateMetadataFieldFormatValidation(addressMetadata, AddressItemType.ZipCode, '^[0-9]{6}$', 'Zip code must be 6 digits', 6);
        this.updateMetadataFieldFormatValidation(
            addressMetadata,
            AddressItemType.Phone,
            '^\\+971[1-9][0-9]{8}$',
            resources.addressPhoneFormatErrorMessage,
            13
        );
        // this.updateMetadataFieldFormatValidation(
        //     addressMetadata,
        //     AddressItemType.Name,
        //     '^(\\w+)(\\s+)(\\w+)$',
        //     'Name must contain 2 words (first & last name)'
        // );

        return addressMetadata;
    }

    private updateMetadataFieldFormatValidation(
        addressMetadata: AddressMetaData,
        addressItemType: AddressItemType,
        regEx: string,
        message: string,
        maxLength?: number
    ) {
        const formatValidationType: string = 'Format';
        try {
            //@ts-ignore
            const fieldMetadata = addressMetadata.metaData?.find((item: IAddressItem) => item.type === addressItemType);
            if (fieldMetadata) {
                if (maxLength) {
                    fieldMetadata.maxLength = maxLength;
                }
                const fieldValidationRule = fieldMetadata?.validationRules?.find(
                    (rule: { type: any }) => rule.type === formatValidationType
                );
                if (fieldValidationRule) {
                    fieldValidationRule.regEx = regEx;
                    fieldValidationRule.message = message;
                } else {
                    fieldValidationRule?.validationRules?.push({
                        type: formatValidationType,
                        regEx: regEx,
                        message: message
                    });
                }
            }
        } catch (err) {
            console.log(err);
        }
    }

    public async componentDidMount(): Promise<void> {
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: { channel }
                }
            },
            config: { autoSuggestionEnabled, autoSuggestOptions }
        } = this.props;

        // Initializing data props
        this._dataInitialize(this.props);

        this.props.data.checkout.then(() => {
            this._setDefaultCountryRegionId();
            this._initModuleState();
        });

        reaction(
            () => this.countryRegionId,
            () => {
                this._getStateProvinces();
            }
        );

        reaction(
            () => this.currentOperation,
            () => {
                this._getStateProvinces();
            }
        );

        reaction(
            () => this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress,
            shippingAddress => {
                if (this.props.moduleState.isUpdating) {
                    if (shippingAddress && this.isBillingAddressSameAsShipping) {
                        this.isBillingAddressSameAsShipping = true;
                        this._updateCurrentOperation(AddressOperation.Show, shippingAddress);
                    } else if (shippingAddress && this.isBillingAddressSameAsShipping) {
                        this._updateCurrentOperation(AddressOperation.Show, shippingAddress);
                    }
                }
            }
        );

        reaction(
            () => this.isBillingAddressRequried,
            isBillingAddressRequried => {
                if (isBillingAddressRequried) {
                    if (this.props.moduleState.isDisabled) {
                        this.onEdit();
                    }
                } else {
                    this.props.data.checkout.result?.removeBillingAddress({});
                    this.props.moduleState.onDisable();
                }
            }
        );

        if (autoSuggestionEnabled) {
            if (channel && !channel.BingMapsApiKey) {
                telemetry.error('BingMapsApiKey is missing.');
                return;
            }

            if (channel && !channel.BingMapsEnabled) {
                telemetry.error('Map is disabled from HQ.');
                return;
            }

            const options: IAutoSuggestOptions = { ...autoSuggestOptions };
            this.autoSuggest = new AutoSuggest(
                telemetry,
                options,
                channel?.BingMapsApiKey,
                channel?.ChannelCountryRegionISOCode,
                channel?.DefaultLanguageId
            );

            // Customer doesn't have any address. Then add view will be loaded directly. Code for the same to handle that
            if (
                this.props.data.storeSelectorStateManager.result &&
                (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update)
            ) {
                await this.autoSuggest._loadMapAPI(await this.props.data.storeSelectorStateManager);
            }

            reaction(
                () =>
                    this.props.data.storeSelectorStateManager.result?.loadMapApi &&
                    (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update),
                async () => {
                    await this.autoSuggest?._loadMapAPI(await this.props.data.storeSelectorStateManager);
                }
            );

            reaction(
                () => this.props.data.storeSelectorStateManager.result?.isMapApiLoaded,
                async () => {
                    await this._attachMapAutoSuggest();
                }
            );
        }

        if (this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging) {
            reaction(
                () => this.props.data.checkout.result?.checkoutError,
                checkoutError => {
                    if (
                        checkoutError &&
                        checkoutError.errorLocation === ErrorLocation.CheckoutBillingAddress &&
                        checkoutError.errorMessage
                    ) {
                        this._setErrorMessage(checkoutError.errorMessage);
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.checkoutErrorFocus,
                checkoutErrorFocus => {
                    if (checkoutErrorFocus === CheckoutModule.CheckoutBillingAddress) {
                        focusOnCheckoutError(this.checkoutErrorRef, this.props.context.actionContext);
                    }
                }
            );
        }
    }

    public async componentDidUpdate(): Promise<void> {
        if (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update) {
            if (this.props.data.storeSelectorStateManager.result?.isMapApiLoaded) {
                await this._attachMapAutoSuggest();
            }
        } else {
            this.autoSuggest?.disposeAutoSuggest();
        }
    }

    public shouldComponentUpdate(
        nextProps: ICheckoutBillingAddressProps<ICheckoutBillingAddressData>,
        nextState: ICheckoutBillingAddressViewState
    ): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        if (!this.isBillingAddressRequried || this._shouldHideBillingAddressForOBO) {
            return null;
        }

        const {
            resources,
            moduleState: { hasError }
        } = this.props;

        const { renderView, config } = this.props;

        const errorMessage = this.state.errorMessage;

        const viewProps = {
            ...this.props,
            currentOperation: this.currentOperation,
            selectedAddress: this.selectedAddress,
            addUpdateAddress: this.addUpdateAddress,
            countryRegionId: this.countryRegionId,
            stateProvinceInfo: this.stateProvinceInfo,
            validationError: this.validationError,
            addressActionResponse: this.addressActionResponse,
            className: config.className,
            viewState: {
                isShowAddress: this.selectedAddress && this.currentOperation === AddressOperation.Show,
                isShowAddOrUpdateAddress: this.currentOperation !== AddressOperation.Show,
                isShowSameAsShippingCheckbox: this.isCartContainsItemsForShipping && this.props.moduleState.isUpdating
            },
            CheckoutBillingAddress: {
                moduleProps: this.props,
                className: classnames('ms-checkout-billing-address', config.className)
            },
            heading: <AddressBillingHeading {...{ text: resources.addressBillingAddressHeading }} />,
            alert: hasError && errorMessage && <ErrorComponent {...{ title: resources.errorMessageTitle, message: errorMessage }} />,
            checkoutErrorRef: this.checkoutErrorRef,

            sameAsShippingCheckbox: (
                <AddressBillingCheckbox
                    {...{
                        isChecked: this.isBillingAddressSameAsShipping,
                        type: 'checkbox',
                        value: 'true',
                        ariaLabel: resources.addressSameAsShippingAddressAriaLabel,
                        text: resources.addressSameAsShippingAddressText,
                        telemetryContent: this.telemetryContent,
                        onChange: this._onBillingAddressSameAsShippingChange
                    }}
                />
            ),
            showAddress: this._renderShowAddress(),
            showAddOrUpdateAddress: this._renderAddOrUpdateAddress()
        };

        return renderView(viewProps) as React.ReactElement;
    }

    /**
     * On suggestion selected.
     * @param result - The suggestion result.
     */
    @action
    private readonly _onSuggestionSelected = async (result: Microsoft.Maps.ISuggestionResult): Promise<void> => {
        this._clearAddressFields();
        const address = this.addressFormat.getTranformedAddress(result, this.stateProvinceInfo);
        set(this.addUpdateAddress, { Street: '' });
        set(this.addUpdateAddress, { ZipCode: address.ZipCode });
        set(this.addUpdateAddress, { CountyName: address.CountyName });
        set(this.addUpdateAddress, { City: address.City });
        set(this.addUpdateAddress, { State: address.State });
        set(this.addUpdateAddress, { DistrictName: address.DistrictName });
        set(this.addUpdateAddress, { FullAddress: address.FullAddress });

        // Bing autosuggest put the complete address in the Street input box. Updating the street input box to show only street address.
        setTimeout(() => {
            set(this.addUpdateAddress, { Street: address.Street });
        }, 0);
    };

    /**
     * Clear address fields.
     */
    @action
    private readonly _clearAddressFields = (): void => {
        const addressFormatItem = this.addressFormat.getAddressFormat(
            this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId
        );
        addressFormatItem.forEach(format => {
            if (this.addUpdateAddress[format.name] !== undefined && !this.autoSuggest?.excludedAddressFields.includes(format.name)) {
                this.addressFormat[format.name] = '';
            }
        });
        this._clearValidation();
    };

    /**
     * Clear validation.
     */
    @action
    private readonly _clearValidation = (): void => {
        this.validationError = {};
    };

    /**
     * On address update.
     * @param name - Name.
     * @param value - Value.
     */
    private readonly onAddressAddUpdate = (name: string, value: string) => {
        set(this.addUpdateAddress, { [name]: value });
        this.addressFormat.validateAddressFormat(this.addUpdateAddress, this.validationError, this.countryRegionId, name);
    };

    /**
     * Method data initialization.
     * @param props -The checkout address properties.
     */
    private readonly _dataInitialize = (props: IProps): void => {
        const { data } = props;

        reaction(
            () => data.countryRegions.result,
            () => {
                this.countryRegions = data.countryRegions.result?.filter(country => country.CountryRegionId === 'ARE') ?? [];
            }
        );

        reaction(
            () => data.addressPurposes.result,
            () => {
                this.addressPurposes = data.addressPurposes.result ?? [];
            }
        );

        reaction(
            () => data.countryStates.result,
            () => {
                this.stateProvinceInfo = data.countryStates.result ?? [];
            }
        );
    };

    /**
     * Render add or update address function.
     * @returns - Address add update props.
     */
    private readonly _renderAddOrUpdateAddress = (): IAddressAddUpdateProps => {
        return AddressAddUpdate({
            resources: this.resources,
            addressType: AddressType.Billing,
            addressFormat: this.addressFormat.getAddressFormat(this.addUpdateAddress.ThreeLetterISORegionName ?? this.countryRegionId),
            defaultCountryRegionId: this.countryRegionId,
            defaultAddressType: this.defaultAddressType,
            selectedAddress: this.addUpdateAddress,
            validationError: this.validationError,
            addressActionResponse: this.addressActionResponse,
            dropdownDisplayData: this.addressFormat.getPrefilledAddressDropdownData(
                this.resources.addressStateDefaultSelectionText,
                this.stateProvinceInfo
            ),
            telemetryContent: this.telemetryContent,
            onInputChange: this._onAddressAddUpdateInputChange,
            onDropdownChange: this._onAddressAddUpdateDropdownChange,
            hasExternalSubmitGroup: this.props.moduleState.hasExternalSubmitGroup,
            onSave: this._onSubmitAddress,
            onCancel: this._resetView
        });
    };

    private _renderShowAddress(): IAddressShowProps | null {
        if (this.selectedAddress) {
            return AddressShow({
                address: this.selectedAddress,
                addressFormat: this.addressFormat.getAddressFormat(this.selectedAddress.ThreeLetterISORegionName ?? ''),
                addressPurposes: this.addressPurposes
            });
        }

        return null;
    }

    /**
     * On country region change function.
     * @param countryRegionId - Country region Id.
     */
    private readonly _onCountryChange = (countryRegionId: string) => {
        this.countryRegionId = countryRegionId;
        const twoLetterIsoRegionName = this.addressFormat.getTwoLetterISORegionName(countryRegionId);
        set(this.addUpdateAddress, { ThreeLetterISORegionName: countryRegionId });
        set(this.addUpdateAddress, { TwoLetterISORegionName: twoLetterIsoRegionName });
        this.autoSuggest?.changeAutoSuggestionCountryCode(twoLetterIsoRegionName);
        this._clearAddressFields();
    };

    /**
     * Gets address format for exclude list.
     * @returns - Address item type.
     */
    private readonly _getAddressFormatExcludeList = (): AddressItemType[] => {
        const { config } = this.props;
        const addressFormatExcludeList: AddressItemType[] = [];

        if (!config.showAddressType) {
            addressFormatExcludeList.push(AddressItemType.AddressTypeValue);
        }

        addressFormatExcludeList.push(AddressItemType.IsPrimary);

        return addressFormatExcludeList;
    };

    /**
     * Method to get all address format exclude list.
     * @returns Collection of address items.
     */
    private readonly _getAddressFormatIncludeList = (): AddressItemType[] => {
        const addressFormatIncludeList: AddressItemType[] = [
            AddressItemType.Phone,
            AddressItemType.Name,
            AddressItemType.ZipCode,
            AddressItemType.City,
            AddressItemType.State,
            AddressItemType.ThreeLetterISORegionName,
            AddressItemType.Street
        ];

        return addressFormatIncludeList;
    };

    /**
     * Attach map auto suggest.
     */
    private readonly _attachMapAutoSuggest = async (): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (storeSelectorStateManager?.isMapApiLoaded) {
            this.autoSuggest?.attachAutoSuggest('#billing_addressstreet', '#billing_addressstreet_container', this._onSuggestionSelected);
        }
    };

    /**
     * On address add update input change.
     * @param event - The event.
     */
    private readonly _onAddressAddUpdateInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
        const value = (event.target.value || '').replace(new RegExp('[<>]', 'gi'), '');
        this.onAddressAddUpdate(event.target.name, value);
    };

    /**
     * On address add update dropdown change.
     * @param event - The event.
     */
    private readonly _onAddressAddUpdateDropdownChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {
        this.onAddressAddUpdate(event.target.name, event.target.value);

        if (event.target.name === AddressItemType[AddressItemType.ThreeLetterISORegionName]) {
            this._onCountryChange(event.target.value);
        }
    };

    /**
     * Gets state provinces.
     */
    private readonly _getStateProvinces = (): void => {
        if (
            !this.countryRegionId ||
            !(this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update)
        ) {
            return;
        }

        this.addressCommon.getStateProvinces(this.countryRegionId).then((result: StateProvinceInfo[]) => {
            const stateInfo = result.some(state => state.StateId === this.addUpdateAddress.State);

            // Reset state if selected state not found in the list.
            if (!stateInfo) {
                set(this.addUpdateAddress, { State: '' });
            }
            this.stateProvinceInfo = result;
        });
    };

    /**
     * Initialize module state.
     */
    private readonly _initModuleState = (): void => {
        this.props.moduleState.init({
            status: this.isBillingAddressRequried ? 'updating' : 'disabled',
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit
        });

        const { billingAddress, isBillingAddressSameAsShippingAddress } = this.props.data.checkout.result ?? {};

        if (this.isBillingAddressRequried) {
            if (billingAddress) {
                this.isBillingAddressSameAsShipping = isBillingAddressSameAsShippingAddress ?? false;
                this._updateCurrentOperation(AddressOperation.Show, billingAddress);
                this._updateModuleState();
            } else if (this.isCartContainsItemsForShipping) {
                this.isBillingAddressSameAsShipping = true;
                this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
            } else {
                this.isBillingAddressSameAsShipping = false;
                this._updateCurrentOperation(AddressOperation.Add);
            }
        }
    };

    /**
     * Sets default country region Id.
     */
    private _setDefaultCountryRegionId(): void {
        const { request } = this.props.context;
        const market = request.channel?.ChannelCountryRegionISOCode;

        this.countryRegionId = this.addressCommon.getDefaultCountryRegionId(this.countryRegionId, this.countryRegions, market);
    }

    /**
     * On change - Billing address same as shipping.
     * @param event - The event.
     */
    private readonly _onBillingAddressSameAsShippingChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.isBillingAddressSameAsShipping = event.currentTarget.checked;

        if (this.isBillingAddressSameAsShipping && this.shippingAddress) {
            this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
        } else {
            this._updateCurrentOperation(AddressOperation.Add, this.billingAddress);
        }
    };

    @computed private get isCartContainsItemsForShipping(): boolean {
        const { request } = this.props.context;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const { channelDeliveryOptionConfig, featureState } = this.props.data;
        const retailMultiplePickUpOptionEnabled = featureState.result?.find(feature => feature.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;

        const pickupDeliveryModeCode = request.channel?.PickupDeliveryModeCode;
        const emailDeliveryModeCode = request.channel?.EmailDeliveryModeCode;

        // If hasInvoiceLine is true, there are only invoices no items in cart and return false here
        return this.props.data.checkout.result?.checkoutCart.hasInvoiceLine
            ? false
            : retailMultiplePickUpOptionEnabled
            ? ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).some(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !==
                            channelDeliveryOptionConfig.result?.PickupDeliveryModeCodes?.find(
                                deliveryMode => deliveryMode === cartLine.DeliveryMode
                            ) && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              )
            : ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).some(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              );
    }

    @computed private get billingAddress(): Address | undefined {
        return this.props.data.checkout.result?.billingAddress;
    }

    @computed private get shippingAddress(): Address | undefined {
        return this.props.data.checkout.result?.shippingAddress;
    }

    @computed private get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState?.loyaltyAmount ? checkoutState.loyaltyAmount : 0;
    }

    @computed private get getGiftCardTotalAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count: number, giftCard: IGiftCardExtend) => {
            return count + (giftCard.Balance || 0);
        }, 0);
    }

    @computed private get getCustomerAccountAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        const defaultAmount = 0;

        return checkoutState?.customerAccountAmount ?? defaultAmount;
    }

    @computed private get shouldPaidByCard(): boolean {
        const {
            data: { checkout },
            config
        } = this.props;
        if (!checkout.result) {
            return false;
        }

        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart.cart;
        if (!cart || !cart.CartLines || cart.CartLines.length === 0) {
            return false;
        }

        const { paymentTenderType, tokenizedPaymentCard } = checkoutResult;
        const isPaidByOtherPaymentSource = config.paymenTenderType !== paymentTenderType && tokenizedPaymentCard;

        // Use payment card when it is not free or gift card balance + Loyalty amount can not cover the total amount
        const amountDue = (cart.TotalAmount || 0) - this.getGiftCardTotalAmount - this.getLoyaltyAmount - this.getCustomerAccountAmount;

        return amountDue > 0 && !isPaidByOtherPaymentSource;
    }

    @computed private get isBillingAddressRequried(): boolean {
        return (
            this.shouldPaidByCard &&
            (!this.props.data.checkout?.result?.isPaymentVerificationRedirection ||
                !!this.props.data.checkout?.result?.isCheckoutCallFailed)
        );
    }

    @computed private get _shouldHideBillingAddressForOBO(): boolean {
        return Msdyn365.isOboRequest(this.props.context.request) && EnabledPaymentsForOBO.PaymentInstrument === 0;
    }

    /**
     * On submit address.
     */
    private readonly _onSubmitAddress = (): void => {
        if (!this.addressFormat.validateAddressFormat(this.addUpdateAddress, this.validationError, this.countryRegionId)) {
            this.props.moduleState.setHasError(true);

            if (
                this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout &&
                this.props.data.checkout.result?.isPaymentSectionContainerHasError
            ) {
                this.props.data.checkout.result.updateIsBillingAddressHasError({ newIsBillingAddressHasError: true });
            }

            return;
        }

        this._setBillingAddress(this.addUpdateAddress);
        this._updateCurrentOperation(AddressOperation.Show, this.addUpdateAddress);
        this._updateModuleState();
    };

    /**
     * On submit.
     */
    private readonly onSubmit = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this.props.telemetry.information('Billing address submit for Add or Update operation.');
                this._onSubmitAddress();
                break;
            case AddressOperation.Show:
                this.props.telemetry.information('Billing address submit for Show operation.');
                if (this.selectedAddress) {
                    this._setBillingAddress(this.selectedAddress);
                    this._updateCurrentOperation(AddressOperation.Show, this.selectedAddress);
                    this._updateModuleState();
                }
                break;
            default:
                this.props.telemetry.error('Invalid operation');
        }
    };

    /**
     * On cancel.
     */
    private readonly onCancel = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this.props.telemetry.information('Billing address cancel for Add or Update operation.');
                this._resetView();
                this._clearAddressFields();
                break;
            case AddressOperation.Show:
                this.props.telemetry.information('Billing address cancel for Show operation.');
                this._resetView();
                break;
            default:
                this.props.telemetry.error('Invalid operation');
        }
    };

    /**
     * On edit.
     */
    private readonly onEdit = (): void => {
        this.props.telemetry.information('Billing address onEdit is called.');

        if (this.isBillingAddressSameAsShipping && this.shippingAddress && this.isCartContainsItemsForShipping) {
            this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
        } else {
            this._updateCurrentOperation(AddressOperation.Add, this.billingAddress);
        }
        this.props.moduleState.onUpdating();
    };

    /**
     * Sets billing address.
     * @param address - The address.
     */
    private readonly _setBillingAddress = (address: Address): void => {
        if (this.props.data.checkout.result) {
            const newBillingAddress = { ...address };

            if (address.ThreeLetterISORegionName && !newBillingAddress.TwoLetterISORegionName) {
                newBillingAddress.TwoLetterISORegionName = this.addressFormat.getTwoLetterISORegionName(address.ThreeLetterISORegionName);
            }

            this.props.data.checkout.result.updateBillingAddress({
                newBillingAddress,
                additionalProperties: {
                    isBillingAddressSameAsShippingAddress: this.isBillingAddressSameAsShipping
                }
            });
        }
    };

    /**
     * Reset view.
     */
    private readonly _resetView = () => {
        this._updateCurrentOperation(AddressOperation.Show, this.billingAddress);
        this._updateModuleState();
    };

    /**
     * Update current operation.
     * @param operation - Address operation
     * @param selectedAddress - The selected address.
     */
    private readonly _updateCurrentOperation = (operation: AddressOperation, selectedAddress?: Address) => {
        this.currentOperation = operation;
        this.selectedAddress = selectedAddress;

        if (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update) {
            this.addUpdateAddress = { ...this.selectedAddress } || {};
            set(this.addUpdateAddress, {
                ThreeLetterISORegionName: this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId
            });
            set(this.addUpdateAddress, { AddressTypeValue: this.addUpdateAddress.AddressTypeValue || this.defaultAddressType });
        }
    };

    /**
     * Updates the module state.
     */
    private readonly _updateModuleState = () => {
        if (this.currentOperation === AddressOperation.Show) {
            this.props.moduleState.onReady();
        } else {
            this.props.moduleState.onUpdating();
        }
    };

    @action
    private readonly _setErrorMessage = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.setState({
            errorMessage
        });
    };
}

export default CheckoutBillingAddress;
