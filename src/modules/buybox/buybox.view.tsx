/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import {
    getConfigureErrors,
    IBuyboxAddToCartViewProps,
    IBuyboxCallbacks,
    IBuyboxCommonResources,
    IBuyboxData,
    IBuyboxKeyInPriceViewProps,
    IBuyboxProductConfigureDropdownViewProps,
    IBuyboxProductConfigureViewProps,
    IBuyboxProductQuantityViewProps,
    IBuyboxResources as IBuyboxExtentionResources,
    IBuyboxShopSimilarLookViewProps,
    IBuyboxState,
    IBuyboxViewProps,
    IBuyboxFindInStoreViewProps
} from '@msdyn365-commerce-modules/buybox';
import {
    ArrayExtensions,
    getFullAvailableInventoryNearby,
    GetFullAvailableInventoryNearbyInput,
    IFullOrgUnitAvailability
} from '@msdyn365-commerce-modules/retail-actions';
import { IncrementalQuantity, INodeProps, ITelemetryContent, Module, Node, Modal, Button } from '@msdyn365-commerce-modules/utilities';
import { reaction } from 'mobx';
import * as React from 'react';
// import { IBuyboxViewProps } from './buybox';
// import { IBuyboxFindInStoreViewProps } from './components/buybox-find-in-store';
// import { IBuyboxProps as IBuyboxExtentionProps, IBuyboxProps } from './buybox.props.autogenerated';
import { format, ItemAvailability, SimpleProduct } from '@msdyn365-commerce/retail-proxy';
import { AddToWishlistComponent, IWishlistActionErrorResult, AddToCartComponent } from '@msdyn365-commerce/components';
import { IAddToCartComponentProps } from '../../themes/adventureworks/views/components/addtocart.component';
import { renderAddToOrderTemplateButton } from '../../themes/adventureworks/views/components/buybox-add-to-order-template';
import {
    IBuyboxProps as IBuyboxExtentionProps,
    IBuyboxProps
} from '../../themes/adventureworks/definition-extensions/buybox.ext.props.autogenerated';
import { IStoreInfo } from '@msdyn365-commerce-modules/bopis-utilities';

/**
 * BuyBoxConstants enum.
 */
export enum BuyBoxConstants {
    zero = 0
}

/**
 * On Change function.
 * @param callbacks -Callbacks.
 * @returns Update quantity.
 */
const onChangeHandler = (callbacks: IBuyboxCallbacks) => (newValue: number): boolean => {
    if (callbacks.updateQuantity) {
        return callbacks.updateQuantity(newValue);
    }
    return true;
};

/**
 * RenderQuantity.
 * @param quantityComponent - QuantityComponent.
 * @param callbacks - Callbacks.
 * @param props - Props.
 * @param state - State.
 * @param extentionResources - ExtentionResources.
 * @param quantityLimitsMessages - QuantityLimitsMessages.
 * @param max - Max.
 * @param telemetryContent - TelemetryContent.
 * @param unitOfMeasure - Unit Of Measure.
 * @returns -- Returns.
 */
const renderQuantity = (
    quantityComponent: IBuyboxProductQuantityViewProps,
    callbacks: IBuyboxCallbacks,
    props: IBuyboxProps<IBuyboxData>,
    state: IBuyboxState,
    extentionResources: IBuyboxExtentionResources,
    quantityLimitsMessages: React.ReactNode,

    // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
    min: number | undefined,
    max: number | undefined,
    applyDefaultOrderSettings?: boolean,
    telemetryContent?: ITelemetryContent,
    unitOfMeasure?: React.ReactNode
): JSX.Element => {
    // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
    const { ContainerProps, LabelContainerProps, heading, errors } = quantityComponent;

    const { resources } = props;

    const { quantity } = state;

    return (
        <Node {...ContainerProps}>
            <Node {...LabelContainerProps}>
                {heading}
                {errors}
            </Node>

            <IncrementalQuantity
                id='ms-buybox__product-quantity-input'
                min={min}
                max={max}
                applyDefaultOrderSettings={applyDefaultOrderSettings}
                currentCount={quantity}
                onChange={onChangeHandler(callbacks)}
                inputQuantityAriaLabel={resources.inputQuantityAriaLabel}
                decrementButtonAriaLabel={resources.decrementButtonAriaLabel}
                incrementButtonAriaLabel={resources.incrementButtonAriaLabel}
                minQuantityText={extentionResources.minQuantityText}
                maxQuantityText={extentionResources.maxQuantityText}
                telemetryContent={telemetryContent}
            />
            {unitOfMeasure}
            {quantityLimitsMessages}
        </Node>
    );
};

/**
 * Render key in price function.
 * @param keyInPrice - KeyInPrice.
 * @returns -- Returns.
 */
const renderKeyInPrice = (keyInPrice: IBuyboxKeyInPriceViewProps): JSX.Element => {
    const { ContainerProps, LabelContainerProps, heading, input } = keyInPrice;

    return (
        <Node {...ContainerProps}>
            <Node {...LabelContainerProps}>{heading}</Node>
            {input}
        </Node>
    );
};

/**
 * Resolves whether product is in stock.
 * @param props - The add to cart component props.
 * @param includeCurrentQuantity - Flag to specify whether current quantity should be included.
 * @returns The dialog element.
 */
const defaultQuantity = 1;
const shouldShowOutOfStock = (props: IAddToCartComponentProps, includeCurrentQuantity: boolean): boolean => {
    if (props.context.app.config.enableStockCheck === undefined || props.context.app.config.enableStockCheck === false) {
        return false;
    }

    // When skip site settings do not need show out of stock on adding to cart
    if (props.shouldSkipSiteSettings) {
        return false;
    }

    if (
        props.isLoading ||
        props.isProductQuantityLoading ||
        props.isUpdatingDimension ||
        props.isLoadingDeliveryOptions ||
        props.isUpdatingDeliveryOptions ||
        props.isAddServiceItemToCart
    ) {
        // Out of stock turn off, don't bother showing out of stock
        return false;
    }

    if (!props.data || !props.data.product.RecordId) {
        // No product exists, don't bother showing out of stock
        return false;
    }

    const hasAvailableProducts = props.hasAvailableProducts ?? true;
    if (!hasAvailableProducts) {
        return true;
    }

    if (props.data.product.Dimensions) {
        if (props.data.product.Dimensions.find(dimension => !(dimension.DimensionValue && dimension.DimensionValue.Value))) {
            // At least one dimension with no value exists on the product, so also don't show out of stock
            return false;
        }
    }

    const includedQuantityNumber = includeCurrentQuantity && props.quantity ? props.quantity : defaultQuantity;

    return !(
        props.productAvailability &&
        props.productAvailability.AvailableQuantity !== undefined &&
        props.productAvailability.AvailableQuantity >= includedQuantityNumber
    );
};

/**
 * RenderAddToCart.
 * @param addToCart - AddToCart.
 * @returns -- Returns.
 */
const renderAddToCart = (
    addToCart: IBuyboxAddToCartViewProps,
    props: IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData>,
    setOpen: React.Dispatch<React.SetStateAction<boolean>>
): JSX.Element => {
    // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
    const { ContainerProps, errorBlock, button } = addToCart;
    const { context } = props;

    let buttonProps: IAddToCartComponentProps = {
        addToCartText: '',
        context: context,
        id: '',
        typeName: '',
        data: undefined
    };

    if (React.isValidElement(button)) {
        // Use type assertion to tell TypeScript about the type of button
        const buttonElement = button as React.ReactElement<any, string | React.JSXElementConstructor<any>>;

        // Access props property of buttonElement
        buttonProps = buttonElement.props as IAddToCartComponentProps;
    }

    return (
        <Node {...ContainerProps}>
            {errorBlock}
            {/* {button} */}
            {shouldShowOutOfStock(buttonProps, false) ? (
                <div className={buttonProps.className}>
                    <button
                        className='notify-btn mt-3'
                        onClick={() => {
                            setOpen(o => !o);
                        }}
                    >
                        Notify Me When Available
                    </button>
                </div>
            ) : (
                <AddToCartComponent {...buttonProps} />
            )}
        </Node>
    );
};

/**
 * RenderFindInStore.
 * @param findInStore - FindInStore.
 * @returns -- Returns.
 */
const renderFindInStore = (findInStore: IBuyboxFindInStoreViewProps): JSX.Element => {
    // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
    const { ContainerProps, storeSelector, heading, description, errors, button, modal, productPickupOptionList } = findInStore;

    return (
        <Node {...ContainerProps}>
            {storeSelector}
            {heading}
            {productPickupOptionList}
            {description}
            {errors}
            {button}
            {modal}
        </Node>
    );
};

/**
 * RenderAddToOrderTemplate.
 * @param props - Buybox view props.
 * @param state - Buybox state.
 * @param callbacks - Buybox callbacks.
 * @returns -- Returns.
 */
const renderAddToOrderTemplate = (
    props: IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks
): JSX.Element | null => {
    const product = props.data.product.result;
    if (!props.addToOrderTemplate || !product) {
        return null;
    }

    const orderTemplateButton = renderAddToOrderTemplateButton(props, state, callbacks, product);

    return (
        <Node {...props.addToOrderTemplate.ContainerProps}>
            {props.addToOrderTemplate.errorBlock}
            {orderTemplateButton}
        </Node>
    );
};

/**
 * Add to wishlist failed function.
 * @param callbacks -Buybox callbacks.
 * @param resources -Buybox resources.
 * @param product -Simple product.
 * @returns Update error state.
 */
const onAddToWishlistFailed = (callbacks: IBuyboxCallbacks, resources: IBuyboxCommonResources, product: SimpleProduct | undefined) => (
    result: IWishlistActionErrorResult
) => {
    callbacks.updateErrorState({
        errorHost: 'WISHLIST',
        configureErrors:
            result.status === 'MISSINGDIMENSION' ? getConfigureErrors(result.missingDimensions, resources, product?.IsGiftCard) : {}
    });
};

/**
 * RenderAddToWishlist.
 * @param props - Buybox view props.
 * @param state - Buybox state.
 * @param callbacks - Buybox callbacks.
 * @param product - Product data.
 * @returns -- Returns.
 */
const renderAddtoWishlistButton = (
    props: IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks,
    product: SimpleProduct
): React.ReactNode => {
    const { context, resources } = props;
    const wishlists = props.data.wishlists.result;
    const isShowWishlitButtonText = true;
    return (
        <AddToWishlistComponent
            className='msc-add-to-cart-extra-actions'
            addToWishlistButtonText={``}
            removeFromWishlistButtonText={resources.removeFromWishlistButtonText}
            addToWishlistMessage={resources.addToWishlistMessage}
            removedFromWishlistMessage={resources.removedFromWishlistMessage}
            addItemToWishlistError={resources.addItemToWishlistError}
            removeItemFromWishlistError={resources.removeItemFromWishlistError}
            nameOfWishlist={resources.nameOfWishlist}
            data={{ product, wishlists }}
            context={context}
            ariaRole='button'
            id={props.id}
            typeName={props.typeName}
            onError={onAddToWishlistFailed(callbacks, resources, product)}
            getSelectedProduct={state.selectedProduct}
            showButtonText={isShowWishlitButtonText}
            showButtonTooltip={false}
        />
    );
};

/**
 * RenderAddToWishlist.
 * @param props - Buybox viewprops.
 * @param state - Buybox state.
 * @param callbacks - Buybox callbacks.
 * @returns -- Returns.
 */
const renderAddToWishlist = (
    props: IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks
): JSX.Element | null => {
    const product = props.data.product.result;
    if (!props.addToWishlist || !product) {
        return null;
    }

    if (!props.config.enableWishlist) {
        return null;
    }

    const wishlistButton = renderAddtoWishlistButton(props, state, callbacks, product);
    return (
        <Node {...props.addToWishlist.ContainerProps}>
            {props.addToWishlist.errorBlock}
            {wishlistButton}
        </Node>
    );
};

/**
 * RRenderShopSimilarItem.
 * @param shopSimilarItem - ShopSimilarItem.
 * @returns -- Returns.
 */
const renderShopSimilarItem = (shopSimilarItem: IBuyboxShopSimilarLookViewProps): JSX.Element => {
    // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
    const { ContainerProps, errors, input } = shopSimilarItem;

    return (
        <Node {...ContainerProps}>
            {errors}
            {input}
        </Node>
    );
};

/**
 * RenderSocialShare.
 * @param socialShare - Social share react node array.
 * @returns -- Returns.
 */
const _renderSocialShare = (socialShare: React.ReactNode[]): JSX.Element | undefined => {
    if (!socialShare || socialShare.length === 0) {
        return undefined;
    }

    return <>{socialShare[0]}</>;
};

/**
 * RenderConfigureDropdown.
 * @param dropdown - Buybox product configure dropdown view props.
 * @returns -- Returns JSX.Element.
 */
const renderConfigureDropdown = (dropdown: IBuyboxProductConfigureDropdownViewProps): JSX.Element => {
    const { ContainerProps, LabelContainerProps, heading, errors, select } = dropdown;

    return (
        <Node {...ContainerProps}>
            <Node {...LabelContainerProps}>{heading}</Node>
            {select}
            {errors}
        </Node>
    );
};

/**
 * RenderConfigure.
 * @param configure - Buybox product configure view props.
 * @returns -- Returns JSX.Element.
 */
const renderConfigure = (configure: IBuyboxProductConfigureViewProps): JSX.Element => {
    const { ContainerProps, dropdowns } = configure;

    return <Node {...ContainerProps}>{dropdowns.map(renderConfigureDropdown)}</Node>;
};

/**
 * BuyboxView.
 * @param props - Props.
 * @returns -- Returns.
 */
const BuyboxView: React.FC<IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData>> = props => {
    // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
    const {
        ModuleProps,
        // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
        MediaGalleryContainerProps,
        // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
        ProductInfoContainerProps,
        addToCart,
        addToOrderTemplate,
        addToWishlist,
        productComparisonButton,
        configure,
        description,
        findInStore,
        quantity,
        price,
        title,
        rating,
        inventoryLabel,
        shopSimilarLook,
        keyInPrice,
        shopSimilarDescription,
        min,
        // eslint-disable-next-line @typescript-eslint/naming-convention -- Dependency from Buybox.tsx file
        max,
        applyDefaultOrderSettings,
        unitOfMeasure,
        callbacks,
        state,
        resources,
        quantityLimitsMessages,
        telemetryContent,
        app: { config: appConfig },
        catalogs,
        data: { product }
    } = props;

    let skuText: string = props.resources.skuText;
    skuText += props.data.product.result?.ItemId;
    const preferredStoreInfo: IStoreInfo | undefined = props.data.storeSelectorStateManager.result?.preferredStore;
    const preferredStoreId = preferredStoreInfo?.StoreId ? preferredStoreInfo.StoreId : '';
    const preferredStoreName = preferredStoreInfo?.StoreName ? preferredStoreInfo.StoreName : '';

    const [availability, setAvailability] = React.useState<string>('');
    const [isStoreChange, setIsStoreChange] = React.useState<boolean>(false);

    /* Context Variables */
    const cRetailURL = props.context.request.apiSettings.baseUrl;
    const cRetailOUN = props.context.request.apiSettings.oun ? props.context.request.apiSettings.oun : '';
    const cCustomerAccount = props.context.request.user.customerAccountNumber
        ? props.context.request.user.customerAccountNumber
        : 'EC00001';
    const cCustomerEmailAddress = props.context.request.user.emailAddress ? props.context.request.user.emailAddress : '';

    /** Notify Me */
    const [open, setOpen] = React.useState(false);
    const closeModal = () => setOpen(false);
    const [email, setEmail] = React.useState<string>(cCustomerEmailAddress);
    const [validEmail, setValidEmail] = React.useState<string>('');
    const [statusMessage, setStatusMessage] = React.useState<string>('');
    const [loading, setLoading] = React.useState<boolean>(false);

    /** Notify Me Submit Form */
    const notifyMeSubmitForm = async (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setLoading(true);

        const itemId = product.result?.ItemId;
        console.log('SIMPLE PRODUCT ITEM ID>>>', itemId);

        if (!email || !validateEmail(email)) {
            setValidEmail('daiso_ntfy_error-message');
            setLoading(false);
            return;
        } else {
            setValidEmail('');
        }

        // Need to update the URL with Lals
        const cNotifyMeRetailURL = `${cRetailURL}Commerce/TCPLCreateNotifyMeSubscription?api-version=7.3`;

        var data = JSON.stringify({
            custAccount: cCustomerAccount,
            email: email,
            itemid: itemId
        });

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = true;

        xhr.addEventListener('readystatechange', function() {
            try {
                if (this.readyState === 4) {
                    if (xhr.status === 200) {
                        const result = JSON.parse(xhr.responseText);
                        if (result.value === 1) {
                            setStatusMessage('true');
                        } else {
                            setStatusMessage('false');
                        }
                    } else {
                        setStatusMessage('false');
                    }
                    setTimeout(function() {
                        setOpen(false);
                        setStatusMessage('');
                    }, 4000);
                }
            } catch (Exception) {
                console.log('NotifyMe Exception>>>>', Exception);
            } finally {
                setLoading(false);
            }
        });

        xhr.open('POST', cNotifyMeRetailURL);
        xhr.setRequestHeader('User-Agent', 'Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0');
        xhr.setRequestHeader('OUN', cRetailOUN);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(data);
    };

    /** Validate Email Address */
    const validateEmail = (email: string) => {
        // Regular expression for email validation
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    };

    /** Notify Me Modal Popup Container */
    const _notifyMeModalContainer = (): INodeProps => {
        return {
            tag: Modal,
            placement: 'center',
            hideArrow: true,
            className: 'ms-notify-me_modal-container',
            wrapClassName: 'ms-notify-me__modal',
            isOpen: open,
            toggle: closeModal
        };
    };

    /** Notify Me Modal Render */
    const renderNotifyMe = (): JSX.Element => {
        return (
            <Node {..._notifyMeModalContainer()}>
                <Node className='ms-notify-me__header msc-modal__header'>
                    {'Notify me when available'}
                    {<Button className='msc-modal__close-button' aria-label='Close' onClick={closeModal}></Button>}
                </Node>
                {loading && <div className='loader'>Loading...</div>}
                <Node className='ms-notify-me__body msc-modal__body'>
                    {<p>Subscribe to this product to receive a notification once it becomes available.</p>}
                    <Node className=''>
                        {
                            <form onSubmit={notifyMeSubmitForm}>
                                <div className='daiso_ntfy_msv-row-email'>
                                    <input
                                        type='email'
                                        name='email'
                                        value={email}
                                        onChange={e => setEmail(e.target.value)}
                                        placeholder='Email'
                                        className={`${validEmail}`}
                                        required
                                    />
                                    {validEmail !== '' && <div>Please enter a valid mail</div>}
                                </div>
                                {statusMessage !== '' && (
                                    <div className='daiso_ntfy_alert-message'>
                                        {statusMessage === 'true' && (
                                            <div className='alert alert-success'>Your request has been submitted</div>
                                        )}
                                        {statusMessage === 'false' && (
                                            <div className='alert alert-danger'>Your request has not been submitted</div>
                                        )}
                                    </div>
                                )}
                                <button className='daiso_ntfy_submit-button' type='submit'>
                                    Notify me when available
                                </button>
                            </form>
                        }
                    </Node>
                </Node>
            </Node>
        );
    };

    /**
     * GetStockInventoryLabel.
     * @param availabilityWithHours - Stock availability with hours.
     * @returns -- Returns.
     */
    const getStockInventoryLabel = (availabilityWithHours: IFullOrgUnitAvailability | undefined): string | undefined => {
        if (availabilityWithHours && ArrayExtensions.hasElements(availabilityWithHours.ProductInventoryInformation)) {
            for (const productInventoryInformation of availabilityWithHours.ProductInventoryInformation) {
                if (
                    availabilityWithHours.OrgUnitAvailability?.OrgUnitLocation?.InventoryLocationId ===
                    productInventoryInformation.InventLocationId
                ) {
                    return productInventoryInformation.StockLevelLabel;
                }
            }
        }

        return undefined;
    };

    const getInventory = React.useCallback(async () => {
        const input = new GetFullAvailableInventoryNearbyInput(
            props.data.product.result?.RecordId,
            BuyBoxConstants.zero,
            BuyBoxConstants.zero,
            BuyBoxConstants.zero,
            BuyBoxConstants.zero,
            true
        );

        /**
         * IsProductInStock.
         * @param itemAvailabilities - Item availability array.
         * @returns -- Returns.
         */
        const isProductInStock = (itemAvailabilities: ItemAvailability[] | undefined): boolean => {
            if (!appConfig.enableStockCheck) {
                return true;
            }

            if (ArrayExtensions.hasElements(itemAvailabilities)) {
                return itemAvailabilities[BuyBoxConstants.zero].AvailableQuantity! > BuyBoxConstants.zero;
            }

            return false;
        };

        await getFullAvailableInventoryNearby(input, props.context.actionContext)
            .catch((error: Error) => {
                props.telemetry.error(error.message);
            })
            .then(response => {
                if (response && ArrayExtensions.hasElements(response)) {
                    const isPreferredStore = (value: IFullOrgUnitAvailability) =>
                        value.OrgUnitAvailability?.OrgUnitLocation?.OrgUnitNumber === preferredStoreId;
                    const filteredFullOrgUnitAvailability = response.filter(isPreferredStore);
                    const preferredStoreAvailability = ArrayExtensions.hasElements(filteredFullOrgUnitAvailability)
                        ? filteredFullOrgUnitAvailability[BuyBoxConstants.zero]
                        : undefined;
                    const stockStatusLabel: string | undefined = getStockInventoryLabel(preferredStoreAvailability);
                    const isInStock = isProductInStock(preferredStoreAvailability?.OrgUnitAvailability?.ItemAvailabilities);
                    const resourceLabel = isInStock ? props.resources.inStockText : props.resources.outOfStockText;
                    const stockText: string | undefined = stockStatusLabel ? stockStatusLabel : resourceLabel;
                    const preferredStoreAvailabilityText = `${format(
                        props.resources.availabilityAtPreferredStoreText,
                        preferredStoreName
                    )} ${stockText}`;
                    setAvailability(preferredStoreAvailabilityText);
                }
            });

        setIsStoreChange(false);
    }, [
        props.data.product.result?.RecordId,
        appConfig.enableStockCheck,
        preferredStoreId,
        preferredStoreName,
        props.context.actionContext,
        props.resources.availabilityAtPreferredStoreText,
        props.resources.inStockText,
        props.resources.outOfStockText,
        props.telemetry
    ]);

    React.useEffect(() => {
        if (props.config.displayStockAvailability) {
            getInventory().catch((error: Error) => {
                props.telemetry.error(error.message);
            });
        }
    }, [getInventory, isStoreChange, props.telemetry, props.config.displayStockAvailability]);

    reaction(
        () => props.data.storeSelectorStateManager.result?.selectedStoreLocationId,
        () => {
            setIsStoreChange(true);
        }
    );

    /**
     * RenderAvailabiltyAtPreferredStore.
     * @returns -- Returns.
     */
    const renderAvailabilityAtPreferredStore = (): JSX.Element | undefined => {
        const hasProductDimensions = ArrayExtensions.hasElements(props.data.product.result?.Dimensions);
        if (hasProductDimensions && props.data.product.result?.MasterProductId === undefined) {
            return undefined;
        }
        const containerProps: INodeProps = {
            className: 'ms-buybox__preferred-store-availability',
            tag: 'span'
        };

        return <Node {...containerProps}>{availability}</Node>;
    };

    return (
        <>
            <Module {...ModuleProps}>
                <Node {...MediaGalleryContainerProps}>
                    {addToWishlist && renderAddToWishlist(props, state, callbacks)}
                    {props.mediaGallery}
                </Node>
                <Node {...ProductInfoContainerProps}>
                    {catalogs && catalogs[0].Name}
                    {title}
                    {configure && renderConfigure(configure)}
                    <Node className='msc-buybox__description-section'>
                        <div className='msc-buybox__description-section-text'>{props.resources.descriptionText}</div>
                        {description}
                    </Node>
                    <Node className='msc-buybox__ratings-section'>
                        <div className='msc-buybox__ratings-section-sku-text'>{skuText}</div>
                        {rating}
                    </Node>
                    <Node className='msc-buybox__price-section'>
                        <div className='msc-buybox__price-section-text'>{props.resources.priceText}</div>
                        {price}
                    </Node>
                    {keyInPrice && renderKeyInPrice(keyInPrice)}
                    <Node className='msc-buybox__bulk-purchase-section'>
                        <div className='msc-buybox__bulk-purchase-button-text'>
                            {quantity &&
                                renderQuantity(
                                    quantity,
                                    callbacks,
                                    props,
                                    state,
                                    resources,
                                    quantityLimitsMessages,
                                    min,
                                    max,
                                    applyDefaultOrderSettings,
                                    telemetryContent,
                                    unitOfMeasure
                                )}
                            {props.bulkPurchaseLink}
                        </div>
                    </Node>
                    {props.config.displayStockAvailability && preferredStoreId && renderAvailabilityAtPreferredStore()}
                    {inventoryLabel}
                    {renderAddToCart(addToCart, props, setOpen)}
                    {findInStore && renderFindInStore(findInStore)}
                    {productComparisonButton}
                    {addToOrderTemplate && renderAddToOrderTemplate(props, state, callbacks)}
                    {findInStore?.productPickupOptionList ? (
                        <div className='msc-buybox__pickup-options'>{findInStore.productPickupOptionList}</div>
                    ) : null}
                    {_renderSocialShare(props.slots && props.slots.socialShare)}
                    <div className='msc-buybox__description-text'>{props.resources.shopText}</div>
                    <Node className='msc-buybox__shop-description'>
                        {shopSimilarLook && renderShopSimilarItem(shopSimilarLook)}
                        {shopSimilarDescription && renderShopSimilarItem(shopSimilarDescription)}
                    </Node>
                </Node>
            </Module>
            <Node className='msc-buybox__prod-spec-container'>
                <h2 className='msc-buybox__prod-spec-title'>Product Specification</h2>
                {ArrayExtensions.hasElements(props.slots.productSpecification) ? (
                    <Node className='msc-buybox__product-specification'>{props.slots.productSpecification[0]}</Node>
                ) : null}
            </Node>
            {renderNotifyMe()}
        </>
    );
};

export default BuyboxView;
