/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { ProductDimensionFull } from '@msdyn365-commerce/commerce-entities';
import { Carousel, ICarouselProps } from '@msdyn365-commerce/components';
import msdyn365Commerce, { IImageData, IImageSettings, Image } from '@msdyn365-commerce/core';
import {
    ProductDeliveryOptions,
    ProductDimension,
    ProductDimensionValue,
    ProductPrice,
    ReleasedProductType,
    SimpleProduct
} from '@msdyn365-commerce/retail-proxy';
import {
    ArrayExtensions,
    convertProductDimensionTypeToDimensionTypes,
    FinitePromiseQueue,
    FinitePromiseQueueError,
    getDeliveryOptionsForSelectedVariant,
    GetDeliveryOptionsForSelectedVariantInput,
    getDimensionsForSelectedVariant,
    GetDimensionsForSelectedVariantInput,
    getPriceForSelectedVariant,
    getProductAvailabilitiesForSelectedVariant,
    getProductPageUrlSync,
    getSelectedVariant,
    IProductInventoryInformation,
    IPromiseQueue,
    ISelectedProduct,
    ObjectExtensions,
    PriceForSelectedVariantInput,
    ProductAvailabilitiesForSelectedVariantInput,
    SelectedVariantInput,
    StringExtensions
} from '@msdyn365-commerce-modules/retail-actions';
import {
    Button,
    format,
    getPayloadObject,
    getTelemetryAttributes,
    getTelemetryObject,
    IComponentNodeProps,
    IModuleProps,
    IncrementalQuantity,
    INodeProps,
    ISingleSlideCarouselProps,
    isMobile,
    ITelemetryContent,
    KeyCodes,
    Modal,
    ModalBody,
    ModalFooter,
    ModalHeader,
    NodeTag,
    onTelemetryClick,
    SingleSlideCarousel,
    TelemetryConstant,
    updateMaxQuantityForCartLineItem,
    VariantType
} from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { Spinner, SpinnerSize } from 'office-ui-fabric-react';
import React, { ReactNode } from 'react';

import {
    getBuyboxAddToCart,
    getBuyBoxInventoryLabel,
    getBuyboxKeyInPrice,
    getBuyboxProductAddToWishlist,
    getBuyboxProductDescription,
    getBuyboxProductPrice,
    getBuyboxProductRating,
    getBuyboxProductTitle,
    getBuyboxProductUnitOfMeasure,
    getQuantityLimitsMessages,
    IBuyboxAddToCartViewProps,
    IBuyboxAddToOrderTemplateViewProps,
    IBuyboxAddToWishlistViewProps,
    IBuyboxCallbacks,
    IBuyboxCommonData,
    IBuyboxExtentedProps,
    IBuyboxKeyInPriceViewProps,
    IBuyboxProductConfigureViewProps,
    IBuyboxProductQuantityViewProps,
    IBuyboxState,
    IErrorState,
    IProductDetails,
    RetailDefaultOrderQuantityLimitsFeatureName,
    EcommerceQuantityLimitConfigurationsFeatureName,
    RevertToSiteBuilderOrderQuantityLimitsSettingsCRTFeatureName
} from '@msdyn365-commerce-modules/buybox';
import { getBuyboxProductConfigure } from '@msdyn365-commerce-modules/buybox';
import { IQuickviewData } from './quickview.data';
import { IQuickviewProps, IQuickviewResources } from './quickview.props.autogenerated';
import { getProductDetails } from './utilities/get-product-details';
import { getProductImages, getValidProductImages } from './utilities/get-valid-product-images';
import { RecentlyViewedState } from '@msdyn365-commerce-modules/buybox';

/**
 * QuickView props Interface.
 */
export interface IQuickviewViewProps extends IQuickviewProps<IQuickviewData> {
    quickView: IModuleProps;
    quickViewButton: React.ReactNode;
    ModalContainer: IModuleProps;
    ModalHeaderContainer: INodeProps;
    ModalHeaderContent: React.ReactNode;
    ModalFooterContainer: INodeProps;
    ModalBodyContainer: INodeProps;
    cartContainerProps: INodeProps;
    state: IBuyboxState;
    ModuleProps?: IModuleProps;
    ProductInfoContainerProps: INodeProps;
    MediaGalleryContainerProps: INodeProps;
    callbacks?: IBuyboxCallbacks;
    title?: React.ReactNode;
    description?: React.ReactNode;
    configure?: IBuyboxProductConfigureViewProps;
    inventoryLabel?: React.ReactNode;
    rating?: React.ReactNode;
    price?: React.ReactNode;
    addToCart?: IBuyboxAddToCartViewProps;
    addToOrderTemplate?: IBuyboxAddToOrderTemplateViewProps;
    addToWishlist?: IBuyboxAddToWishlistViewProps;
    max: number | undefined;
    keyInPrice?: IBuyboxKeyInPriceViewProps;
    quantity?: IBuyboxProductQuantityViewProps;
    quantityLimitsMessages?: React.ReactNode;
    CarouselProps: INodeProps;
    Thumbnails: IQuickViewThumbnailsViewProps;
    seeDetailsbutton: React.ReactNode;
    isModalOpen: boolean;
    loading?: React.ReactNode;
    unitOfMeasure?: React.ReactNode;
    productDetails?: IProductDetails | undefined;
    isMobileDevice?: boolean;
}

/**
 * QuickView extend props Interface.
 */
export interface IQuickviewExtentedProps<T> extends IQuickviewProps<IQuickviewData> {
    selectedProductId?: number;
    selectedDimensions?: ProductDimension[];
}

/**
 * QuickView thumbnails props Interface.
 */
export interface IQuickViewThumbnailsViewProps {
    ThumbnailsContainerProps: INodeProps;
    SingleSlideCarouselComponentProps: INodeProps;
    items?: IQuickViewThumbnailItemViewProps[];
}

/**
 * QuickView thumbnail item view props Interface.
 */
export interface IQuickViewThumbnailItemViewProps {
    ThumbnailItemContainerProps: INodeProps;
    Picture: React.ReactElement;
}

/**
 * QuickView state Interface.
 */
export interface IQuickViewState extends IBuyboxState {
    isDataLoaded: boolean;
}

/**
 *
 * Quickview component.
 * @extends {React.Component<IQuickviewProps<IQuickviewData>>}
 */
class Quickview extends React.Component<IQuickviewExtentedProps<IQuickviewData>, IQuickViewState> {
    /**
     * A queue of tasks of processing the changes in the dimensions.
     * Limit to two processes:
     * 1 - for the current process, which is under execution at the moment.
     * 2 - next process, which will process the latest version of data.
     * @remark Enqueueing new promises will discard the previous ones (except the one which is under processing).
     */
    private readonly dimensionUpdateQueue: IPromiseQueue<void> = new FinitePromiseQueue<void>(2);

    private dimensions: { [id: number]: string } = {};

    private initializedDimensions: Set<string> = new Set();

    private readonly telemetryContent: ITelemetryContent;

    private productDetails: IProductDetails | undefined;

    private readonly quickViewCallbacks: IBuyboxCallbacks = {
        updateQuantity: (newQuantity: number): boolean => {
            const errorState = { ...this.state.errorState };
            errorState.quantityError = undefined;
            errorState.otherError = undefined;

            this.setState({ quantity: newQuantity, errorState });
            return true;
        },
        updateErrorState: (newErrorState: IErrorState): void => {
            this.setState({ errorState: newErrorState });
        },
        updateSelectedProduct: (
            newSelectedProduct: Promise<SimpleProduct | null>,
            newInventory: IProductInventoryInformation | undefined,
            newPrice: ProductPrice | undefined,
            newDeliveryOptions: ProductDeliveryOptions | undefined
        ): void => {
            this.setState({
                selectedProduct: newSelectedProduct,
                productAvailableQuantity: newInventory,
                productDeliveryOptions: newDeliveryOptions
            });
            this._updatePrice(newPrice);
        },
        initializeDimension: (initializedDimension: string): void => {
            if (initializedDimension) {
                this.initializedDimensions.add(initializedDimension);
            }
        },
        dimensionSelectedAsync: async (selectedDimensionId: number, selectedDimensionValueId: string): Promise<void> => {
            this.dimensions[selectedDimensionId] = selectedDimensionValueId;
            // Only trigger _updateDimensions when all dimensions are initialized
            if (this.initializedDimensions.size === this.productDetails?.product?.Dimensions?.length) {
                return this.dimensionUpdateQueue
                    .enqueue(async () => {
                        return this._updateDimensions();
                    })
                    .catch((error: unknown) => {
                        // Ignore discarded processes.
                        if (error !== FinitePromiseQueueError.ProcessWasDiscardedFromTheQueue) {
                            throw error;
                        }
                    });
            }
        },
        getDropdownName: (dimensionType: number, resources: IQuickviewResources): string => {
            return this._getDropdownName(dimensionType, resources);
        },
        changeModalOpen: (isModalOpen: boolean): void => {
            this._hideQuickViewDialog();
        },
        changeUpdatingDimension: (isUpdatingDimension: boolean): void => {
            this.setState({ isUpdatingDimension });
        },
        updateKeyInPrice: (customPrice: number): void => {
            // Remove custom amount error when updating the custom price
            const errorState = { ...this.state.errorState };
            errorState.customAmountError = undefined;

            this.setState({ isPriceKeyedIn: true, keyInPriceAmount: customPrice, errorState });
            this._updatePrice(this.state.productPrice, customPrice);
        }
    };

    private readonly defaultGalleryImageSettings: IImageSettings = {
        viewports: {
            xs: { q: 'w=767&h=767&m=8', w: 0, h: 0 },
            sm: { q: 'w=600&h=600&m=8', w: 0, h: 0 },
            md: { q: 'w=600&h=772&m=8', w: 0, h: 0 },
            lg: { q: 'h=772&m=8', w: 0, h: 0 }
        },
        lazyload: true,
        cropFocalRegion: true
    };

    private readonly defaultThumbnailImageSettings: IImageSettings = {
        viewports: {
            xs: { q: 'w=100&m=8', w: 100, h: 0 },
            lg: { q: 'w=100&m=8', w: 100, h: 0 }
        },
        lazyload: true,
        cropFocalRegion: true
    };

    public constructor(props: IQuickviewProps<IQuickviewData>) {
        super(props);
        this.state = {
            modalOpen: false,
            quantity: 1,
            min: undefined,
            max: undefined,
            errorState: {
                configureErrors: {}
            },
            selectedProduct: undefined,
            productPrice: undefined,
            productDeliveryOptions: undefined,
            isUpdatingDimension: false,
            activeIndex: 0,
            animating: false,
            mediaGalleryItems: undefined,
            isDataLoaded: false
        };

        this._quickViewCloseButtonclick = this._quickViewCloseButtonclick.bind(this);
        this.telemetryContent = getTelemetryObject(props.context.request.telemetryPageName!, props.friendlyName, props.telemetry);
    }

    /**
     * React should component udpate function.
     * @param nextProps - Next Props.
     * @param nextState - Next State.
     * @returns Boolean - Whether the module will rerender or not.
     */
    public shouldComponentUpdate(nextProps: IQuickviewProps<IQuickviewData>, nextState: IBuyboxState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        const {
            config: { className = '' },
            resources
        } = this.props;
        const { max } = this.state;
        const product = this.productDetails?.product ? this.productDetails.product : undefined;
        const props = this.props as IBuyboxExtentedProps<IBuyboxCommonData>;
        const defaultMinimumKeyInPrice = 10;
        const defaultMaximumKeyInPrice = 100;
        const isMobileDevice = isMobile({ variant: VariantType.Viewport, context: this.props.context.request }) === 'xs';
        const viewprops: IQuickviewViewProps = {
            ...(this.props as IQuickviewExtentedProps<IQuickviewData>),
            state: this.state,
            productDetails: this.productDetails,
            isModalOpen: this.state.modalOpen!,
            quickView: {
                moduleProps: this.props,
                className: classnames('ms-quickView', className),
                tag: 'div'
            },
            isMobileDevice,
            quickViewButton: (
                <button className='ms-quickView__button' onClick={this.onClickHandler} aria-label={resources.quickViewbuttonText}>
                    {resources.quickViewbuttonText}
                </button>
            ),
            ModalContainer: {
                moduleProps: this.props,
                tag: Modal,
                className: classnames('ms-quickView__dialog', 'ms-sidebar-quickview_dialog'),
                isOpen: this.state.modalOpen,
                'aria-label': format(resources.quickViewAriaLabel, this.productDetails?.product?.Name),
                toggle: this._quickViewCloseButtonclick,
                modalTransition: { timeout: 0 },
                shouldUpdateFocusToFirstElement: this.state.isDataLoaded
            },
            ModalHeaderContainer: {
                tag: ModalHeader,
                className: 'ms-quickView__header',
                toggle: this._quickViewCloseButtonclick
            },
            ModalFooterContainer: {
                tag: ModalFooter,
                className: 'ms-quickView__footer'
            },
            ModalHeaderContent: '',
            ModalBodyContainer: {
                tag: ModalBody,
                className: 'ms-quickView__body'
            },
            cartContainerProps: {
                className: 'ms-quickView__product-add-to-cart'
            },
            ProductInfoContainerProps: {
                className: 'ms-quickView__content'
            },
            MediaGalleryContainerProps: {
                className: 'ms-quickView__media-gallery'
            },
            seeDetailsbutton: this._renderSeeDetailButton(product),
            loading: !this.state.isDataLoaded && (
                <Spinner className='ms-quickView__loading__icon' label={resources.loadingText} size={SpinnerSize.large} />
            ),
            callbacks: this.quickViewCallbacks,
            title: this.state.isDataLoaded && getBuyboxProductTitle(props, this.productDetails),
            description: this.state.isDataLoaded && getBuyboxProductDescription(props, this.productDetails),
            configure: this.state.isDataLoaded
                ? getBuyboxProductConfigure(props, this.state, this.quickViewCallbacks, this.productDetails, this.props.selectedDimensions)
                : undefined,
            price: product?.IsGiftCard ? undefined : this.state.isDataLoaded && getBuyboxProductPrice(props, this.state),
            unitOfMeasure: this.state.isDataLoaded && getBuyboxProductUnitOfMeasure(props, this.productDetails),
            rating:
                this.state.isDataLoaded && !this.props.context.app.config.hideRating && getBuyboxProductRating(props, this.productDetails),
            addToCart: this.state.isDataLoaded
                ? getBuyboxAddToCart(
                      props,
                      this.state,
                      this.quickViewCallbacks,
                      defaultMinimumKeyInPrice,
                      defaultMaximumKeyInPrice,
                      this.productDetails
                  )
                : undefined,
            keyInPrice:
                this.state.isDataLoaded && this.props.config.enableKeyInPrice && this.state.isCustomPriceSelected
                    ? getBuyboxKeyInPrice(props, this.state, this.quickViewCallbacks)
                    : undefined,
            quantity: product?.IsGiftCard ? undefined : this._renderQuantity(this.props, this.state, this.quickViewCallbacks),
            inventoryLabel: this.state.isDataLoaded && getBuyBoxInventoryLabel(props, this.productDetails),
            addToWishlist: this.state.isDataLoaded
                ? getBuyboxProductAddToWishlist(props, this.state, this.quickViewCallbacks, this.productDetails)
                : undefined,
            quantityLimitsMessages: this.state.isDataLoaded && getQuantityLimitsMessages(props, this.state),
            max,
            CarouselProps: this._renderCarousel(),
            Thumbnails: this._renderThumbnails()
        };

        return this.props.renderView(viewprops) as React.ReactElement;
    }

    /**
     * Method to render detail button on quick view.
     * @param product - Simple product object.
     * @returns JSX element.
     */
    private readonly _renderSeeDetailButton = (product: SimpleProduct | undefined): JSX.Element => {
        const { config } = this.props;
        const payLoad = getPayloadObject('click', this.telemetryContent, TelemetryConstant.seeDetails, '');
        const attributes = getTelemetryAttributes(this.telemetryContent, payLoad);

        return (
            <Button
                className='ms-quickView__seeDetailsbutton'
                onClick={onTelemetryClick(this.telemetryContent, payLoad, TelemetryConstant.seeDetails)}
                {...attributes}
                aria-label={config.seeDetailsLinkText}
                href={this._getProductURL(product)}
            >
                {config.seeDetailsLinkText}
            </Button>
        );
    };

    /**
     * Method to return carousel.
     * @returns Node props.
     */
    private readonly _renderCarousel = (): INodeProps => {
        const { config, resources } = this.props;
        let mediaGalleryItems: ReactNode[];
        let keys: (string | undefined)[];
        const galleryImageSettings = config.galleryImageSettings;
        if (galleryImageSettings) {
            galleryImageSettings.cropFocalRegion = true;
        }

        if (ArrayExtensions.hasElements(this.state.mediaGalleryItems)) {
            mediaGalleryItems = this.state.mediaGalleryItems.map((item: IImageData, index: number) => {
                return this._renderCarouselItemImageView(item, galleryImageSettings || this.defaultGalleryImageSettings, index);
            });
            keys = [...this.state.mediaGalleryItems.map(item => item.src)];
        } else {
            mediaGalleryItems = [this._renderEmptyImage(galleryImageSettings)];
            keys = ['empty'];
        }

        const props: IComponentNodeProps<ICarouselProps> = {
            tag: Carousel,
            className: 'ms-media-gallery__carousel',
            items: mediaGalleryItems,
            activeIndex: this.state.activeIndex ?? 0,
            next: this.next,
            previous: this.previous,
            interval: false,
            directionTextPrev: resources.previousScreenshotFlipperText,
            directionTextNext: resources.nextScreenshotFlipperText,
            indicatorAriaText: resources.ariaLabelForSlide,
            onIndicatorsClickHandler: this.goToIndex,
            handleOnExited: this.onExited,
            handleOnExiting: this.onExiting,
            key: keys
        };

        return props;
    };

    /**
     * Method to render thumbnails.
     * @returns QuickView Thumbnails view props.
     */
    private readonly _renderThumbnails = (): IQuickViewThumbnailsViewProps => {
        const { config, id, resources } = this.props;

        const thumbnailImageSettings = config.thumbnailImageSettings;
        if (thumbnailImageSettings) {
            thumbnailImageSettings.cropFocalRegion = true;
        }

        let mediaGalleryItems: IQuickViewThumbnailItemViewProps[];
        let keys: (string | undefined)[];
        if (ArrayExtensions.hasElements(this.state.mediaGalleryItems)) {
            mediaGalleryItems = this.state.mediaGalleryItems.map((item: IImageData, index: number) => {
                return this._getThumbnailItem(
                    item,
                    thumbnailImageSettings ?? this.defaultThumbnailImageSettings,
                    index,
                    this.state.activeIndex!
                );
            });
            keys = [...this.state.mediaGalleryItems.map(item => item.src)];
        } else {
            mediaGalleryItems = [];
            keys = [];
        }

        return {
            ThumbnailsContainerProps: { className: 'ms-media-gallery__thumbnails-container' },
            SingleSlideCarouselComponentProps: {
                tag: SingleSlideCarousel,
                className: 'ms-media-gallery__thumbnails',
                flipperPrevLabel: resources.previousScreenshotFlipperText,
                flipperNextLabel: resources.nextScreenshotFlipperText,
                parentId: id,
                useTabList: true,
                key: JSON.stringify(keys)
            } as IComponentNodeProps<ISingleSlideCarouselProps>,
            items: mediaGalleryItems
        };
    };

    private _updateMediaItems(lastUpdatedTime: number): void {
        const product = this.productDetails?.product;
        if (!this.state.mediaGalleryItems && product?.PrimaryImageUrl) {
            this.setState({
                mediaGalleryItems: [this._mapProductToImageData(product)],
                lastUpdate: lastUpdatedTime
            });
        }
    }

    private _updatePrice(newPrice: ProductPrice | undefined, customPrice: number | undefined = this.state.keyInPriceAmount): void {
        if (this.state.isCustomPriceSelected && newPrice) {
            newPrice.CustomerContextualPrice = customPrice;
        }
        this.setState({ productPrice: newPrice });
    }

    private readonly _updateDimensions = async (): Promise<void> => {
        const {
            context: {
                actionContext,
                request: {
                    apiSettings: { channelId }
                }
            }
        } = this.props;

        const { product, productDimensions } = this.productDetails!;

        if (!product || !productDimensions) {
            return;
        }

        const dimensionsToUpdate: { [id: number]: string } = { ...this.dimensions };
        this.setState({ isUpdatingDimension: true });

        // Step 1: Clear error state to display relevant errors
        if (this.state.errorState.otherError || this.state.errorState.quantityError) {
            const clearErrorState = { ...this.state.errorState };
            clearErrorState.otherError = undefined;
            if (this.state.errorState.errorHost === 'ADDTOCART') {
                clearErrorState.quantityError = undefined;
                clearErrorState.errorHost = undefined;
            }
            this.setState({ errorState: clearErrorState });
        }

        // Step 2: Clear any errors indicating the dimension wasn't selected
        for (const key of Object.keys(dimensionsToUpdate)) {
            if (this.state.errorState.configureErrors[key]) {
                const errorState = { ...this.state.errorState };
                errorState.configureErrors[key] = undefined;

                this.setState({ errorState });
            }
        }

        // Step 3, Build the actually selected dimensions, prioritizing the information in state
        // over the information in data
        const mappedDimensions = productDimensions
            .map(dimension => {
                return {
                    DimensionTypeValue: dimension.DimensionTypeValue,
                    DimensionValue:
                        this._updateDimensionValue(dimension, dimensionsToUpdate[dimension.DimensionTypeValue]) || dimension.DimensionValue,
                    ExtensionProperties: dimension.ExtensionProperties
                };
            })
            .filter(dimension => {
                return dimension && dimension.DimensionValue;
            });

        // Step 4. Use these dimensions hydrate the product. Wrap this in a promise
        // so that places like add to cart can await it
        const selectedProduct = new Promise<ISelectedProduct | null>(async resolve => {
            const newProduct = await getSelectedVariant(
                new SelectedVariantInput(
                    product.MasterProductId ? product.MasterProductId : product.RecordId,
                    channelId,
                    mappedDimensions,
                    undefined,
                    this.props.context.request
                ),
                actionContext
            );
            if (newProduct) {
                // @ts-expect-error
                this.productDetails.productDimensions = await getDimensionsForSelectedVariant(
                    new GetDimensionsForSelectedVariantInput(
                        newProduct.MasterProductId ? newProduct.MasterProductId : newProduct.RecordId,
                        channelId,
                        mappedDimensions,
                        this.props.context.request
                    ),
                    actionContext
                );
            }

            resolve(newProduct);
        });

        this.setState({ selectedProduct });
        const variantProduct = await selectedProduct;

        if (variantProduct && this.productDetails) {
            // Step 5. Use these dimensions hydrate the inventory. Wrap this in a promise
            // so that places like add to cart can await it
            this.productDetails.product = variantProduct;
            let images: IImageData[] = await this.getImagesForProduct(product, variantProduct);
            images = this._filterMasterImageFromVariant(images, variantProduct);
            this.setState({
                mediaGalleryItems: [...images],
                activeIndex: 0,
                lastUpdate: Date.now()
            });

            const newAvailableQuantity = await getProductAvailabilitiesForSelectedVariant(
                new ProductAvailabilitiesForSelectedVariantInput(variantProduct.RecordId, channelId),
                actionContext
            );

            this.productDetails.productAvailableQuantity = newAvailableQuantity!;

            const isCustompriceSelected = variantProduct.Dimensions?.find(
                dimension => dimension.DimensionTypeValue === 4 && dimension.DimensionValue?.Value?.toLowerCase() === 'custom'
            );

            if (isCustompriceSelected) {
                this.setState({ isCustomPriceSelected: true });
            } else {
                // Remove custom amount error when unselect the custom amount
                const errorState = { ...this.state.errorState };
                errorState.customAmountError = undefined;

                this.setState({ isCustomPriceSelected: false, isPriceKeyedIn: false, errorState });
            }

            if (newAvailableQuantity && newAvailableQuantity.length > 0) {
                this.setState({ productAvailableQuantity: newAvailableQuantity[0] });
            } else {
                this.setState({ productAvailableQuantity: undefined });
            }

            // Step 6. Use these dimensions hydrate the product price.
            const newPrice = await getPriceForSelectedVariant(
                new PriceForSelectedVariantInput(variantProduct.RecordId, channelId),
                actionContext
            );

            if (newPrice) {
                this._updatePrice(newPrice);
            }

            const RetailMulitplePickupMFeatureState = this.props.data.featureState.result?.find(
                featureState => featureState.Name === 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature'
            );

            // Step 7. Use these dimensions hydrate the product delivery options.
            const newDeliveryOptions = await getDeliveryOptionsForSelectedVariant(
                new GetDeliveryOptionsForSelectedVariantInput(
                    variantProduct.RecordId,
                    channelId,
                    undefined,
                    undefined,
                    RetailMulitplePickupMFeatureState?.IsEnabled
                ),
                actionContext
            );

            if (newDeliveryOptions) {
                this.setState({ productDeliveryOptions: newDeliveryOptions });
            }

            this.setState({ isUpdatingDimension: false });
            await this._updateQuantitiesInState(variantProduct);
        }
    };

    private _getProductURL(product: SimpleProduct | undefined): string {
        if (!product || !msdyn365Commerce.isBrowser) {
            return '';
        }

        let productUrl = '';
        productUrl = getProductPageUrlSync(product.Name || '', product.RecordId, this.props.context.actionContext, undefined);

        const fullUrl = new URL(productUrl, window.location.href);
        product.Dimensions?.map(dimension => {
            const dimensionValue = dimension.DimensionValue?.Value;
            if (!StringExtensions.isNullOrWhitespace(dimensionValue)) {
                const dimensionName = convertProductDimensionTypeToDimensionTypes(dimension.DimensionTypeValue);
                fullUrl.searchParams.set(dimensionName, dimensionValue!);
            }
        });
        return fullUrl.href;
    }

    private shouldUseCmsAltText = (): boolean => {
        if (this.props.config.altTextSource === 'product') {
            return false;
        } else {
            return true;
        }
    };

    private async _updateQuantitiesInState(product: SimpleProduct): Promise<void> {
        const isOrderQuantityLimitsFeatureEnabled = await this._isOrderQuantityLimitsFeatureEnabled();
        const isChannelLimitsFeatureEnabled = await this._isChannelLimitsFeatureEnabled();

        const min: number = this._getMinQuantityForCartLineItem(isOrderQuantityLimitsFeatureEnabled, product);
        const max: number = this._getMaxQuantityForCartLineItem(
            isChannelLimitsFeatureEnabled || isOrderQuantityLimitsFeatureEnabled,
            product
        );
        let quantity: number = this._getQuantity(product, isOrderQuantityLimitsFeatureEnabled);
        quantity = Math.max(quantity, min);

        this.setState({
            min,
            max,
            quantity
        });
    }

    private _getMinQuantityForCartLineItem(isOrderQuantityLimitsFeatureEnabled: boolean, product: SimpleProduct): number {
        if (isOrderQuantityLimitsFeatureEnabled && product?.Behavior?.MinimumQuantity && product.Behavior.MinimumQuantity > 0) {
            return product.Behavior.MinimumQuantity;
        }

        return 1;
    }

    private _getMaxQuantityForCartLineItem(isQuantityLimitsFeatureEnabled: boolean, product: SimpleProduct): number {
        if (isQuantityLimitsFeatureEnabled && product?.Behavior?.MaximumQuantity && product.Behavior.MaximumQuantity > 0) {
            return product.Behavior.MaximumQuantity;
        }

        return updateMaxQuantityForCartLineItem(this.props.context.app.config.maxQuantityForCartLineItem);
    }

    private _getQuantity(product: SimpleProduct, isOrderQuantityLimitsFeatureEnabled: boolean): number {
        const { quantity } = this.state;
        let defaultQuantity = 1;

        if (quantity !== defaultQuantity || !isOrderQuantityLimitsFeatureEnabled) {
            return quantity;
        }

        const cartConfiguration = this.props.data.cartConfiguration;
        const applyDefaultOrderSettingsForCartLine = cartConfiguration?.result?.ValidateDefaultOrderSettingsPerLine ?? false;
        if (!applyDefaultOrderSettingsForCartLine) {
            return quantity;
        }

        if (product?.Behavior?.DefaultQuantity && product.Behavior.DefaultQuantity > 0) {
            defaultQuantity = product.Behavior.DefaultQuantity;
        }

        return defaultQuantity;
    }

    private _filterMasterImageFromVariant(images?: IImageData[], product?: ISelectedProduct | null): IImageData[] {
        const shouldHidePrimaryImages = this.props.config.shouldHideMasterProductImagesForVariant ?? true;
        let variantImages = images ?? [];
        const isVariantProduct =
            !ObjectExtensions.isNullOrUndefined(product?.MasterProductId) || !ObjectExtensions.isNullOrUndefined(product?.productVariant);
        const itemId = product?.ItemId;
        if (shouldHidePrimaryImages && isVariantProduct && itemId) {
            variantImages = variantImages.filter(item => {
                const isApplicableForChildEntities = item.additionalProperties?.isApplicableForChildEntities;
                return !isApplicableForChildEntities;
            });
            if (!ArrayExtensions.hasElements(variantImages)) {
                variantImages = images ?? [];
            }
        }
        return variantImages;
    }

    private readonly _updateDimensionValue = (
        productDimensionFull: ProductDimensionFull,
        newValueId: string | undefined
    ): ProductDimensionValue | undefined => {
        if (newValueId && productDimensionFull.DimensionValues) {
            return productDimensionFull.DimensionValues.find(dimension => dimension.RecordId === +newValueId);
        }

        return undefined;
    };

    private readonly _getDropdownName = (dimensionType: number, resources: IQuickviewResources): string => {
        const isGiftCard = this.productDetails?.product?.IsGiftCard;

        switch (dimensionType) {
            case 1: // ProductDimensionType.Color
                return resources.productDimensionTypeColor;
            case 2: // ProductDimensionType.Configuration
                return resources.productDimensionTypeConfiguration;
            case 3: // ProductDimensionType.Size
                return resources.productDimensionTypeSize;
            case 4: // ProductDimensionType.Style
                return isGiftCard ? resources.productDimensionTypeAmount : resources.productDimensionTypeStyle;
            default:
                return '';
        }
    };

    private async _isOrderQuantityLimitsFeatureEnabled(): Promise<boolean> {
        const featureStatuses = await this.props.data.featureState;

        const isFeatureEnabledInHq = featureStatuses?.find(
            featureState => featureState.Name === RetailDefaultOrderQuantityLimitsFeatureName
        )?.IsEnabled;
        if (!isFeatureEnabledInHq) {
            return false;
        }
        const useSiteBuilderSettings = featureStatuses?.find(
            featureState => featureState.Name === RevertToSiteBuilderOrderQuantityLimitsSettingsCRTFeatureName
        )?.IsEnabled;

        if (useSiteBuilderSettings) {
            const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
            if (defaultOrderQuantityLimitsFeatureConfig === 'none') {
                return false;
            }

            if (defaultOrderQuantityLimitsFeatureConfig === 'all') {
                return true;
            }
            let customerInfo;
            try {
                customerInfo = await this.props.data.customerInformation;
            } catch (error) {
                this.props.telemetry.information(error);
                this.props.telemetry.debug('Unable to receive Customer Information. May be user is not authorized');
                return false;
            }

            return (
                customerInfo &&
                ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
                    (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b))
            );
        } else {
            const cartConfiguration = await this.props.data.cartConfiguration;
            return !(cartConfiguration?.IgnoreOrderSettings ?? false);
        }
    }

    private async _isChannelLimitsFeatureEnabled(): Promise<boolean> {
        const featureStatuses = await this.props.data.featureState;

        const isChannelLimitsFeatureEnabledInHq = featureStatuses?.find(
            featureState => featureState.Name === EcommerceQuantityLimitConfigurationsFeatureName
        )?.IsEnabled;

        return isChannelLimitsFeatureEnabledInHq ?? false;
    }

    private readonly onExiting = () => {
        this.setState({ animating: true });
    };

    private readonly onExited = () => {
        this.setState({ animating: false });
    };

    private readonly next = (): void => {
        if (this.isLastItem() === undefined) {
            return;
        }

        const nextIndex = this.isLastItem() ? 0 : this.state.activeIndex! + 1;
        this.goToIndex(nextIndex);
    };

    private readonly previous = (): void => {
        const nextIndex = this.isFirstItem()
            ? this.state.mediaGalleryItems
                ? this.state.mediaGalleryItems.length - 1
                : 0
            : this.state.activeIndex! - 1;
        this.goToIndex(nextIndex);
    };

    private readonly goToIndex = (index: number): void => {
        this.setState({ activeIndex: index });
    };

    private _renderCarouselItemImageView(image: IImageData, imageSettings: IImageSettings, index: number): React.ReactNode {
        return <>{this._getCarouselItem(image, imageSettings, index)}</>;
    }

    private readonly _getCarouselItem = (image: IImageData, imageSettings: IImageSettings, index: number): React.ReactNode => (
        <Image
            requestContext={this.props.context.actionContext.requestContext}
            className='ms-media-gallery__item'
            {...image}
            gridSettings={this.props.context.request.gridSettings!}
            imageSettings={imageSettings}
            loadFailureBehavior='default'
            role='tabpanel'
            key={image.src}
            id={`${this.props.id}__carousel-item__${index}`}
        />
    );

    private readonly _getThumbnailItem = (
        image: IImageData,
        imageSettings: IImageSettings,
        index: number,
        modifiedActiveIndex: number
    ): IQuickViewThumbnailItemViewProps => {
        const classes = classnames(
            'ms-media-gallery__thumbnail-item',
            modifiedActiveIndex === index ? 'ms-media-gallery__thumbnail-item-active' : ''
        );

        return {
            ThumbnailItemContainerProps: {
                tag: 'li' as NodeTag,
                className: classes,
                role: 'tab',
                tabIndex: 0,
                key: index,
                'aria-label': image.altText,
                'aria-selected': modifiedActiveIndex === index,
                'aria-controls': `${this.props.id}__carousel-item__${index}`,
                onClick: this._generateOnThumbnailClick(index),
                onKeyDown: this._generateOnThumbnailKeyDown(index)
            },
            Picture: (
                <Image
                    requestContext={this.props.context.actionContext.requestContext}
                    className='ms-media-gallery__thumbnail'
                    {...image}
                    key={image.src}
                    gridSettings={this.props.context.request.gridSettings!}
                    imageSettings={imageSettings}
                    loadFailureBehavior='default'
                />
            )
        };
    };

    private readonly _generateOnThumbnailKeyDown = (index: number) => {
        return (event: React.KeyboardEvent) => {
            if (event.which === KeyCodes.Enter || event.which === KeyCodes.Space) {
                event.preventDefault();
                this.goToIndex(index);
            }
        };
    };

    private readonly _generateOnThumbnailClick = (index: number) => {
        return (event: React.MouseEvent<HTMLLIElement>) => {
            event.preventDefault();
            this.goToIndex(index);
        };
    };

    private _mapProductToImageData(product: SimpleProduct): IImageData {
        return {
            src: product.PrimaryImageUrl || '',
            altText: product.Name
        };
    }

    private readonly isFirstItem = () => this.state.activeIndex === 0;

    private readonly isLastItem = () => this.state.mediaGalleryItems && this.state.activeIndex === this.state.mediaGalleryItems.length - 1;

    private readonly onClickHandler = async (event: React.MouseEvent<HTMLElement>) => {
        return this._onClick(event, this.props);
    };

    private readonly _onClick = async (_event: React.MouseEvent<HTMLElement>, props: IQuickviewExtentedProps<IQuickviewData>) => {
        if (!ObjectExtensions.isNullOrUndefined(props.selectedProductId)) {
            const {
                context: {
                    actionContext,
                    request: {
                        apiSettings: { channelId }
                    }
                }
            } = this.props;

            if (this.props.selectedProductId) {
                this.setState({ modalOpen: true });
                const productId = this.props.selectedProductId;
                const selectedDimensions = this.props.selectedDimensions;
                this.productDetails = await getProductDetails(productId, channelId, actionContext, selectedDimensions);
                const { product, productPrice } = this.productDetails;
                const currentTime: number = Date.now();
                this._updateMediaItems(currentTime);
                if (productPrice) {
                    this._updatePrice(productPrice);
                }

                if (product) {
                    const { context } = this.props;
                    if (context.app.config.maxRecentlyViewedItemsCount > 0) {
                        RecentlyViewedState.instance(this.props.context, context.app.config.maxRecentlyViewedItemsCount, product.RecordId);
                    }
                    // Check if the product is service or not by product type
                    if (product.ItemTypeValue === ReleasedProductType.Service) {
                        this.setState({ isServiceItem: true });
                    }
                    await this._updateQuantitiesInState(product);
                    let images = await this.getImagesForProduct(product, product);
                    images = this._filterMasterImageFromVariant(images);
                    this.setState({
                        mediaGalleryItems: [...images],
                        activeIndex: 0,
                        lastUpdate: currentTime
                    });
                }
                this.setState({ isDataLoaded: true });
            }
        }
    };

    private getImagesForProduct = async (product: ISelectedProduct, variantProduct: ISelectedProduct): Promise<IImageData[]> => {
        let images: IImageData[];
        if (this.props.context.app?.config?.OmniChannelMedia) {
            images = await getProductImages(
                product.RecordId,
                this.shouldUseCmsAltText(),
                +this.props.context.request.apiSettings.channelId,
                this.props.context.actionContext,
                product.Name,
                product.productVariant ?? variantProduct
            );
        } else {
            images = await getValidProductImages(
                product.RecordId || 0,
                +this.props.context.request.apiSettings.channelId,
                this.props.context.actionContext,
                this.props.config.thumbnailImageSettings ?? this.defaultThumbnailImageSettings,
                product.productVariant ?? variantProduct
            );
        }
        return images;
    };

    private readonly _quickViewCloseButtonclick = () => {
        this._hideQuickViewDialog();
    };

    private _hideQuickViewDialog(): void {
        this.dimensions = [];
        this.setState({
            modalOpen: false,
            quantity: 1,
            min: undefined,
            max: undefined,
            errorState: {
                configureErrors: {}
            },
            selectedProduct: undefined,
            productPrice: undefined,
            productDeliveryOptions: undefined,
            isUpdatingDimension: false,
            productAvailableQuantity: undefined,
            lastUpdate: undefined,
            activeIndex: undefined,
            animating: undefined,
            mediaGalleryItems: [],
            isDataLoaded: false
        });
    }

    /**
     * Quantity Change Handler.
     * @param callbacks -Buybox callbacks.
     * @returns Update quantity.
     */
    private readonly onChangeHandler = (callbacks: IBuyboxCallbacks) => (newValue: number): boolean => {
        if (callbacks.updateQuantity) {
            return callbacks.updateQuantity(newValue);
        }
        return true;
    };

    private readonly _renderQuantity = (
        props: IQuickviewExtentedProps<IQuickviewData>,
        state: IBuyboxState,
        callbacks: IBuyboxCallbacks
    ): IBuyboxProductQuantityViewProps => {
        const { resources } = props;

        const {
            quantity,
            min,
            max,
            errorState: { quantityError }
        } = state;

        return {
            ContainerProps: {
                className: 'ms-quickView__quantity'
            },
            LabelContainerProps: {
                tag: 'label',
                className: 'ms-quickView__product-quantity-label',
                htmlFor: 'ms-quickView__product-quantity-input'
            },
            heading: <div className='ms-quickView__product-quantity-label-heading'>{resources.productQuantityHeading}</div>,
            errors: quantityError && (
                <span className='msc-alert msc-alert-noborder msc-alert-danger'>
                    <span className='msi-exclamation-triangle' aria-hidden='true' />
                    <span>{quantityError}</span>
                </span>
            ),
            input: (
                <IncrementalQuantity
                    id='ms-buybox__product-quantity-input'
                    min={min}
                    max={max}
                    currentCount={quantity}
                    onChange={this.onChangeHandler(callbacks)}
                    inputQuantityAriaLabel={resources.inputQuantityAriaLabel}
                    decrementButtonAriaLabel={resources.decrementButtonAriaLabel}
                    incrementButtonAriaLabel={resources.incrementButtonAriaLabel}
                    minQuantityText={resources.minQuantityText}
                    maxQuantityText={resources.maxQuantityText}
                    telemetryContent={this.telemetryContent}
                    disabled={this.state.isUpdatingDimension}
                />
            )
        };
    };

    private _renderEmptyImage(imageSettings: IImageSettings | undefined): React.ReactNode {
        return (
            <div className='ms-media-gallery__item'>
                <Image
                    requestContext={this.props.context.actionContext.requestContext}
                    className='ms-media-gallery__item__image'
                    src='empty'
                    gridSettings={this.props.context.request.gridSettings!}
                    imageSettings={imageSettings ?? this.defaultGalleryImageSettings}
                    loadFailureBehavior='empty'
                />
            </div>
        );
    }
}
export default Quickview;
