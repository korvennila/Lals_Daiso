/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { buildHydratedMockActionContext, buildMockModuleProps, ICultureInfoFormatter, IRequestContext } from '@msdyn365-commerce/core';
import { Address, AddressPurpose, AsyncResult, CountryRegionInfo, Customer, FeatureState } from '@msdyn365-commerce/retail-proxy';
import { IStoreSelectorStateManager } from '@msdyn365-commerce-modules/bopis-utilities';
import { mount, render, shallow } from 'enzyme';
import * as React from 'react';
import * as renderer from 'react-test-renderer';

import { AddressItemDisplayType, IAddressItem } from '@msdyn365-commerce-modules/address';
import AccountManagementAddress, {
    IAccountManagementAddressViewProps,
    IAccountManagementAddressViewState
} from '../account-management-address';
import { IAccountManagementAddressData } from '../account-management-address.data';
import {
    AddAddressHeadingTag,
    EditAddressHeadingTag,
    HeadingTag,
    IAccountManagementAddressConfig,
    IAccountManagementAddressProps,
    IAccountManagementAddressResources,
    OtherAddressSectionHeadingTag,
    PrimaryAddressSectionHeadingTag
} from '../account-management-address.props.autogenerated';
import AccountManagementAddressView from '../account-management-address.view';
import mockActionContext from '../mocks/action-context';
import MockTelemetry from '../mocks/MockTelemetry';

const addressItem: IAddressItem[] = [
    {
        name: 'name',
        type: 1001,
        label: 'name',
        maxLength: 100,
        displayType: AddressItemDisplayType.Input,
        isNewLine: true
    }
];

const address = {
    name: 'test12',
    FullAddress: 'usa',
    RecordId: 123,
    Street: 'A-12',
    StreetNumber: 'xyz',
    County: 'USA',
    CountyName: 'USA',
    City: 'USA'
};

const mockAddresses: Address[] = [
    {
        Name: 'Contoso Consulting USA',
        Id: '',
        FullAddress: '454 1st Street\nSuite 99\nRedmond, WA \n98052\nUSA',
        RecordId: 22565421841,
        Street: '454 1st Street\nSuite 99',
        StreetNumber: '',
        County: '',
        CountyName: '',
        City: 'Redmond',
        DistrictName: '',
        State: 'WA',
        StateName: 'Washington',
        ZipCode: '98052',
        ThreeLetterISORegionName: 'USA',
        Phone: '',
        PhoneRecordId: 0,
        PhoneExt: '',
        Email: '',
        EmailContent: '',
        EmailRecordId: 0,
        Url: '',
        UrlRecordId: 0,
        TwoLetterISORegionName: '',
        Deactivate: false,
        AttentionTo: '',
        BuildingCompliment: '',
        Postbox: '',
        TaxGroup: '',
        AddressTypeValue: 8,
        IsPrimary: false,
        IsPrivate: false,
        PartyNumber: '000000472',
        IsAsyncAddress: false,
        DirectoryPartyTableRecordId: 22565423403,
        DirectoryPartyLocationRecordId: 22565425606,
        DirectoryPartyLocationRoleRecordId: 0,
        LogisticsLocationId: '000000037',
        LogisticsLocationRecordId: 22565424302,
        LogisticsLocationExtRecordId: 0,
        LogisticsLocationRoleRecordId: 5637144583,
        PhoneLogisticsLocationRecordId: 0,
        PhoneLogisticsLocationId: '',
        EmailLogisticsLocationRecordId: 0,
        EmailLogisticsLocationId: '',
        UrlLogisticsLocationRecordId: 0,
        UrlLogisticsLocationId: '',
        ExpireRecordId: 0,
        SortOrder: 0,
        RoleCount: 1,
        DataAreaId: '',
        ExtensionProperties: []
    },
    {
        Name: 'Home address',
        Id: '',
        FullAddress: '712 1st Ave SW\nKirkland, WA \n98007\nUSA',
        RecordId: 52565470382,
        Street: '712 1st Ave SW',
        StreetNumber: '',
        County: 'KING',
        CountyName: 'King',
        City: 'Kirkland',
        DistrictName: '',
        State: 'WA',
        StateName: 'Washington',
        ZipCode: '98007',
        ThreeLetterISORegionName: 'USA',
        Phone: '',
        PhoneRecordId: 0,
        PhoneExt: '',
        Email: '',
        EmailContent: '',
        EmailRecordId: 0,
        Url: '',
        UrlRecordId: 0,
        TwoLetterISORegionName: '',
        Deactivate: false,
        AttentionTo: '',
        BuildingCompliment: '',
        Postbox: '',
        TaxGroup: '',
        AddressTypeValue: 6,
        IsPrimary: true,
        IsPrivate: false,
        PartyNumber: '000000472',
        IsAsyncAddress: false,
        DirectoryPartyTableRecordId: 22565423403,
        DirectoryPartyLocationRecordId: 22565425608,
        DirectoryPartyLocationRoleRecordId: 0,
        LogisticsLocationId: '000000759',
        LogisticsLocationRecordId: 22565426409,
        LogisticsLocationExtRecordId: 0,
        LogisticsLocationRoleRecordId: 5637144581,
        PhoneLogisticsLocationRecordId: 0,
        PhoneLogisticsLocationId: '',
        EmailLogisticsLocationRecordId: 0,
        EmailLogisticsLocationId: '',
        UrlLogisticsLocationRecordId: 0,
        UrlLogisticsLocationId: '',
        ExpireRecordId: 0,
        SortOrder: 0,
        RoleCount: 1,
        DataAreaId: '',
        ExtensionProperties: []
    }
];

const mockData: IAccountManagementAddressData = {
    address: AsyncResult.resolve([] as Address[]),
    countryRegions: AsyncResult.resolve([] as CountryRegionInfo[]),
    addressPurposes: AsyncResult.resolve([] as AddressPurpose[]),
    storeSelectorStateManager: {
        status: 'SUCCESS',
        result: {
            isMapApiLoaded: true
        }
    } as AsyncResult<IStoreSelectorStateManager>,
    customerInformation: AsyncResult.resolve({} as Customer),
    featureState: ([
        {
            Name: 'Test',
            IsEnabled: false
        }
    ] as unknown) as AsyncResult<FeatureState[]>
};

const mockDataApi: IAccountManagementAddressData = {
    address: AsyncResult.resolve([] as Address[]),
    countryRegions: AsyncResult.resolve([] as CountryRegionInfo[]),
    addressPurposes: AsyncResult.resolve([] as AddressPurpose[]),
    storeSelectorStateManager: {
        status: 'SUCCESS'
    } as AsyncResult<IStoreSelectorStateManager>,
    customerInformation: AsyncResult.resolve({} as Customer),
    featureState: AsyncResult.resolve([{}] as FeatureState[])
};

const mockConfig: IAccountManagementAddressConfig = {
    heading: {
        text: 'Address',
        tag: HeadingTag.h1
    },
    primaryAddressSectionHeading: {
        text: 'Address',
        tag: PrimaryAddressSectionHeadingTag.h2
    },
    otherAddressSectionHeading: {
        text: 'Address',
        tag: OtherAddressSectionHeadingTag.h2
    },
    addAddressHeading: {
        text: 'Address',
        tag: AddAddressHeadingTag.h1
    },
    editAddressHeading: {
        text: 'Address',
        tag: EditAddressHeadingTag.h1
    },
    autoSuggestionEnabled: true
};

const mockResources: IAccountManagementAddressResources = {
    accountProcessingPendingInfoMessage: 'Your information is being processed. Your account will be available to edit within 24 hours.',
    accountProcessingPendingInfoMessageCanAddAddress:
        'Your information is being processed. Your account will be available to edit within 24 hours. During this period, you can add new addresses to your account.',
    addressAddButtonText: 'Add address',
    addressPhoneFormatErrorMessage: 'Phone number format is not match',
    addressChangeCheckboxAriaLabel: 'Select address',
    addressAddButtonAriaLabel: 'Add address',
    addressPrimaryButtonText: 'Set as primary address',
    addressPrimaryButtonAriaLabel: 'Set {addressName} address as your primary address',
    addressEditButtonText: 'Edit',
    addressEditButtonAriaLabel: 'Edit {addressName} address',
    addressRemoveButtonText: 'Remove',
    addressRemoveButtonAriaLabel: 'Remove {addressName} address',
    addressSaveButtonText: 'Save',
    addressSaveButtonAriaLabel: 'Save',
    addressCancelButtonText: 'Cancel',
    addressCancelButtonAriaLabel: 'Cancel',
    addressStateDefaultSelectionText: 'Select state',
    addressNameLabel: 'Name',
    addressNameRequiredErrorMessage: 'Name is required',
    addressPhoneLabel: 'Phone',
    addressPhoneRequiredErrorMessage: 'Phone is required',
    addressZipCodeLabel: 'Zip code',
    addressZipCodeRequiredErrorMessage: 'Zip code is required',
    addressCityLabel: 'City',
    addressCityRequiredErrorMessage: 'City is required',
    addressCountyLabel: 'County',
    addressCountyRequiredErrorMessage: 'County is required',
    addressStateLabel: 'State',
    addressStateRequiredErrorMessage: 'State is required',
    addressThreeLetterISORegionNameLabel: 'Country',
    addressThreeLetterISORegionNameRequiredErrorMessage: 'Country is required',
    addressStreetLabel: 'Street',
    addressStreetRequiredErrorMessage: 'Street is required',
    addressDistrictLabel: 'District',
    addressDistrictNameLabel: 'District',
    addressDistrictRequiredErrorMessage: 'District is required',
    addressStreetNumberLabel: 'Street number',
    addressStreetNumberRequiredErrorMessage: 'Street number is required',
    addressBuildingComplimentLabel: 'Building compliment',
    addressBuildingComplimentRequiredErrorMessage: 'Building compliment is required',
    addressPostboxLabel: 'Post box',
    addressPostboxRequiredErrorMessage: 'Post box is required',
    addressHouseRULabel: 'House',
    addressHouseRURequiredErrorMessage: 'House is required',
    addressFlatRULabel: 'Flat',
    addressFlatRURequiredErrorMessage: 'Flat is required',
    addressCountryOKSMCodeRULabel: 'Countryoksmcode',
    addressCountryOKSMCodeRURequiredErrorMessage: 'Countryoksmcode field is required',
    addressErrorMessageTitle: 'Error message',
    addressGenericErrorMessage: 'Something went wrong. Please try again later',
    addressEmptyListAddressMessage: 'No addresses are present. Please add one.',
    addressIsPrimaryLabel: 'Set as primary account',
    addressAddressTypeValueLabel: 'Address type',
    removeAddressNotification: 'Address has been removed'
};

const mockActions = {};

// @ts-ignore: initializing test data
mockActionContext.requestContext = {
    channel: {
        RecordId: 123,
        BingMapsApiKey: 'key123',
        MinimumDepositPercentage: 1,
        QuoteExpirationDays: 1,
        CancellationChargePercentage: 1,
        BingMapsEnabled: true,
        PriceIncludesSalesTax: true,
        EnableProductRecommendations: true,
        RefundableShippingAmountWithoutApproval: 1,
        RefundShippingCharges: true,
        ReceiptSettingsValue: 1,
        CustomerAttributeGroupId: 1,
        ClientBookAttributeGroupId: 1,
        NotificationRefreshInterval: 1,
        IsInventoryAutomaticValidationEnabled: true,
        HideSystemInventoryInStockCount: true,
        EnablePriceChangeTracking: false
    }
};
const microsoft = {
    Maps: {
        loadModule: (moduleName: string, options?: { credentials: string; callback(): void; errorCallback(): void }) => {
            options?.callback();
            options?.errorCallback();
            return moduleName;
        },
        AutosuggestManager: () => {
            return {
                detachAutosuggest: (): void => {
                    // No value required.
                },
                dispose: (): void => {
                    // No value required.
                },
                attachAutosuggest: (
                    suggestionBoxId: string,
                    suggestionContainerId: string,
                    selectedSuggestionCallback: (result: Microsoft.Maps.ISuggestionResult) => void
                ): void => {
                    if (suggestionBoxId && suggestionContainerId) {
                        const result = {
                            formattedSuggestion: 'San Francisco, California, United States',
                            address: {
                                postalCode: 123
                            }
                        };

                        // @ts-expect-error -- Mocking result.
                        selectedSuggestionCallback(result);
                    }
                }
            };
        },
        ISuggestionResult: {
            formattedSuggestion: 'test'
        }
    }
};
// @ts-expect-error
global.Microsoft = microsoft;
describe('Account Management Address', () => {
    let moduleProps: IAccountManagementAddressProps<IAccountManagementAddressData>;
    beforeAll(() => {
        moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            resources: mockResources,

            // @ts-expect-error
            renderView: AccountManagementAddressView
        };
        moduleProps.context = {
            actionContext: mockActionContext,
            app: {},
            telemetry: new MockTelemetry(),
            request: {
                url: {
                    staticCdnUrl: 'testOriginUrl'
                },
                user: {
                    isAuthenticated: true
                },
                channel: {
                    PickupDeliveryModeCode: '70',
                    ChannelCountryRegionISOCode: 'US',
                    BingMapsApiKey: undefined,
                    BingMapsEnabled: false
                }
            } as IRequestContext,
            cultureFormatter: {} as ICultureInfoFormatter
        };
    });
    it('renders correctly', () => {
        const component: renderer.ReactTestRenderer = renderer.create(<AccountManagementAddress {...moduleProps} />);
        const tree = component.toJSON();
        expect(tree).toMatchSnapshot();
    });

    it('renders correctly View without key', () => {
        const modulePropsKey = { ...moduleProps };
        modulePropsKey.context.request.user.isAuthenticated = false;

        // @ts-expect-error
        modulePropsKey.context.actionContext.requestContext.channel?.BingMapsEnabled = false;
        const component = mount(<AccountManagementAddress {...modulePropsKey} />);
        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        expect(instance.currentOperation).toBe('List');
    });
    it('renders correctly View with key', () => {
        const modulePropsKey = { ...moduleProps };

        // @ts-expect-error
        modulePropsKey.context.actionContext.requestContext.channel?.BingMapsApiKey = undefined;
        const component = mount(<AccountManagementAddress {...modulePropsKey} />);

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        expect(instance.currentOperation).toBe('List');
    });
    it('renders correctly View', () => {
        const modulePropsView = { ...moduleProps };

        // @ts-expect-error
        modulePropsView.context.actionContext.requestContext.channel?.BingMapsEnabled = true;

        // @ts-expect-error
        modulePropsView.context.actionContext.requestContext.channel?.BingMapsApiKey = '1233';
        jest.spyOn(modulePropsView, 'renderView').mockImplementation(props => {
            // @ts-expect-error
            return <div props={props} />;
        });
        const component = mount(<AccountManagementAddress {...modulePropsView} />, {
            attachTo: document.body.firstElementChild as HTMLElement
        });

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance.addressFormat.getTranformedAddress = () => {
            return address;
        };

        // @ts-expect-error
        const suggestionSelected: Promise<void> = instance._onSuggestionSelected({});

        expect(suggestionSelected).toBeDefined();

        // @ts-expect-error
        expect(instance.addUpdateAddress.Street).toBe('');
    });

    it('cannot disable "add address" button when switch is false even when customer is async and "async address creation" feature is disabled', () => {
        // Arrange.
        const testData: IAccountManagementAddressData = {
            ...mockData,
            customerInformation: {
                result: { IsAsyncCustomer: true }
            } as AsyncResult<Customer>,
            address: {
                status: 'SUCCESS',
                result: mockAddresses
            } as AsyncResult<Address[]>,
            featureState: {
                status: 'SUCCESS',
                result: [
                    { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: false },
                    { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: true }
                ]
            } as AsyncResult<FeatureState[]>
        };

        const moduleProps = {
            ...(buildMockModuleProps(testData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: false } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).not.toBeTruthy();

        // Verify we are looking at the 'Add address' button.
        const { addButton } = showAddressList;
        expect(addButton).toBeTruthy();

        expect(
            render(addButton as React.ReactElement)
                .closest('button')
                .text()
        ).toEqual(mockResources.addressAddButtonText);

        // Verify 'disabled' attribute is set on the 'Add address' button.
        expect((addButton as React.ReactElement).props.disabled).toBeFalsy();

        component.unmount();
    });

    it('add address button is disabled when customer is async and "async address creation" feature is disabled', () => {
        // Arrange.
        // Update standard mock data.
        mockData.customerInformation = {
            result: { IsAsyncCustomer: true }
        } as AsyncResult<Customer>;
        mockData.address = {
            status: 'SUCCESS',
            result: mockAddresses
        } as AsyncResult<Address[]>;
        mockData.featureState = {
            status: 'SUCCESS',
            result: [{ Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: false }]
        } as AsyncResult<FeatureState[]>;

        // Enable the switch
        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: true } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).toBeTruthy();

        // Verify text displayed in info message bar is correct.
        expect(
            render(infoMessageBar as React.ReactElement)
                .closest('div')
                .text()
        ).toEqual(mockResources.accountProcessingPendingInfoMessage);

        // Verify we are looking at the 'Add address' button.
        const { addButton } = showAddressList;
        expect(addButton).toBeTruthy();

        expect(
            render(addButton as React.ReactElement)
                .closest('button')
                .text()
        ).toEqual(mockResources.addressAddButtonText);

        // Verify 'disabled' attribute is set on the 'Add address' button.
        expect((addButton as React.ReactElement).props.disabled).toBeTruthy();

        component.unmount();
    });

    it('add address button is enabled when customer is not async', () => {
        // Arrange.
        // Update standard mock data.
        mockData.customerInformation = {
            result: { IsAsyncCustomer: false }
        } as AsyncResult<Customer>;
        mockData.address = {
            status: 'SUCCESS',
            result: mockAddresses
        } as AsyncResult<Address[]>;
        mockData.featureState = {
            status: 'SUCCESS',
            result: [{ Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: false }]
        } as AsyncResult<FeatureState[]>;

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: false } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).not.toBeTruthy();

        // Verify we are looking at the 'Add address' button.
        const { addButton } = showAddressList;
        expect(addButton).toBeTruthy();

        expect(
            render(addButton as React.ReactElement)
                .closest('button')
                .text()
        ).toEqual(mockResources.addressAddButtonText);

        // Verify 'disabled' attribute is set on the 'Add address' button.
        expect((addButton as React.ReactElement).props.disabled).toBeFalsy();

        component.unmount();
    });

    it('add address button is enabled when customer is async and "async address creation" feature is enabled', () => {
        // Arrange.
        const testData: IAccountManagementAddressData = {
            ...mockData,
            customerInformation: {
                result: { IsAsyncCustomer: true }
            } as AsyncResult<Customer>,
            address: {
                status: 'SUCCESS',
                result: mockAddresses
            } as AsyncResult<Address[]>,
            featureState: {
                status: 'SUCCESS',
                result: [
                    { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: true },
                    { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: false }
                ]
            } as AsyncResult<FeatureState[]>
        };

        const moduleProps = {
            ...(buildMockModuleProps(testData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: true } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).toBeTruthy();

        // Verify text displayed in info message bar is correct.
        expect(
            render(infoMessageBar as React.ReactElement)
                .closest('div')
                .text()
        ).toEqual(mockResources.accountProcessingPendingInfoMessageCanAddAddress);

        // Verify we are looking at the 'Add address' button.
        const { addButton } = showAddressList;
        expect(addButton).toBeTruthy();

        expect(
            render(addButton as React.ReactElement)
                .closest('button')
                .text()
        ).toEqual(mockResources.addressAddButtonText);

        // Verify 'disabled' attribute is set on the 'Add address' button.
        expect((addButton as React.ReactElement).props.disabled).toBeFalsy();

        component.unmount();
    });

    it('add address button is disabled when customer is async and "async address creation" feature is enabled BUT edit async customer feature is also enabled.', () => {
        // Arrange.
        const testData: IAccountManagementAddressData = {
            ...mockData,
            customerInformation: {
                result: { IsAsyncCustomer: true }
            } as AsyncResult<Customer>,
            address: {
                status: 'SUCCESS',
                result: mockAddresses
            } as AsyncResult<Address[]>,
            featureState: {
                status: 'SUCCESS',
                result: [
                    { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: true },
                    { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: true }
                ]
            } as AsyncResult<FeatureState[]>
        };

        const moduleProps = {
            ...(buildMockModuleProps(testData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: true } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).toBeFalsy();

        // Verify we are looking at the 'Add address' button.
        const { addButton } = showAddressList;
        expect(addButton).toBeTruthy();

        expect(
            render(addButton as React.ReactElement)
                .closest('button')
                .text()
        ).toEqual(mockResources.addressAddButtonText);

        // Verify 'disabled' attribute is set on the 'Add address' button.
        expect((addButton as React.ReactElement).props.disabled).toBeFalsy();

        component.unmount();
    });

    it('edit, set primary, and remove button cannot be disabled when switch is false even when customer is async', () => {
        // Arrange.
        // Update standard mock data.
        mockData.customerInformation = {
            result: { IsAsyncCustomer: true }
        } as AsyncResult<Customer>;
        mockData.address = {
            status: 'SUCCESS',
            result: mockAddresses
        } as AsyncResult<Address[]>;
        mockData.featureState = {
            status: 'SUCCESS',
            result: [
                { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: false },
                { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: false }
            ]
        } as AsyncResult<FeatureState[]>;

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: false } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).not.toBeTruthy();

        showAddressList.primaryAddressList.items.forEach(item => {
            const { editButton, primaryButton, removeButton } = item;

            expect(editButton).toBeTruthy();
            expect(primaryButton).toBeTruthy();
            expect(removeButton).toBeTruthy();

            /** EDIT BUTTON VALIDATION */
            // Verify we are looking at the 'Edit' button.
            expect(
                render(editButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressEditButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((editButton as React.ReactElement).props.disabled).toBeFalsy();

            /** SET PRIMARY BUTTON VALIDATION */
            expect(
                render(primaryButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressPrimaryButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((primaryButton as React.ReactElement).props.disabled).toBeFalsy();

            /** REMOVE BUTTON VALIDATION */
            expect(
                render(removeButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressRemoveButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((removeButton as React.ReactElement).props.disabled).toBeFalsy();
        });

        component.unmount();
    });

    it('edit, set primary, and remove button disabled when customer is async', () => {
        // Arrange.
        // Update standard mock data.
        mockData.customerInformation = {
            result: { IsAsyncCustomer: true }
        } as AsyncResult<Customer>;
        mockData.address = {
            status: 'SUCCESS',
            result: mockAddresses
        } as AsyncResult<Address[]>;
        mockData.featureState = {
            status: 'SUCCESS',
            result: [
                { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: false },
                { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: false }
            ]
        } as AsyncResult<FeatureState[]>;

        // Enable the switch
        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: true } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).toBeTruthy();

        showAddressList.primaryAddressList.items.forEach(item => {
            const { editButton, primaryButton, removeButton } = item;

            expect(editButton).toBeTruthy();
            expect(primaryButton).toBeTruthy();
            expect(removeButton).toBeTruthy();

            /** EDIT BUTTON VALIDATION */
            // Verify we are looking at the 'Edit' button.
            expect(
                render(editButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressEditButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((editButton as React.ReactElement).props.disabled).toBeTruthy();

            /** SET PRIMARY BUTTON VALIDATION */
            expect(
                render(primaryButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressPrimaryButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((primaryButton as React.ReactElement).props.disabled).toBeTruthy();

            /** REMOVE BUTTON VALIDATION */
            expect(
                render(removeButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressRemoveButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((removeButton as React.ReactElement).props.disabled).toBeTruthy();
        });

        component.unmount();
    });

    it('edit, set primary, and remove button enabled when customer is async and both features enabled', () => {
        // Arrange.
        // Update standard mock data.
        mockData.customerInformation = {
            result: { IsAsyncCustomer: true }
        } as AsyncResult<Customer>;
        mockData.address = {
            status: 'SUCCESS',
            result: mockAddresses
        } as AsyncResult<Address[]>;
        mockData.featureState = {
            status: 'SUCCESS',
            result: [
                { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: true },
                { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: true }
            ]
        } as AsyncResult<FeatureState[]>;

        // Enable the switch
        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: true } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).toBeFalsy();

        showAddressList.primaryAddressList.items.forEach(item => {
            const { editButton, primaryButton, removeButton } = item;

            expect(editButton).toBeTruthy();
            expect(primaryButton).toBeTruthy();
            expect(removeButton).toBeTruthy();

            /** EDIT BUTTON VALIDATION */
            // Verify we are looking at the 'Edit' button.
            expect(
                render(editButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressEditButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((editButton as React.ReactElement).props.disabled).toBeFalsy();

            /** SET PRIMARY BUTTON VALIDATION */
            expect(
                render(primaryButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressPrimaryButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((primaryButton as React.ReactElement).props.disabled).toBeFalsy();

            /** REMOVE BUTTON VALIDATION */
            expect(
                render(removeButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressRemoveButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((removeButton as React.ReactElement).props.disabled).toBeFalsy();
        });

        component.unmount();
    });

    it('edit, set primary, and remove button enabled when customer is not async', () => {
        // Arrange.
        // Update standard mock data.
        mockData.customerInformation = {
            result: { IsAsyncCustomer: false }
        } as AsyncResult<Customer>;
        mockData.address = {
            status: 'SUCCESS',
            result: mockAddresses
        } as AsyncResult<Address[]>;
        mockData.featureState = {
            status: 'SUCCESS',
            result: [
                { Name: 'Dynamics.AX.Application.RetailAsyncAddressCreationFeature', IsEnabled: false },
                { Name: 'Dynamics.AX.Application.RetailEnableAsyncCustomerEditFeature', IsEnabled: false }
            ]
        } as AsyncResult<FeatureState[]>;

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };

        // @ts-expect-error
        const mockContext: ICoreContext = {
            actionContext: buildHydratedMockActionContext(),
            request: { locale: 'en-us', user: { isAuthenticated: true, customerAccountNumber: 'foo' } },
            app: { config: { canRenderAsyncCustomerDataAsUnmodifiable: false } }
        };

        moduleProps.context = mockContext;
        moduleProps.resources = mockResources;

        // Act.
        const component = mount(<AccountManagementAddress {...moduleProps} />);
        const viewProps: IAccountManagementAddressViewProps = component.childAt(0).props().props;
        const { infoMessageBar, showAddressList } = viewProps;

        // Assert.
        expect(moduleProps.renderView).toHaveBeenCalled();
        expect(viewProps).toBeDefined();
        expect(showAddressList).toBeDefined();
        expect(infoMessageBar).not.toBeTruthy();

        showAddressList.primaryAddressList.items.forEach(item => {
            const { editButton, primaryButton, removeButton } = item;

            expect(editButton).toBeTruthy();
            expect(primaryButton).toBeTruthy();
            expect(removeButton).toBeTruthy();

            /** EDIT BUTTON VALIDATION */
            // Verify we are looking at the 'Edit' button.
            expect(
                render(editButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressEditButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((editButton as React.ReactElement).props.disabled).toBeFalsy();

            /** SET PRIMARY BUTTON VALIDATION */
            expect(
                render(primaryButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressPrimaryButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((primaryButton as React.ReactElement).props.disabled).toBeFalsy();

            /** REMOVE BUTTON VALIDATION */
            expect(
                render(removeButton as React.ReactElement)
                    .closest('button')
                    .text()
            ).toEqual(mockResources.addressRemoveButtonText);

            // Verify 'disabled' attribute is set on the button.
            expect((removeButton as React.ReactElement).props.disabled).toBeFalsy();
        });

        component.unmount();
    });

    it('renders correctly AddressAddUpdate without address', () => {
        const modulePropsDemo = { ...moduleProps };
        modulePropsDemo.context.request.user.isAuthenticated = true;

        const component = mount(<AccountManagementAddress {...moduleProps} />, {
            attachTo: document.body.firstElementChild as HTMLElement
        });

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance._updateCurrentOperation('Add');
        component.mount();

        // @ts-expect-error
        instance._updateCurrentOperation('List');

        const response = {
            address
        };

        // @ts-expect-error
        instance._goToEditAddress(address);

        // @ts-expect-error
        instance._onRemoveAddress(address);

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        instance.addressFormat.validateAddressFormat = () => {
            return false;
        };

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        instance._onAddOrUpdateSuccess(response);

        // @ts-expect-error
        instance._onSubmitUpdatePrimaryAddress(address);

        // @ts-expect-error
        instance._onUpdatePrimaryAddressSuccess(response);
        component.mount();

        // @ts-expect-error
        instance._goToAddAddress(response);

        // @ts-expect-error
        instance.onAddressAddUpdate('city', 'usa');

        // @ts-expect-error
        instance.countryRegionId = 'usa';

        // @ts-expect-error
        expect(instance.addUpdateAddress.city).toBe('usa');
    });

    it('renders correctly AddressAddUpdate', () => {
        const modulePropsDemo = { ...moduleProps };
        modulePropsDemo.context.request.user.isAuthenticated = true;

        const component = mount(<AccountManagementAddress {...moduleProps} />, {
            attachTo: document.body.firstElementChild as HTMLElement
        });

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance._updateCurrentOperation('Add');
        component.mount();

        // @ts-expect-error
        instance._updateCurrentOperation('List');

        const response = {
            customerAddresses: [address, address],
            address
        };

        // @ts-expect-error
        instance._goToEditAddress(address);

        // @ts-expect-error
        instance._onRemoveAddress(address);

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        instance.addressFormat.validateAddressFormat = () => {
            return false;
        };

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        instance._onAddressAddUpdateSubmit();

        // @ts-expect-error
        instance._onAddOrUpdateSuccess(response);

        // @ts-expect-error
        instance._onSubmitUpdatePrimaryAddress(address);

        // @ts-expect-error
        instance._onUpdatePrimaryAddressSuccess(response);
        component.mount();

        // @ts-expect-error
        instance._goToAddAddress(response);

        // @ts-expect-error
        instance.onAddressAddUpdate('city', 'usa');

        // @ts-expect-error
        instance.countryRegionId = 'usa';

        // @ts-expect-error
        expect(instance.addUpdateAddress.city).toBe('usa');
    });

    it('renders correctly AddressAddUpdate 2', () => {
        const component = mount(<AccountManagementAddress {...moduleProps} />, {
            attachTo: document.body.firstElementChild as HTMLElement
        });

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance.addressFormat.getAddressFormat = () => {
            return addressItem;
        };
        const response = {
            customerAddresses: [address, address],
            address
        };

        // @ts-expect-error
        instance._onAddOrUpdateSuccess(response);

        // @ts-expect-error
        expect(instance.customerAddresses).toMatchObject([address, address]);
    });

    it('renders correctly AddressAddUpdate checkbox', () => {
        const component = mount(<AccountManagementAddress {...moduleProps} />, {
            attachTo: document.body.firstElementChild as HTMLElement
        });

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance._onAddressAddUpdateInputChange({ target: { type: 'checkbox' } });

        // @ts-expect-error
        instance._onAddressAddUpdateInputChange({ target: { type: 'input' } });

        // @ts-expect-error 1004
        instance._onAddressAddUpdateDropdownChange({ target: { name: 'input' } });

        // @ts-expect-error
        instance._onAddressAddUpdateDropdownChange({ target: { name: 'AddressTypeValue' } });

        // @ts-expect-error
        instance.addressFormat.getTwoLetterISORegionName = () => {
            return 'USA';
        };

        // @ts-expect-error
        instance._onAddressAddUpdateDropdownChange({ target: { name: 'ThreeLetterISORegionName' } });

        // @ts-expect-error
        instance.autoSuggest = undefined;

        // @ts-expect-error
        instance._onAddressAddUpdateDropdownChange({ target: { name: 'ThreeLetterISORegionName', value: 'usa' } });

        // @ts-expect-error
        expect(instance.countryRegionId).toBe('usa');
    });
    it('renders correctly AddressAddUpdate change country', () => {
        const modulePropsComponent = { ...moduleProps };
        modulePropsComponent.data = mockDataApi;
        const component = mount(<AccountManagementAddress {...modulePropsComponent} />, {
            attachTo: document.body.firstElementChild as HTMLElement
        });

        const instance = component.instance() as AccountManagementAddress;

        // @ts-expect-error
        instance.currentOperation = 'Add';

        // @ts-expect-error
        instance.addressFormat.getTwoLetterISORegionName = () => {
            return 'USA';
        };

        // Instance.autoSuggest = undefined;
        // @ts-expect-error
        instance.addressFormat.getAddressFormat = () => {
            return addressItem;
        };

        // @ts-expect-error
        instance.addUpdateAddress = address;

        // @ts-expect-error
        instance._onAddressAddUpdateDropdownChange({ target: { name: 'ThreeLetterISORegionName', value: 'USA' } });

        // @ts-expect-error
        expect(instance.countryRegionId).toBe('USA');
    });

    it('shouldComponentUpdate', () => {
        const props = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig) as IAccountManagementAddressProps<IAccountManagementAddressData>),
            renderView: jest.fn(props => {
                // @ts-expect-error
                return <div props={props} />;
            })
        };
        props.resources = mockResources;
        props.context.actionContext = moduleProps.context.actionContext;

        props.data = mockData;
        const accordion = shallow(<AccountManagementAddress {...props} />);
        const instance = accordion.instance() as AccountManagementAddress;
        const shouldUpdate = instance.shouldComponentUpdate(
            {} as IAccountManagementAddressProps<IAccountManagementAddressData>,
            {} as IAccountManagementAddressViewState
        );
        expect(shouldUpdate).toBe(true);
    });
});
